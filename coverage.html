
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/troubling/hummingbird/accountserver/engine.go (95.2%)</option>
				
				<option value="file1">github.com/troubling/hummingbird/accountserver/incoming_rep.go (77.9%)</option>
				
				<option value="file2">github.com/troubling/hummingbird/accountserver/replicator.go (80.5%)</option>
				
				<option value="file3">github.com/troubling/hummingbird/accountserver/schema.go (56.8%)</option>
				
				<option value="file4">github.com/troubling/hummingbird/accountserver/server.go (65.3%)</option>
				
				<option value="file5">github.com/troubling/hummingbird/accountserver/sqlite_backend.go (75.1%)</option>
				
				<option value="file6">github.com/troubling/hummingbird/bench/cbench.go (0.0%)</option>
				
				<option value="file7">github.com/troubling/hummingbird/bench/dbench.go (0.0%)</option>
				
				<option value="file8">github.com/troubling/hummingbird/bench/main.go (0.0%)</option>
				
				<option value="file9">github.com/troubling/hummingbird/client/client.go (0.0%)</option>
				
				<option value="file10">github.com/troubling/hummingbird/client/directclient.go (2.6%)</option>
				
				<option value="file11">github.com/troubling/hummingbird/client/userclient.go (0.0%)</option>
				
				<option value="file12">github.com/troubling/hummingbird/cmd/hummingbird/main.go (0.4%)</option>
				
				<option value="file13">github.com/troubling/hummingbird/common/conf/conf.go (87.6%)</option>
				
				<option value="file14">github.com/troubling/hummingbird/common/conf/policy.go (97.3%)</option>
				
				<option value="file15">github.com/troubling/hummingbird/common/conf/syncrealm.go (40.0%)</option>
				
				<option value="file16">github.com/troubling/hummingbird/common/freepool.go (100.0%)</option>
				
				<option value="file17">github.com/troubling/hummingbird/common/fs/atomic_linux.go (65.6%)</option>
				
				<option value="file18">github.com/troubling/hummingbird/common/fs/main.go (86.4%)</option>
				
				<option value="file19">github.com/troubling/hummingbird/common/fs/xattr.go (60.0%)</option>
				
				<option value="file20">github.com/troubling/hummingbird/common/fs/xattr_darwinlinux.go (81.8%)</option>
				
				<option value="file21">github.com/troubling/hummingbird/common/multipart.go (94.4%)</option>
				
				<option value="file22">github.com/troubling/hummingbird/common/pickle/pickle.go (82.8%)</option>
				
				<option value="file23">github.com/troubling/hummingbird/common/pickle/unmarshal.go (81.6%)</option>
				
				<option value="file24">github.com/troubling/hummingbird/common/pickle/unpickle.go (92.4%)</option>
				
				<option value="file25">github.com/troubling/hummingbird/common/ring/memcachering.go (78.9%)</option>
				
				<option value="file26">github.com/troubling/hummingbird/common/ring/ring.go (45.6%)</option>
				
				<option value="file27">github.com/troubling/hummingbird/common/srv/context.go (75.0%)</option>
				
				<option value="file28">github.com/troubling/hummingbird/common/srv/router.go (93.3%)</option>
				
				<option value="file29">github.com/troubling/hummingbird/common/srv/server.go (19.7%)</option>
				
				<option value="file30">github.com/troubling/hummingbird/common/test/test.go (69.0%)</option>
				
				<option value="file31">github.com/troubling/hummingbird/common/utils.go (68.1%)</option>
				
				<option value="file32">github.com/troubling/hummingbird/containerserver/engine.go (97.3%)</option>
				
				<option value="file33">github.com/troubling/hummingbird/containerserver/incoming_rep.go (77.9%)</option>
				
				<option value="file34">github.com/troubling/hummingbird/containerserver/replicator.go (80.2%)</option>
				
				<option value="file35">github.com/troubling/hummingbird/containerserver/schema.go (78.9%)</option>
				
				<option value="file36">github.com/troubling/hummingbird/containerserver/server.go (78.9%)</option>
				
				<option value="file37">github.com/troubling/hummingbird/containerserver/sqlite_backend.go (77.5%)</option>
				
				<option value="file38">github.com/troubling/hummingbird/containerserver/update.go (83.3%)</option>
				
				<option value="file39">github.com/troubling/hummingbird/middleware/grep.go (100.0%)</option>
				
				<option value="file40">github.com/troubling/hummingbird/middleware/options.go (0.0%)</option>
				
				<option value="file41">github.com/troubling/hummingbird/middleware/recon.go (26.2%)</option>
				
				<option value="file42">github.com/troubling/hummingbird/middleware/recover.go (55.6%)</option>
				
				<option value="file43">github.com/troubling/hummingbird/middleware/validaterequest.go (80.0%)</option>
				
				<option value="file44">github.com/troubling/hummingbird/objectserver/auditor.go (93.3%)</option>
				
				<option value="file45">github.com/troubling/hummingbird/objectserver/backend.go (81.9%)</option>
				
				<option value="file46">github.com/troubling/hummingbird/objectserver/main.go (62.6%)</option>
				
				<option value="file47">github.com/troubling/hummingbird/objectserver/objengine.go (77.8%)</option>
				
				<option value="file48">github.com/troubling/hummingbird/objectserver/priorityrep.go (44.6%)</option>
				
				<option value="file49">github.com/troubling/hummingbird/objectserver/repconn.go (67.7%)</option>
				
				<option value="file50">github.com/troubling/hummingbird/objectserver/replicator.go (81.9%)</option>
				
				<option value="file51">github.com/troubling/hummingbird/objectserver/repsrv.go (63.0%)</option>
				
				<option value="file52">github.com/troubling/hummingbird/objectserver/swiftobjeng.go (75.8%)</option>
				
				<option value="file53">github.com/troubling/hummingbird/objectserver/update.go (97.6%)</option>
				
				<option value="file54">github.com/troubling/hummingbird/probe/base.go (92.9%)</option>
				
				<option value="file55">github.com/troubling/hummingbird/proxyserver/accounthandlers.go (0.0%)</option>
				
				<option value="file56">github.com/troubling/hummingbird/proxyserver/constraints.go (92.7%)</option>
				
				<option value="file57">github.com/troubling/hummingbird/proxyserver/containerhandlers.go (22.9%)</option>
				
				<option value="file58">github.com/troubling/hummingbird/proxyserver/main.go (0.0%)</option>
				
				<option value="file59">github.com/troubling/hummingbird/proxyserver/middleware/acl.go (100.0%)</option>
				
				<option value="file60">github.com/troubling/hummingbird/proxyserver/middleware/authtoken.go (80.3%)</option>
				
				<option value="file61">github.com/troubling/hummingbird/proxyserver/middleware/catcherror.go (0.0%)</option>
				
				<option value="file62">github.com/troubling/hummingbird/proxyserver/middleware/context.go (21.8%)</option>
				
				<option value="file63">github.com/troubling/hummingbird/proxyserver/middleware/copy.go (83.3%)</option>
				
				<option value="file64">github.com/troubling/hummingbird/proxyserver/middleware/cors.go (42.4%)</option>
				
				<option value="file65">github.com/troubling/hummingbird/proxyserver/middleware/formpost.go (75.0%)</option>
				
				<option value="file66">github.com/troubling/hummingbird/proxyserver/middleware/healthcheck.go (0.0%)</option>
				
				<option value="file67">github.com/troubling/hummingbird/proxyserver/middleware/keystoneauth.go (0.0%)</option>
				
				<option value="file68">github.com/troubling/hummingbird/proxyserver/middleware/largeobject.go (64.8%)</option>
				
				<option value="file69">github.com/troubling/hummingbird/proxyserver/middleware/logging.go (0.0%)</option>
				
				<option value="file70">github.com/troubling/hummingbird/proxyserver/middleware/multirange.go (74.7%)</option>
				
				<option value="file71">github.com/troubling/hummingbird/proxyserver/middleware/ratelimit.go (21.7%)</option>
				
				<option value="file72">github.com/troubling/hummingbird/proxyserver/middleware/staticweb.go (74.1%)</option>
				
				<option value="file73">github.com/troubling/hummingbird/proxyserver/middleware/tempauth.go (63.0%)</option>
				
				<option value="file74">github.com/troubling/hummingbird/proxyserver/middleware/tempurl.go (93.3%)</option>
				
				<option value="file75">github.com/troubling/hummingbird/proxyserver/objhandlers.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "container/list"
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common/fs"
)

var (
        // ErrorNoSuchAccount is returned when a requested account doesn't exist.
        ErrorNoSuchAccount = fmt.Errorf("No such account.")
        // ErrorInvalidMetadata is returned for errors that violate the API metadata constraints.
        ErrorInvalidMetadata = fmt.Errorf("Invalid metadata value")
)

// AccountInfo represents the container_info database record - basic information about the container.
type AccountInfo struct {
        Account         string              `json:"account"`
        CreatedAt       string              `json:"created_at"`
        PutTimestamp    string              `json:"put_timestamp"`
        DeleteTimestamp string              `json:"delete_timestamp"`
        StatusChangedAt string              `json:"status_changed_at"`
        ObjectCount     int64               `json:"count"`
        BytesUsed       int64               `json:"bytes_used"`
        ContainerCount  int64               `json:"container_count"`
        Hash            string              `json:"hash"`
        ID              string              `json:"id"`
        RawMetadata     string              `json:"metadata"`
        Metadata        map[string][]string `json:"-"`
        MaxRow          int64               `json:"max_row"`
        invalid         bool
        updated         time.Time
        // This row isn't populated by GetInfo, it only exists for the times this is
        // serialized during replication.
        Point int64 `json:"point"`
}

type PolicyStat struct {
        StoragePolicyIndex int
        ContainerCount     int64
        ObjectCount        int64
        BytesUsed          int64
}

type policyStats struct {
        list    []*PolicyStat
        invalid bool
        updated time.Time
}

// ContainerListingRecord is the struct used for serializing objects in json and xml account listings.
type ContainerListingRecord struct {
        XMLName      xml.Name `xml:"container" json:"-"`
        Name         string   `xml:"name" json:"name"`
        Bytes        int64    `xml:"bytes" json:"bytes"`
        Count        int64    `xml:"count" json:"count"`
        LastModified string   `xml:"last_modified" json:"last_modified"`
}

// SubdirListingRecord is the struct used for serializing subdirs in json and xml account listings.
type SubdirListingRecord struct {
        XMLName xml.Name `xml:"subdir" json:"-"`
        Name2   string   `xml:"name,attr" json:"-"`
        Name    string   `xml:"name" json:"subdir"`
}

// ContainerRecord represents the object's data in-databaee, it is used by replication.
type ContainerRecord struct {
        Rowid              int64  `json:"ROWID"`
        Name               string `json:"name"`
        PutTimestamp       string `json:"put_timestamp"`
        DeleteTimestamp    string `json:"delete_timestamp"`
        ObjectCount        int64  `json:"object_count"`
        BytesUsed          int64  `json:"bytes_used"`
        Deleted            int    `json:"deleted"`
        StoragePolicyIndex int    `json:"storage_policy_index"`
}

// SyncRecord represents a row in the incoming_sync table.  It is used by replication.
type SyncRecord struct {
        SyncPoint int64  `json:"sync_point"`
        RemoteID  string `json:"remote_id"`
}

// Account is the interface implemented by an account
type Account interface {
        // GetInfo returns the AccountInfo struct for the account.
        GetInfo() (*AccountInfo, error)
        // PolicyStats returns the metrics for various policies in use by the account.
        PolicyStats() ([]*PolicyStat, error)
        // IsDeleted returns true if the account has been deleted.
        IsDeleted() (bool, error)
        // Delete deletes the account.
        Delete(timestamp string) error
        // ListContainers lists the account's container entries.
        ListContainers(limit int, marker string, endMarker string, prefix string, delimiter string, reverse bool) ([]interface{}, error)
        // GetMetadata returns the account's current metadata.
        GetMetadata() (map[string]string, error)
        // UpdateMetadata applies updates to the account's metadata.
        UpdateMetadata(updates map[string][]string) error
        // PutContainer adds a new container to the account.
        PutContainer(name string, putTimestamp string, deleteTimestamp string, objectCount int64, bytesUsed int64, storagePolicyIndex int) error
        // ID returns a unique identifier for the account.
        ID() string
        // Close frees any resources associated with the account.
        Close() error
}

// ReplicableAccount is an account that also implements the replication API.
type ReplicableAccount interface {
        Account
        // MergeItems merges object records into the account, with an optional remoteId.
        MergeItems(records []*ContainerRecord, remoteID string) error
        // ItemsSince returns count object records with a ROWID greater than start.
        ItemsSince(start int64, count int) ([]*ContainerRecord, error)
        // MergeSyncTable updates the account's incoming sync tables with new data.
        MergeSyncTable(records []*SyncRecord) error
        // SyncTable returns the account's current sync table.
        SyncTable() ([]*SyncRecord, error)
        // SyncRemoteData accepts a remote account's current status information and updates local records accordingly.
        SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*AccountInfo, error)
        // NewID gives the database a new unique identifier, which is used for incoming_sync entries.
        NewID() error
        // OpenDatabaseFile returns a consistent reader for the underlying database file.
        OpenDatabaseFile() (*os.File, func(), error)
        // CleanupTombstones removes any metadata and object tombstones older than reclaimAge seconds.
        CleanupTombstones(reclaimAge int64) error
        // RingHash returns the account's ring hash.
        RingHash() string
}

// AccountEngine is the interface of an object that creates and returns accounts.
type AccountEngine interface {
        // Get returns an Account, given a vars mapping.
        Get(vars map[string]string) (c Account, err error)
        // Return returns a Account to the engine, where it can close or retain them as it sees fit.
        Return(c Account)
        // Create creates a new account.  Returns true if the accoun t was created and a pointer to the account.
        Create(vars map[string]string, putTimestamp string, metadata map[string][]string) (bool, Account, error)
        // Close releases all cached accounts and any other retained resources.
        Close()

        // GetByHash returns a replicable database given its hash.  This will probably move from this interface once we
        // have replicator-&gt;replicator communication.
        GetByHash(device, hash, partition string) (c ReplicableAccount, err error)
        // Invalidate removes an account from the cache entirely.  This will probably also move, since it's only used by replication.
        Invalidate(c Account)
}

// My attempts at making this lruEngine reusable have not been successful, so for now it's sqlite-specific and not exported.
type lruEngine struct {
        deviceRoot     string
        hashPathPrefix string
        hashPathSuffix string
        maxSize        int
        cache          map[string]*lruEntry
        used           *list.List
        m              sync.Mutex
}

type lruEntry struct {
        c     Account
        inUse int
        elem  *list.Element
}

func (l *lruEngine) add(c Account) <span class="cov8" title="1">{
        if len(l.cache) &gt;= l.maxSize </span><span class="cov8" title="1">{
                for elem := l.used.Front(); elem != nil; elem = elem.Next() </span><span class="cov8" title="1">{
                        if entry, ok := elem.Value.(*lruEntry); ok &amp;&amp; entry.inUse == 0 </span><span class="cov8" title="1">{
                                l.used.Remove(elem)
                                delete(l.cache, entry.c.ID())
                                entry.c.Close()
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">holder := &amp;lruEntry{c: c, inUse: 1}
        holder.elem = l.used.PushBack(holder)
        l.cache[c.ID()] = holder</span>
}

func (l *lruEngine) accountLocation(vars map[string]string) string <span class="cov8" title="1">{
        h := md5.New()
        fmt.Fprintf(h, "%s/%s%s", l.hashPathPrefix, vars["account"], l.hashPathSuffix)
        hexHash := fmt.Sprintf("%032x", h.Sum(nil))
        suffix := hexHash[29:32]
        return filepath.Join(l.deviceRoot, vars["device"], "accounts", vars["partition"], suffix, hexHash, hexHash+".db")
}</span>

func (l *lruEngine) getbypath(accountFile string) (c Account, err error) <span class="cov8" title="1">{
        if !fs.Exists(accountFile) </span><span class="cov8" title="1">{
                return nil, ErrorNoSuchAccount
        }</span>
        <span class="cov8" title="1">ringHash := filepath.Base(filepath.Dir(accountFile))
        l.m.Lock()
        defer l.m.Unlock()
        if e := l.cache[ringHash]; e != nil </span><span class="cov8" title="1">{
                e.inUse++
                l.used.MoveToBack(e.elem)
                return e.c, nil
        }</span>
        <span class="cov8" title="1">if c, err = sqliteOpenAccount(accountFile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">l.add(c)
        return c, nil</span>
}

// Get returns a database given the incoming vars.
func (l *lruEngine) Get(vars map[string]string) (c Account, err error) <span class="cov8" title="1">{
        return l.getbypath(l.accountLocation(vars))
}</span>

// Create creates a new account.
func (l *lruEngine) Create(vars map[string]string, putTimestamp string, metadata map[string][]string) (bool, Account, error) <span class="cov8" title="1">{
        accountFile := l.accountLocation(vars)
        created := false
        c, err := l.Get(vars)
        if err != nil </span><span class="cov8" title="1">{
                created = true
                err = sqliteCreateAccount(accountFile, vars["account"], putTimestamp, metadata)
                if err == nil </span><span class="cov8" title="1">{
                        c, err = l.Get(vars)
                }</span>
        }<span class="cov0" title="0"> else {
                created, err = sqliteCreateExistingAccount(c, putTimestamp, metadata)
        }</span>
        <span class="cov8" title="1">return created, c, err</span>
}

// Return returns a database object to the engine.
func (l *lruEngine) Return(c Account) <span class="cov8" title="1">{
        l.m.Lock()
        if e := l.cache[c.ID()]; e != nil &amp;&amp; e.c == c </span><span class="cov8" title="1">{
                e.inUse--
        }</span><span class="cov8" title="1"> else {
                l.add(c)
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// GetByHash returns a database given its device and ring hash.
func (l *lruEngine) GetByHash(device, hash, partition string) (ReplicableAccount, error) <span class="cov8" title="1">{
        accountFile := filepath.Join(l.deviceRoot, device, "accounts", partition, hash[29:32], hash, hash+".db")
        c, err := l.getbypath(accountFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rc, ok := c.(ReplicableAccount)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Account does not support replication.")
        }</span>
        <span class="cov8" title="1">return rc, nil</span>
}

// Invalidate removes any cached backend connections to the database.
func (l *lruEngine) Invalidate(c Account) <span class="cov8" title="1">{
        defer c.Close()
        l.m.Lock()
        if e := l.cache[c.ID()]; e != nil &amp;&amp; e.c == c </span><span class="cov8" title="1">{
                l.used.Remove(e.elem)
                delete(l.cache, c.ID())
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// Close shuts down any backend account database connections and clears the caches.
func (l *lruEngine) Close() <span class="cov8" title="1">{
        for k, v := range l.cache </span><span class="cov8" title="1">{
                v.c.Close()
                delete(l.cache, k)
        }</span>
        <span class="cov8" title="1">l.used = l.used.Init()</span>
}

func newLRUEngine(deviceRoot, hashPathPrefix, hashPathSuffix string, accountCount int) *lruEngine <span class="cov8" title="1">{
        return &amp;lruEngine{
                deviceRoot:     deviceRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                maxSize:        accountCount,
                cache:          make(map[string]*lruEntry),
                used:           list.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "os"
        "path/filepath"

        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

func isOkayFilename(s string) bool <span class="cov8" title="1">{
        if len(s) &lt; 5 || len(s) &gt; 100 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, c := range s </span><span class="cov8" title="1">{
                if !((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') ||
                        (c == '-') || (c == '_') || (c == '.')) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// TmpUploadHandler handles uploading account files to the tmp directory for various replication strategies.
// This replaces the swift replicator's use of rsync.
func (server *AccountServer) TmpUploadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if !isOkayFilename(vars["filename"]) </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">filename := filepath.Join(server.driveRoot, vars["device"], "tmp", vars["filename"])
        if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">fp, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create file.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        if _, err := io.Copy(fp, request.Body); err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(filename)
                srv.GetLogger(request).Error("Error saving file contents.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span><span class="cov8" title="1"> else {
                srv.StandardResponse(writer, http.StatusCreated)
        }</span>
}

// AccountReplicateHandler handles the REPLICATE call for accounts.
func (server *AccountServer) AccountReplicateHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        // make sure there's a tmp dir to rsync to
        if err := os.MkdirAll(filepath.Join(server.driveRoot, vars["device"], "tmp"), 0777); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">message := []json.RawMessage{}
        decoder := json.NewDecoder(request.Body)
        if err := decoder.Decode(&amp;message); err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var op string
        if err := json.Unmarshal(message[0], &amp;op); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">extractArgs := func(args ...interface{}) error </span><span class="cov8" title="1">{
                if len(message)-1 &lt; len(args) </span><span class="cov8" title="1">{
                        return errors.New("Not enough arguments in payload.")
                }</span>
                <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(message[i+1], arg); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">switch op </span>{
        case "rsync_then_merge":<span class="cov8" title="1">
                var tmpFileName string
                if err := extractArgs(&amp;tmpFileName); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateRsyncThenMerge(request, vars, tmpFileName)
                        srv.StandardResponse(writer, status)
                }</span>
        case "complete_rsync":<span class="cov8" title="1">
                var tmpFileName string
                if err := extractArgs(&amp;tmpFileName); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateCompleteRsync(request, vars, tmpFileName)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_items":<span class="cov8" title="1">
                var records []*ContainerRecord
                var remoteID string
                if err := extractArgs(&amp;records, &amp;remoteID); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateMergeItems(request, vars, records, remoteID)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_syncs":<span class="cov8" title="1">
                var records []*SyncRecord
                if err := extractArgs(&amp;records); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateMergeSyncs(request, vars, records)
                        srv.StandardResponse(writer, status)
                }</span>
        case "sync":<span class="cov8" title="1">
                var maxRow int64
                var hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string
                if err := extractArgs(&amp;maxRow, &amp;hash, &amp;id, &amp;createdAt, &amp;putTimestamp, &amp;deleteTimestamp, &amp;metadata); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else if status, data := server.replicateSync(request, vars, maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata); status == http.StatusOK </span><span class="cov8" title="1">{
                        writer.WriteHeader(http.StatusOK)
                        writer.Write(data)
                }</span><span class="cov8" title="1"> else {
                        srv.StandardResponse(writer, status)
                }</span>
        default:<span class="cov8" title="1">
                srv.GetLogger(request).Error("Unknown replication op.", zap.String("op", op))
                srv.StandardResponse(writer, http.StatusBadRequest)</span>
        }
}

func (server *AccountServer) replicateRsyncThenMerge(request *http.Request, vars map[string]string, tmpFileName string) int <span class="cov8" title="1">{
        accountFile := filepath.Join(server.driveRoot, vars["device"], "accounts", vars["partition"], vars["hash"][29:32], vars["hash"], vars["hash"]+".db")
        tmpAccountFile := filepath.Join(server.driveRoot, vars["device"], "tmp", tmpFileName)
        tmpDb, err := sqliteOpenAccount(tmpAccountFile)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer tmpDb.Close()
        localDb, err := server.accountEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer localDb.Close()
        point := int64(-1)
        for </span><span class="cov8" title="1">{
                records, err := localDb.ItemsSince(point, 10000)
                if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error fetching items.",
                                zap.String("accountFile", accountFile),
                                zap.Error(err))
                        return http.StatusInternalServerError
                }</span>
                <span class="cov8" title="1">if len(records) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">point = records[len(records)-1].Rowid
                if err := tmpDb.MergeItems(records, ""); err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error merging items.",
                                zap.String("tmpAccountFile", tmpAccountFile),
                                zap.Error(err))
                        return http.StatusInternalServerError
                }</span>
        }
        <span class="cov8" title="1">if tmpDb.NewID() != nil || os.MkdirAll(filepath.Dir(accountFile), 0777) != nil || os.Rename(tmpAccountFile, accountFile) != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new account db.",
                        zap.String("accountFile", accountFile))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">server.accountEngine.Invalidate(localDb)
        return http.StatusNoContent</span>
}

func (server *AccountServer) replicateCompleteRsync(request *http.Request, vars map[string]string, tmpFileName string) int <span class="cov8" title="1">{
        accountFile := filepath.Join(server.driveRoot, vars["device"], "accounts", vars["partition"], vars["hash"][29:32], vars["hash"], vars["hash"]+".db")
        tmpAccountFile := filepath.Join(server.driveRoot, vars["device"], "tmp", tmpFileName)
        if !fs.Exists(tmpAccountFile) || fs.Exists(accountFile) </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">tmpDb, err := sqliteOpenAccount(tmpAccountFile)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer tmpDb.Close()
        if tmpDb.NewID() != nil || os.MkdirAll(filepath.Dir(accountFile), 0777) != nil || os.Rename(tmpAccountFile, accountFile) != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new account db.",
                        zap.String("accountFile", accountFile))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusNoContent</span>
}

func (server *AccountServer) replicateMergeItems(request *http.Request, vars map[string]string, records []*ContainerRecord, remoteID string) int <span class="cov8" title="1">{
        db, err := server.accountEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if err := db.MergeItems(records, remoteID); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging records.",
                        zap.String("db.RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *AccountServer) replicateMergeSyncs(request *http.Request, vars map[string]string, records []*SyncRecord) int <span class="cov8" title="1">{
        db, err := server.accountEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if err := db.MergeSyncTable(records); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging sync table.",
                        zap.String("db.RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *AccountServer) replicateSync(request *http.Request, vars map[string]string, maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (int, []byte) <span class="cov8" title="1">{
        db, err := server.accountEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound, nil
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        info, err := db.SyncRemoteData(maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error syncing remote data.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">response, err := json.Marshal(info)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error marshaling info.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">return http.StatusOK, response</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "bytes"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

var (
        errDeviceNotMounted = errors.New("Remove drive was unmounted")
        deviceLockupTimeout = time.Hour
        // GetRing is a local pointer to the hummingbird function, for overriding in tests.
        GetRing = ring.GetRing
)

// Replicator is the account replicator daemon object
type Replicator struct {
        checkMounts    bool
        deviceRoot     string
        reconCachePath string
        logger         srv.LowLevelLogger
        serverPort     int
        Ring           ring.Ring
        perUsync       int64
        maxUsyncs      int
        concurrencySem chan struct{}
        sendStat       chan statUpdate
        checkin        chan string
        startRun       chan string
        client         *http.Client
        runningDevices map[string]*replicationDevice
        reclaimAge     int64
}

type statUpdate struct {
        device string
        stat   string
        value  int64
}

type replicationDevice struct {
        i interface {
                sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error)
                sync(dev *ring.Device, part uint64, ringHash string, info *AccountInfo) (*AccountInfo, error)
                rsync(dev *ring.Device, c ReplicableAccount, part uint64, op string) error
                usync(dev *ring.Device, c ReplicableAccount, part uint64, localID string, point int64) error
                chooseReplicationStrategy(localInfo, remoteInfo *AccountInfo, usyncThreshold int64) string
                replicateDatabaseToDevice(dev *ring.Device, c ReplicableAccount, part uint64) error
                replicateDatabase(dbFile string) error
                findAccountDbs(devicePath string, results chan string)
                incrementStat(stat string)
        }
        r             *Replicator
        cancel        chan struct{}
        dev           *ring.Device
        stats         map[string]int64
        lastCheckin   time.Time
        runStarted    time.Time
        deviceStarted time.Time
}

func (rd *replicationDevice) sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error) <span class="cov8" title="1">{
        body, err := json.Marshal(args)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest("REPLICATE", fmt.Sprintf("http://%s:%d/%s/%d/%s",
                dev.ReplicationIp, dev.ReplicationPort, dev.Device, part, ringHash), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">return resp.StatusCode, respBody, nil</span>
}

func (rd *replicationDevice) sync(dev *ring.Device, part uint64, ringHash string, info *AccountInfo) (*AccountInfo, error) <span class="cov8" title="1">{
        var remoteInfo AccountInfo
        status, body, err := rd.i.sendReplicationMessage(dev, part, ringHash, "sync", info.MaxRow, info.Hash,
                info.ID, info.CreatedAt, info.PutTimestamp, info.DeleteTimestamp, info.RawMetadata)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sending sync request to %s/%s: %v", dev.ReplicationIp, dev.Device, err)
        }</span><span class="cov8" title="1"> else if status == http.StatusNotFound </span><span class="cov8" title="1">{
                return nil, nil
        }</span><span class="cov8" title="1"> else if status == http.StatusInsufficientStorage </span><span class="cov8" title="1">{
                return nil, errDeviceNotMounted
        }</span><span class="cov8" title="1"> else if status/100 != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("bad status code %d", status)
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(body, &amp;remoteInfo); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unmarshalling sync response: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;remoteInfo, nil</span>
}

func (rd *replicationDevice) rsync(dev *ring.Device, c ReplicableAccount, part uint64, op string) error <span class="cov8" title="1">{
        tmpFilename := common.UUID()
        fp, release, err := c.OpenDatabaseFile()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error opening databae: %v", err)
        }</span>
        <span class="cov8" title="1">defer release()
        req, err := http.NewRequest("PUT", fmt.Sprintf("http://%s:%d/%s/tmp/%s", dev.ReplicationIp, dev.ReplicationPort, dev.Device, tmpFilename), fp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating request: %v", err)
        }</span>
        <span class="cov8" title="1">req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("putting database to %s/%s: %v", dev.ReplicationIp, dev.Device, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("bad status code %d rsyncing file with %s/%s", resp.StatusCode, dev.ReplicationIp, dev.Device)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), op, tmpFilename)
        if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("sending %s message to %s/%s: %v", op, dev.ReplicationIp, dev.Device, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) usync(dev *ring.Device, c ReplicableAccount, part uint64, localID string, point int64) error <span class="cov8" title="1">{
        objects, err := c.ItemsSince(point, int(rd.r.perUsync))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("getting object records from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">usyncs := 0
        syncTable, err := c.SyncTable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting sync table: %v", err)
        }</span>
        <span class="cov8" title="1">for len(objects) != 0 &amp;&amp; usyncs &lt; rd.r.maxUsyncs </span><span class="cov8" title="1">{
                status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_items", objects, localID)
                if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Bad response to merge_items with %s/%s: %v, %v", dev.ReplicationIp, dev.Device, status, err)
                }</span>
                <span class="cov8" title="1">point = objects[len(objects)-1].Rowid
                usyncs++
                if objects, err = c.ItemsSince(point, int(rd.r.perUsync)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("getting object records from database: %s, %v", c.RingHash(), err)
                }</span>
        }
        <span class="cov8" title="1">if usyncs &gt;= rd.r.maxUsyncs </span><span class="cov0" title="0">{
                rd.i.incrementStat("diff_capped")
                return fmt.Errorf("capping usync at %d requests", usyncs)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_syncs", syncTable)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid status code from merge_syncs: %d", status)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) chooseReplicationStrategy(localInfo, remoteInfo *AccountInfo, usyncThreshold int64) string <span class="cov8" title="1">{
        switch </span>{
        case remoteInfo == nil:<span class="cov8" title="1">
                return "complete_rsync"</span>
        case localInfo.MaxRow == -1:<span class="cov8" title="1">
                return "empty"</span>
        case localInfo.MaxRow == remoteInfo.Point:<span class="cov8" title="1">
                return "no_change"</span>
        case localInfo.Hash == remoteInfo.Hash:<span class="cov8" title="1">
                return "hashmatch"</span>
        case remoteInfo.MaxRow &lt; localInfo.MaxRow*2 &amp;&amp; localInfo.MaxRow-remoteInfo.MaxRow &gt; usyncThreshold:<span class="cov8" title="1">
                return "rsync_then_merge"</span>
        default:<span class="cov8" title="1">
                return "diff"</span>
        }
}

func (rd *replicationDevice) replicateDatabaseToDevice(dev *ring.Device, c ReplicableAccount, part uint64) error <span class="cov8" title="1">{
        rd.i.incrementStat("attempted")
        info, err := c.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("getting local info from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">remoteInfo, err := rd.i.sync(dev, part, c.RingHash(), info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">strategy := rd.i.chooseReplicationStrategy(info, remoteInfo, rd.r.perUsync*3)
        rd.i.incrementStat(strategy)
        switch strategy </span>{
        case "empty", "hashmatch", "no_change":<span class="cov8" title="1">
                rd.r.logger.Debug("Not replicating anything.",
                        zap.String("strategy", strategy),
                        zap.String("RingHash", c.RingHash()))</span>
        case "complete_rsync", "rsync_then_merge":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("ReplicationIp", dev.ReplicationIp),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.rsync(dev, c, part, strategy)</span>
        case "diff":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("ReplicationIp", dev.ReplicationIp),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.usync(dev, c, part, info.ID, remoteInfo.Point)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) replicateDatabase(dbFile string) error <span class="cov8" title="1">{
        rd.r.logger.Debug("Replicating database.", zap.String("dbFile", filepath.Base(dbFile)))
        parts := filepath.Base(filepath.Dir(filepath.Dir(filepath.Dir(dbFile))))
        part, err := strconv.ParseUint(parts, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Bad partition: %s", parts)
        }</span>
        <span class="cov8" title="1">devices, handoff := rd.r.Ring.GetJobNodes(part, rd.dev.Id)
        moreNodes := rd.r.Ring.GetMoreNodes(part)
        c, err := sqliteOpenAccount(dbFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer c.Close()
        if err := c.CleanupTombstones(rd.r.reclaimAge); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">successes := 0
        for i := 0; i &lt; len(devices); i++ </span><span class="cov8" title="1">{
                if err := rd.i.replicateDatabaseToDevice(devices[i], c, part); err == nil </span><span class="cov8" title="1">{
                        rd.i.incrementStat("success")
                        rd.r.logger.Debug("Succeeded replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("ReplicationIp", devices[i].ReplicationIp),
                                zap.String("Device", devices[i].Device))
                        successes++
                }</span><span class="cov8" title="1"> else {
                        rd.i.incrementStat("failure")
                        rd.r.logger.Error("Error replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("ReplicationIp", devices[i].ReplicationIp),
                                zap.String("Device", devices[i].Device),
                                zap.Error(err))
                        if err == errDeviceNotMounted &amp;&amp; !handoff </span><span class="cov0" title="0">{
                                next := moreNodes.Next()
                                if next == nil </span><span class="cov0" title="0">{
                                        rd.r.logger.Error("Ran out of handoffs to talk to.",
                                                zap.String("dbFile", dbFile))
                                }</span><span class="cov0" title="0"> else {
                                        devices = append(devices, moreNodes.Next())
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if handoff &amp;&amp; successes == len(devices) </span><span class="cov8" title="1">{
                rd.i.incrementStat("remove")
                return os.RemoveAll(filepath.Dir(dbFile))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) findAccountDbs(devicePath string, results chan string) <span class="cov8" title="1">{
        defer close(results)
        accountsDir := filepath.Join(devicePath, "accounts")
        partitions, err := filepath.Glob(filepath.Join(accountsDir, "[0-9]*"))
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("Error getting partitions.",
                        zap.String("accountsDir", accountsDir),
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, part := range partitions </span><span class="cov8" title="1">{
                suffixes, err := filepath.Glob(filepath.Join(part, "[a-f0-9][a-f0-9][a-f0-9]"))
                if err != nil </span><span class="cov0" title="0">{
                        rd.r.logger.Error("Error getting suffixes.",
                                zap.String("part", part),
                                zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">for _, suff := range suffixes </span><span class="cov8" title="1">{
                        hashes, err := filepath.Glob(filepath.Join(suff, "????????????????????????????????"))
                        if err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error getting hashes",
                                        zap.String("suff", suff),
                                        zap.Error(err))
                                return
                        }</span>
                        <span class="cov8" title="1">for _, hash := range hashes </span><span class="cov8" title="1">{
                                dbFile := filepath.Join(hash, filepath.Base(hash)+".db")
                                if fs.Exists(dbFile) </span><span class="cov8" title="1">{
                                        select </span>{
                                        case results &lt;- dbFile:</span><span class="cov8" title="1">
                                        case &lt;-rd.cancel:<span class="cov8" title="1">
                                                return</span>
                                        }
                                }
                        }
                }
        }
}

func (rd *replicationDevice) replicate() <span class="cov8" title="1">{
        rd.r.logger.Info("Beginning replication for device.",
                zap.String("device", rd.dev.Device))
        rd.r.startRun &lt;- rd.dev.Device
        devicePath := filepath.Join(rd.r.deviceRoot, rd.dev.Device)
        stat, err := os.Stat(devicePath)
        if err != nil || !stat.IsDir() </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device doesn't exist.",
                        zap.String("devicePath", devicePath))
                return
        }</span>
        <span class="cov8" title="1">if mount, err := fs.IsMount(devicePath); rd.r.checkMounts &amp;&amp; (err != nil || !mount) </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device not mounted.",
                        zap.String("devicePath", devicePath))
                return
        }</span>
        <span class="cov8" title="1">results := make(chan string, 100)
        go rd.i.findAccountDbs(devicePath, results)
        for dbFile := range results </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                case rd.r.concurrencySem &lt;- struct{}{}:<span class="cov8" title="1">
                        rd.r.checkin &lt;- rd.dev.Device
                        if err := rd.i.replicateDatabase(dbFile); err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error replicating database file.",
                                        zap.String("dbFile", dbFile),
                                        zap.Error(err))
                        }</span>
                        <span class="cov8" title="1">&lt;-rd.r.concurrencySem</span>
                }
        }
}

func (rd *replicationDevice) replicateLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        rd.replicate()</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Second * 30)</span>
        }
}

func (rd *replicationDevice) incrementStat(stat string) <span class="cov8" title="1">{
        rd.r.sendStat &lt;- statUpdate{rd.dev.Device, stat, 1}
}</span>

func newReplicationDevice(dev *ring.Device, r *Replicator) *replicationDevice <span class="cov8" title="1">{
        rd := &amp;replicationDevice{
                r:             r,
                cancel:        make(chan struct{}),
                lastCheckin:   time.Now(),
                deviceStarted: time.Now(),
                dev:           dev,
                stats: map[string]int64{
                        "attempted":             0,
                        "success":               0,
                        "failure":               0,
                        "no_change":             0,
                        "hashmatch":             0,
                        "rsync":                 0,
                        "diff":                  0,
                        "remove":                0,
                        "empty":                 0,
                        "remote_merge":          0,
                        "diff_capped":           0,
                        "lifetime_attempted":    0,
                        "lifetime_success":      0,
                        "lifetime_failure":      0,
                        "lifetime_no_change":    0,
                        "lifetime_hashmatch":    0,
                        "lifetime_rsync":        0,
                        "lifetime_diff":         0,
                        "lifetime_remove":       0,
                        "lifetime_empty":        0,
                        "lifetime_remote_merge": 0,
                        "lifetime_diff_capped":  0,
                        "lifetime_passes":       0,
                },
        }
        rd.i = rd
        return rd
}</span>

func (r *Replicator) verifyDevices() <span class="cov8" title="1">{
        // kill devices that haven't checked in for a while
        for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                if time.Since(rd.lastCheckin) &gt; deviceLockupTimeout </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
        <span class="cov8" title="1">ringDevices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        // look for devices that aren't running but should be
        <span class="cov8" title="1">for _, dev := range ringDevices </span><span class="cov8" title="1">{
                if _, ok := r.runningDevices[dev.Device]; !ok </span><span class="cov8" title="1">{
                        r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                        go r.runningDevices[dev.Device].replicateLoop()
                }</span>
        }
        // look for devices that are running but shouldn't be
        <span class="cov8" title="1">for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                found := false
                for _, dev := range ringDevices </span><span class="cov8" title="1">{
                        if dev.Device == key </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
}

func (r *Replicator) reportStats() <span class="cov8" title="1">{
        var totalTime time.Duration
        aggStats := map[string]int64{"attempted": 0, "success": 0, "failure": 0, "remove": 0}
        for _, device := range r.runningDevices </span><span class="cov8" title="1">{
                totalTime += time.Since(device.runStarted)
                aggStats["attempted"] += device.stats["attempted"]
                aggStats["success"] += device.stats["success"]
                aggStats["failure"] += device.stats["failure"]
                aggStats["remove"] += device.stats["remove"]
        }</span>
        // there's no longer the concept of a single pass, so we report the average running time.
        <span class="cov8" title="1">if len(r.runningDevices) &gt; 0 </span><span class="cov8" title="1">{
                rate := 0.0
                runningTime := (totalTime / time.Duration(len(r.runningDevices))).Seconds()
                if runningTime &gt; 0 </span><span class="cov8" title="1">{
                        rate = float64(aggStats["attempted"]) / runningTime
                }</span>
                <span class="cov8" title="1">r.logger.Info("Attempted to replicate dbs",
                        zap.Int64("aggStats['attempted']", aggStats["attempted"]),
                        zap.Float64("runningTime", runningTime),
                        zap.Float64("rate", rate))

                r.logger.Info("Removed dbs",
                        zap.Int64("aggStats['remove']", aggStats["remove"]))
                r.logger.Info("Sucess &amp; Failure",
                        zap.Int64("success", aggStats["success"]),
                        zap.Int64("failure", aggStats["failure"]))</span>
        }<span class="cov0" title="0"> else {
                r.logger.Info("No devices replicating.")
        }</span>
}

func (r *Replicator) runLoopCheck(reportTimer &lt;-chan time.Time) <span class="cov8" title="1">{
        select </span>{
        case device := &lt;-r.checkin:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.lastCheckin = time.Now()
                }</span>
        case device := &lt;-r.startRun:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.runStarted = time.Now()
                        rd.lastCheckin = time.Now()
                        for k, v := range rd.stats </span><span class="cov8" title="1">{
                                rd.stats[k] = 0
                                rd.stats["lifetime_"+k] += v
                        }</span>
                        <span class="cov8" title="1">rd.stats["lifetime_passes"]++</span>
                }
        case update := &lt;-r.sendStat:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[update.device]; ok </span><span class="cov8" title="1">{
                        rd.stats[update.stat] += update.value
                }</span>
        case &lt;-reportTimer:<span class="cov8" title="1">
                r.reportStats()
                r.verifyDevices()</span>
        }
}

// RunForever runs the replicator in a forever-loop.
func (r *Replicator) RunForever() <span class="cov0" title="0">{
        reportTimer := time.NewTimer(time.Minute * 15)
        r.verifyDevices()
        for </span><span class="cov0" title="0">{
                r.runLoopCheck(reportTimer.C)
        }</span>
}

// Run runs a pass of the replicator once.
func (r *Replicator) Run() <span class="cov8" title="1">{
        done := make(chan struct{})
        devices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                go func(rd *replicationDevice) </span><span class="cov8" title="1">{
                        rd.replicate()
                        done &lt;- struct{}{}
                }</span>(r.runningDevices[dev.Device])
        }
        <span class="cov8" title="1">waitingFor := len(devices)
        for waitingFor &gt; 0 </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-r.checkin:</span><span class="cov0" title="0">
                case &lt;-r.startRun:</span><span class="cov8" title="1">
                case update := &lt;-r.sendStat:<span class="cov0" title="0">
                        if ctx, ok := r.runningDevices[update.device]; ok </span><span class="cov0" title="0">{
                                ctx.stats[update.stat] += update.value
                        }</span>
                case &lt;-done:<span class="cov8" title="1">
                        waitingFor--</span>
                }
        }
        <span class="cov8" title="1">r.reportStats()</span>
}

// GetReplicator uses the config settings and command-line flags to configure and return a replicator daemon struct.
func GetReplicator(serverconf conf.Config, flags *flag.FlagSet) (srv.Daemon, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        if !serverconf.HasSection("account-replicator") </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("Unable to find account-replicator config section")
        }</span>
        <span class="cov8" title="1">hashPathPrefix, hashPathSuffix, err := GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("Unable to get hash prefix and suffix")
        }</span>
        <span class="cov8" title="1">ring, err := GetRing("account", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error loading account ring")
        }</span>
        <span class="cov8" title="1">concurrency := int(serverconf.GetInt("account-replicator", "concurrency", 4))

        logLevelString := serverconf.GetDefault("account-replicator", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))

        var logger srv.LowLevelLogger
        if logger, err = srv.SetupLogger("account-replicator", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;Replicator{
                runningDevices: make(map[string]*replicationDevice),
                perUsync:       3000,
                maxUsyncs:      25,
                sendStat:       make(chan statUpdate),
                checkin:        make(chan string),
                startRun:       make(chan string),
                reconCachePath: serverconf.GetDefault("account-replicator", "recon_cache_path", "/var/cache/swift"),
                checkMounts:    serverconf.GetBool("account-replicator", "mount_check", true),
                deviceRoot:     serverconf.GetDefault("account-replicator", "devices", "/srv/node"),
                serverPort:     int(serverconf.GetInt("account-replicator", "bind_port", 6000)),
                reclaimAge:     serverconf.GetInt("account-replicator", "reclaim_age", 604800),
                logger:         logger,
                concurrencySem: make(chan struct{}, concurrency),
                Ring:           ring,
                client: &amp;http.Client{
                        Timeout:   time.Minute * 15,
                        Transport: &amp;http.Transport{Dial: (&amp;net.Dialer{Timeout: time.Second}).Dial},
                },
        }, logger, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "database/sql"
        "fmt"
        "strings"
)

const (
        accountDBScript = `
                CREATE TABLE outgoing_sync (
                        remote_id TEXT UNIQUE,
                        sync_point INTEGER,
                        updated_at TEXT DEFAULT 0
                );
                CREATE TRIGGER outgoing_sync_insert AFTER INSERT ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER outgoing_sync_update AFTER UPDATE ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;

                CREATE TABLE incoming_sync (
                        remote_id TEXT UNIQUE,
                        sync_point INTEGER,
                        updated_at TEXT DEFAULT 0
                );
                CREATE TRIGGER incoming_sync_insert AFTER INSERT ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER incoming_sync_update AFTER UPDATE ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;

                CREATE TABLE container (
                        ROWID INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT,
                        put_timestamp TEXT,
                        delete_timestamp TEXT,
                        object_count INTEGER,
                        bytes_used INTEGER,
                        deleted INTEGER DEFAULT 0,
                        storage_policy_index INTEGER DEFAULT 0
                );
                CREATE INDEX ix_container_deleted_name ON container (deleted, name);

                CREATE TABLE account_stat (
                        account TEXT,
                        created_at TEXT,
                        put_timestamp TEXT DEFAULT '0',
                        delete_timestamp TEXT DEFAULT '0',
                        container_count INTEGER,
                        object_count INTEGER DEFAULT 0,
                        bytes_used INTEGER DEFAULT 0,
                        hash TEXT default '00000000000000000000000000000000',
                        id TEXT,
                        status TEXT DEFAULT '',
                        status_changed_at TEXT DEFAULT '0',
                        metadata TEXT DEFAULT ''
                );

                CREATE TRIGGER container_update BEFORE UPDATE ON container
                        BEGIN
                                SELECT RAISE(FAIL, 'UPDATE not allowed; DELETE and INSERT');
                        END;
                CREATE TRIGGER container_insert AFTER INSERT ON container
                        BEGIN
                                UPDATE account_stat
                                SET container_count = container_count + (1 - new.deleted),
                                        object_count = object_count + new.object_count,
                                        bytes_used = bytes_used + new.bytes_used,
                                        hash = chexor(hash, new.name,
                                                                  new.put_timestamp || '-' ||
                                                                  new.delete_timestamp || '-' ||
                                                                  new.object_count || '-' || new.bytes_used);
                        END;
                CREATE TRIGGER container_delete AFTER DELETE ON container
                        BEGIN
                                UPDATE account_stat
                                SET container_count = container_count - (1 - old.deleted),
                                        object_count = object_count - old.object_count,
                                        bytes_used = bytes_used - old.bytes_used,
                                        hash = chexor(hash, old.name,
                                                                  old.put_timestamp || '-' ||
                                                                  old.delete_timestamp || '-' ||
                                                                  old.object_count || '-' || old.bytes_used);
                        END;
                `

        policyStatTableScript = `
                CREATE TABLE policy_stat (
                        storage_policy_index INTEGER PRIMARY KEY,
                        container_count INTEGER DEFAULT 0,
                        object_count INTEGER DEFAULT 0,
                        bytes_used INTEGER DEFAULT 0
                );
                INSERT OR IGNORE INTO policy_stat (storage_policy_index, container_count, object_count, bytes_used)
                        SELECT 0, container_count, object_count, bytes_used FROM account_stat WHERE container_count &gt; 0;
                `

        policyStatTriggerScript = `
                CREATE TRIGGER container_insert_ps AFTER INSERT ON container
                        BEGIN
                                INSERT OR IGNORE INTO policy_stat
                                        (storage_policy_index, container_count, object_count, bytes_used)
                                        VALUES (new.storage_policy_index, 0, 0, 0);
                                UPDATE policy_stat
                                SET container_count = container_count + (1 - new.deleted),
                                        object_count = object_count + new.object_count,
                                        bytes_used = bytes_used + new.bytes_used
                                WHERE storage_policy_index = new.storage_policy_index;
                        END;
                CREATE TRIGGER container_delete_ps AFTER DELETE ON container
                        BEGIN
                                UPDATE policy_stat
                                SET container_count = container_count - (1 - old.deleted),
                                        object_count = object_count - old.object_count,
                                        bytes_used = bytes_used - old.bytes_used
                                WHERE storage_policy_index = old.storage_policy_index;
                        END;
        `

        pragmaScript = `
                PRAGMA synchronous = NORMAL;
                PRAGMA cache_size = -4096;
                PRAGMA temp_store = MEMORY;
                PRAGMA journal_mode = WAL;
                PRAGMA busy_timeout = 25000;`
)

func schemaMigrate(db *sql.DB) (bool, error) <span class="cov8" title="1">{
        hasMetadata := false
        hasPolicyStat := false
        hasContainerCount := false
        hasDeletedNameIndex := false

        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // We just pull the schema out of sqlite_master and look at it to get the current state of the database.
        rows, err := tx.Query("SELECT name, sql FROM sqlite_master WHERE name in ('policy_stat', 'account_stat', 'policy_stat', 'ix_container_deleted_name')")
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var name, sql string
                if err := rows.Scan(&amp;name, &amp;sql); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if name == "policy_stat" </span><span class="cov8" title="1">{
                        hasPolicyStat = true
                        hasContainerCount = strings.Contains(sql, "container_count")
                }</span><span class="cov8" title="1"> else if name == "account_stat" </span><span class="cov8" title="1">{
                        hasMetadata = strings.Contains(sql, "metadata")
                }</span><span class="cov8" title="1"> else if name == "ix_container_deleted_name" </span><span class="cov8" title="1">{
                        hasDeletedNameIndex = true
                }</span>
        }

        <span class="cov8" title="1">if hasMetadata &amp;&amp; hasPolicyStat &amp;&amp; hasContainerCount </span><span class="cov8" title="1">{
                return hasDeletedNameIndex, nil
        }</span>

        <span class="cov0" title="0">if !hasMetadata </span><span class="cov0" title="0">{
                script := "ALTER TABLE account_stat ADD COLUMN metadata DEFAULT '{}';"
                if _, err := tx.Exec(script); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Adding metadata column: %v", err)
                }</span>
        }
        <span class="cov0" title="0">if !hasPolicyStat </span><span class="cov0" title="0">{
                script := `
                        ALTER TABLE container ADD COLUMN storage_policy_index INTEGER DEFAULT 0;
                ` + policyStatTableScript + policyStatTriggerScript
                if _, err = tx.Exec(script); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Performing policy migration: %v", err)
                }</span>
        }<span class="cov0" title="0"> else if !hasContainerCount </span><span class="cov0" title="0">{
                script := `
                        DROP TRIGGER container_delete_ps;
                        DROP TRIGGER container_insert_ps;
                        ALTER TABLE policy_stat ADD COLUMN container_count INTEGER DEFAULT 0;
                ` + policyStatTriggerScript + `
                        UPDATE policy_stat SET container_count = (SELECT container_count FROM account_stat)
                                WHERE (SELECT COUNT(storage_policy_index) FROM policy_stat) &lt;= 1;

                        INSERT OR REPLACE INTO policy_stat (storage_policy_index, container_count, object_count, bytes_used)
                                SELECT p.storage_policy_index, c.count, p.object_count, p.bytes_used
                                FROM (
                                        SELECT storage_policy_index, COUNT(*) as count FROM container
                                        WHERE deleted = 0 GROUP BY storage_policy_index
                                ) c
                                JOIN policy_stat p ON p.storage_policy_index = c.storage_policy_index
                                WHERE NOT EXISTS(SELECT changes() as change FROM policy_stat WHERE change &lt;&gt; 0);
                `
                if _, err = tx.Exec(script); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Performing container-count migration: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return hasDeletedNameIndex, tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "encoding/json"
        "encoding/xml"
        "flag"
        "fmt"
        "net"
        "net/http"
        _ "net/http/pprof" // install pprof http handlers
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/justinas/alice"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

// GetHashPrefixAndSuffix is a pointer to hummingbird's function of the same name, for overriding in tests.
var GetHashPrefixAndSuffix = conf.GetHashPrefixAndSuffix

// AccountServer contains all of the information for a running account server.
type AccountServer struct {
        driveRoot        string
        hashPathPrefix   string
        hashPathSuffix   string
        logger           srv.LowLevelLogger
        logLevel         zap.AtomicLevel
        diskInUse        *common.KeyedLimit
        checkMounts      bool
        accountEngine    AccountEngine
        updateClient     *http.Client
        autoCreatePrefix string
        policyList       conf.PolicyList
}

func formatTimestamp(ts string) (string, error) <span class="cov8" title="1">{
        if len(ts) == 16 &amp;&amp; ts[10] == '.' </span><span class="cov8" title="1">{
                return ts, nil
        }</span>
        <span class="cov8" title="1">t, err := strconv.ParseFloat(ts, 64)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ret := strconv.FormatFloat(t, 'f', 5, 64)
        if len(ret) &lt; 16 </span><span class="cov8" title="1">{
                return strings.Repeat("0", 16-len(ret)) + ret, nil
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func (server *AccountServer) Finalize() <span class="cov0" title="0">{
}</span>

// AccountGetHandler handles GET and HEAD requests for an account.
func (server *AccountServer) AccountGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if err := request.ParseForm(); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account info. ", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers := writer.Header()
        if ts, err := formatTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := formatTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Put-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := formatTimestamp(info.DeleteTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Delete-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := formatTimestamp(info.StatusChangedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Status-Changed-At", ts)
        }</span>
        <span class="cov8" title="1">metadata, err := db.GetMetadata()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get metadata.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                headers.Set(key, value)
        }</span>
        <span class="cov8" title="1">if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span><span class="cov8" title="1"> else if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else {
                headers.Set("X-Account-Container-Count", strconv.FormatInt(info.ContainerCount, 10))
                headers.Set("X-Account-Object-Count", strconv.FormatInt(info.ObjectCount, 10))
                headers.Set("X-Account-Bytes-Used", strconv.FormatInt(info.BytesUsed, 10))
                if ts, err := formatTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Timestamp", ts)
                }</span>
                <span class="cov8" title="1">if ts, err := formatTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Put-Timestamp", ts)
                }</span>
        }
        <span class="cov8" title="1">if policyStats, err := db.PolicyStats(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling PolicyStats.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span><span class="cov8" title="1"> else {
                for _, policyStat := range policyStats </span><span class="cov8" title="1">{
                        var prefix string
                        if policy := server.policyList[policyStat.StoragePolicyIndex]; policy != nil </span><span class="cov0" title="0">{
                                prefix = fmt.Sprintf("X-Account-Storage-Policy-%s-", policy.Name)
                        }</span><span class="cov8" title="1"> else {
                                prefix = fmt.Sprintf("X-Account-Storage-Policy-%d-", policyStat.StoragePolicyIndex)
                        }</span>
                        <span class="cov8" title="1">headers.Set(prefix+"Container-Count", fmt.Sprintf("%d", policyStat.ContainerCount))
                        headers.Set(prefix+"Object-Count", fmt.Sprintf("%d", policyStat.ContainerCount))
                        headers.Set(prefix+"Bytes-Used", fmt.Sprintf("%d", policyStat.BytesUsed))</span>
                }
        }
        <span class="cov8" title="1">if request.Method == "HEAD" </span><span class="cov8" title="1">{
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
                return
        }</span>
        <span class="cov8" title="1">limit, _ := strconv.ParseInt(request.FormValue("limit"), 10, 64)
        if limit &gt; 10000 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusPreconditionFailed)
                return
        }</span><span class="cov8" title="1"> else if limit &lt;= 0 </span><span class="cov8" title="1">{
                limit = 10000
        }</span>
        <span class="cov8" title="1">marker := request.Form.Get("marker")
        delimiter := request.Form.Get("delimiter")
        endMarker := request.Form.Get("end_marker")
        prefix := request.Form.Get("prefix")
        reverse := common.LooksTrue(request.Form.Get("reverse"))
        containers, err := db.ListContainers(int(limit), marker, endMarker, prefix, delimiter, reverse)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to list containers.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">format := request.Form.Get("format")
        if format == "" </span><span class="cov8" title="1">{ /* TODO: real accept parsing */
                accept := request.Header.Get("Accept")
                if strings.Contains(accept, "application/json") </span><span class="cov8" title="1">{
                        format = "json"
                }</span><span class="cov8" title="1"> else if strings.Contains(accept, "application/xml") || strings.Contains(accept, "text/xml") </span><span class="cov0" title="0">{
                        format = "xml"
                }</span><span class="cov8" title="1"> else {
                        format = "text"
                }</span>
        }
        <span class="cov8" title="1">if format == "text" </span><span class="cov8" title="1">{
                response := ""
                for _, obj := range containers </span><span class="cov8" title="1">{
                        if or, ok := obj.(*ContainerListingRecord); ok </span><span class="cov8" title="1">{
                                response += or.Name + "\n"
                        }</span><span class="cov0" title="0"> else if sr, ok := obj.(*SubdirListingRecord); ok </span><span class="cov0" title="0">{
                                response += sr.Name + "\n"
                        }</span>
                }
                <span class="cov8" title="1">if len(response) &gt; 0 </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", strconv.Itoa(len(response)))
                        writer.WriteHeader(200)
                        writer.Write([]byte(response))
                }</span><span class="cov8" title="1"> else {
                        headers.Set("Content-Length", "0")
                        writer.WriteHeader(204)
                        writer.Write([]byte(""))
                }</span>
        }<span class="cov8" title="1"> else if format == "json" </span><span class="cov8" title="1">{
                output, err := json.Marshal(containers)
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">headers.Set("Content-Type", "application/json; charset=utf-8")
                headers.Set("Content-Length", strconv.Itoa(len(output)))
                writer.WriteHeader(200)
                writer.Write(output)</span>
        }<span class="cov8" title="1"> else if format == "xml" </span><span class="cov8" title="1">{
                type Account struct {
                        XMLName    xml.Name `xml:"account"`
                        Name       string   `xml:"name,attr"`
                        Containers []interface{}
                }
                container := &amp;Account{Name: vars["account"], Containers: containers}
                writer.Header().Set("Content-Type", "application/xml; charset=utf-8")
                output, _ := xml.Marshal(container)
                headers.Set("Content-Length", strconv.Itoa(len(output)+39))
                writer.WriteHeader(200)
                writer.Write([]byte("&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"))
                writer.Write(output)
        }</span>
}

// AccountPutHandler handles PUT requests for an account.
func (server *AccountServer) AccountPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">metadata := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Account-Meta-") || strings.HasPrefix(key, "X-Account-Sysmeta-") </span><span class="cov8" title="1">{
                        metadata[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">created, db, err := server.accountEngine.Create(vars, timestamp, metadata)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create database.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if created </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusCreated)
        }</span><span class="cov0" title="0"> else {
                srv.StandardResponse(writer, http.StatusAccepted)
        }</span>
}

// AccountDeleteHandler handles DELETE requests for an account.
func (server *AccountServer) AccountDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account info.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if info.ContainerCount &gt; 0 </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusConflict)
                return
        }</span>
        <span class="cov8" title="1">if err = db.Delete(timestamp); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to delete database", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">info, err = db.GetInfo()
        writer.WriteHeader(http.StatusNoContent)
        writer.Write([]byte(""))</span>
}

// AccountPostHandler handles POST requests for an account.
func (server *AccountServer) AccountPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">updates := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Account-Meta-") || strings.HasPrefix(key, "X-Account-Sysmeta-") </span><span class="cov8" title="1">{
                        updates[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span><span class="cov8" title="1"> else if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err := db.UpdateMetadata(updates); err == ErrorInvalidMetadata </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span><span class="cov8" title="1"> else {
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
        }</span>
}

// ContainerPutHandler handles the PUT of container records to an account.
func (server *AccountServer) ContainerPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        putTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Put-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var objectCount, bytesUsed, storagePolicyIndex int64
        if objectCount, err = strconv.ParseInt(request.Header.Get("X-Object-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if bytesUsed, err = strconv.ParseInt(request.Header.Get("X-Bytes-Used"), 10, 64); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if storagePolicyIndex, err = strconv.ParseInt(request.Header.Get("X-Backend-Storage-Policy-Index"), 10, 64); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">deleteTimestamp := request.Header.Get("X-Delete-Timestamp")
        db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                if strings.HasPrefix(vars["account"], server.autoCreatePrefix) </span><span class="cov8" title="1">{
                        if _, db, err = server.accountEngine.Create(vars, putTimestamp, map[string][]string{}); err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Unable to auto-create account.", zap.Error(err))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return
                        }</span>
                }<span class="cov0" title="0"> else {
                        srv.StandardResponse(writer, http.StatusNotFound)
                        return
                }</span>
        }<span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if err := db.PutContainer(vars["container"], putTimestamp, deleteTimestamp, objectCount, bytesUsed, int(storagePolicyIndex)); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error adding object to container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, http.StatusCreated)</span>
}

// HealthcheckHandler implements a basic health check, that just returns "OK".
func (server *AccountServer) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

// ReconHandler delegates incoming /recon calls to the common recon handler.
func (server *AccountServer) ReconHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.ReconHandler(server.driveRoot, writer, request)
}</span>

// DiskUsageHandler returns information on the current outstanding HTTP requests per-disk.
func (server *AccountServer) DiskUsageHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        if data, err := server.diskInUse.MarshalJSON(); err == nil </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
        }</span><span class="cov0" title="0"> else {
                writer.WriteHeader(http.StatusInternalServerError)
                writer.Write([]byte(err.Error()))
        }</span>
}

// LogRequest is a middleware that logs requests and also sets up a logger in the request context.
func (server *AccountServer) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                newWriter := &amp;srv.WebWriter{ResponseWriter: writer, Status: 500, ResponseStarted: false}
                start := time.Now()
                logr := server.logger.With(zap.String("txn", request.Header.Get("X-Trans-Id")))
                request = srv.SetLogger(request, logr)
                next.ServeHTTP(newWriter, request)
                forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                lvl, _ := server.logLevel.MarshalText()
                if (request.Method != "REPLICATE" &amp;&amp; request.Method != "REPCONN") || strings.ToUpper(string(lvl)) == "DEBUG" </span><span class="cov8" title="1">{
                        extraInfo := "-"
                        if forceAcquire </span><span class="cov0" title="0">{
                                extraInfo = "FA"
                        }</span>
                        <span class="cov8" title="1">logr.Info("Request log",
                                zap.String("remoteAddr", request.RemoteAddr),
                                zap.String("eventTime", time.Now().Format("02/Jan/2006:15:04:05 -0700")),
                                zap.String("method", request.Method),
                                zap.String("urlPath", common.Urlencode(request.URL.Path)),
                                zap.Int("status", newWriter.Status),
                                zap.String("contentLength", common.GetDefault(newWriter.Header(), "Content-Length", "-")),
                                zap.String("referer", common.GetDefault(request.Header, "Referer", "-")),
                                zap.String("userAgent", common.GetDefault(request.Header, "User-Agent", "-")),
                                zap.Float64("requestTimeSeconds", time.Since(start).Seconds()),
                                zap.String("extraInfo", extraInfo))</span>
                }
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

// AcquireDevice is a middleware that makes sure the device is available - mounted and not beyond its max concurrency.
func (server *AccountServer) AcquireDevice(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                vars := srv.GetVars(request)
                if device, ok := vars["device"]; ok &amp;&amp; device != "" </span><span class="cov8" title="1">{
                        devicePath := filepath.Join(server.driveRoot, device)
                        if server.checkMounts </span><span class="cov0" title="0">{
                                if mounted, err := fs.IsMount(devicePath); err != nil || !mounted </span><span class="cov0" title="0">{
                                        vars["Method"] = request.Method
                                        srv.CustomErrorResponse(writer, 507, vars)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                        if concRequests := server.diskInUse.Acquire(device, forceAcquire); concRequests != 0 </span><span class="cov0" title="0">{
                                writer.Header().Set("X-Disk-Usage", strconv.FormatInt(concRequests, 10))
                                srv.StandardResponse(writer, 503)
                                return
                        }</span>
                        <span class="cov8" title="1">defer server.diskInUse.Release(device)</span>
                }
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (server *AccountServer) updateDeviceLocks(seconds int64) <span class="cov0" title="0">{
        reloadTime := time.Duration(seconds) * time.Second
        for </span><span class="cov0" title="0">{
                time.Sleep(reloadTime)
                for _, key := range server.diskInUse.Keys() </span><span class="cov0" title="0">{
                        lockPath := filepath.Join(server.driveRoot, key, "lock_device")
                        if fs.Exists(lockPath) </span><span class="cov0" title="0">{
                                server.diskInUse.Lock(key)
                        }</span><span class="cov0" title="0"> else {
                                server.diskInUse.Unlock(key)
                        }</span>
                }
        }
}

// GetHandler returns the server's http handler - it sets up routes and instantiates middleware.
func (server *AccountServer) GetHandler(config conf.Config) http.Handler <span class="cov8" title="1">{
        commonHandlers := alice.New(server.LogRequest, middleware.RecoverHandler, middleware.ValidateRequest, server.AcquireDevice)
        router := srv.NewRouter()
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/diskusage", commonHandlers.ThenFunc(server.DiskUsageHandler))
        router.Get("/recon/:method/:recon_type", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/recon/:method", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        router.Put("/:device/tmp/:filename", commonHandlers.ThenFunc(server.TmpUploadHandler))
        router.Put("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerPutHandler))
        router.Put("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountPutHandler))
        router.Delete("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountDeleteHandler))
        router.Get("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountGetHandler))
        router.Head("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountGetHandler))
        router.Post("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountPostHandler))
        router.Replicate("/:device/:partition/:hash", commonHandlers.ThenFunc(server.AccountReplicateHandler))
        router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Invalid path: %s", r.URL.Path), http.StatusBadRequest)
        }</span>)
        <span class="cov8" title="1">return alice.New(middleware.GrepObject).Then(router)</span>
}

// GetServer parses configs and command-line flags, returning a configured server object and the ip and port it should bind on.
func GetServer(serverconf conf.Config, flags *flag.FlagSet) (bindIP string, bindPort int, serv srv.Server, logger srv.LowLevelLogger, err error) <span class="cov0" title="0">{
        server := &amp;AccountServer{driveRoot: "/srv/node", hashPathPrefix: "", hashPathSuffix: "", policyList: conf.LoadPolicies()}
        server.hashPathPrefix, server.hashPathSuffix, err = GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, err
        }</span>
        <span class="cov0" title="0">server.autoCreatePrefix = serverconf.GetDefault("app:account-server", "auto_create_account_prefix", ".")
        server.driveRoot = serverconf.GetDefault("app:account-server", "devices", "/srv/node")
        server.checkMounts = serverconf.GetBool("app:account-server", "mount_check", true)
        server.diskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:account-server", "disk_limit", 25, 10000))
        bindIP = serverconf.GetDefault("app:account-server", "bind_ip", "0.0.0.0")
        bindPort = int(serverconf.GetInt("app:account-server", "bind_port", 6000))

        logLevelString := serverconf.GetDefault("app:account-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        if server.logger, err = srv.SetupLogger("account-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov0" title="0">server.accountEngine = newLRUEngine(server.driveRoot, server.hashPathPrefix, server.hashPathSuffix, 32)
        connTimeout := time.Duration(serverconf.GetFloat("app:account-server", "conn_timeout", 1.0) * float64(time.Second))
        nodeTimeout := time.Duration(serverconf.GetFloat("app:account-server", "node_timeout", 10.0) * float64(time.Second))
        server.updateClient = &amp;http.Client{
                Timeout:   nodeTimeout,
                Transport: &amp;http.Transport{Dial: (&amp;net.Dialer{Timeout: connTimeout}).Dial},
        }
        return bindIP, bindPort, server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "crypto/md5"
        "database/sql"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/mattn/go-sqlite3"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
)

const (
        maxQueryArgs       = 990
        maxOpenConns       = 2
        maxIdleConns       = 2
        pendingCap         = 131072
        maxMetaCount       = 90
        maxMetaOverallSize = 4096
)

var infoCacheTimeout = time.Second * 10
var policyStatsCacheTimeout = time.Second * 10

func chexor(old, name, timestamp string) string <span class="cov8" title="1">{
        oldDigest, err := hex.DecodeString(old)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error decoding hex: %v", err))</span>
        }
        <span class="cov8" title="1">h := md5.New()
        if _, err := io.WriteString(h, name+"-"+timestamp); err != nil </span><span class="cov0" title="0">{
                panic("THIS SHOULD NEVER HAPPEN")</span>
        }
        <span class="cov8" title="1">digest := h.Sum(nil)
        for i := range digest </span><span class="cov8" title="1">{
                digest[i] ^= oldDigest[i]
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(digest)</span>
}

func init() <span class="cov8" title="1">{
        // register our sql driver with user-defined chexor function
        sql.Register("sqlite3_account",
                &amp;sqlite3.SQLiteDriver{
                        ConnectHook: func(conn *sqlite3.SQLiteConn) error </span><span class="cov8" title="1">{
                                if err := conn.RegisterFunc("chexor", chexor, true); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(pragmaScript, nil); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(`CREATE TEMPORARY VIEW IF NOT EXISTS maxrowid (max) AS
                                                                                  SELECT IFNULL(MAX(seq), -1) FROM sqlite_sequence WHERE name='container'`, nil); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
        )
}

type sqliteAccount struct {
        connectLock sync.Mutex
        *sql.DB
        accountFile         string
        hasDeletedNameIndex bool
        infoCache           atomic.Value
        policyStatsCache    atomic.Value
        ringhash            string
}

var _ Account = &amp;sqliteAccount{}

func (db *sqliteAccount) connect() error <span class="cov8" title="1">{
        db.connectLock.Lock()
        defer db.connectLock.Unlock()
        if db.DB != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">dbConn, err := sql.Open("sqlite3_account", "file:"+db.accountFile+"?psow=1&amp;_txlock=immediate&amp;mode=rw")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to open: %v", err)
        }</span>
        <span class="cov8" title="1">dbConn.SetMaxOpenConns(maxOpenConns)
        dbConn.SetMaxIdleConns(maxIdleConns)
        if db.hasDeletedNameIndex, err = schemaMigrate(dbConn); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return fmt.Errorf("Error migrating database: %v", err)
        }</span>
        <span class="cov8" title="1">db.DB = dbConn
        return nil</span>
}

// GetInfo returns the account's information as a AccountInfo struct.
func (db *sqliteAccount) GetInfo() (*AccountInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := db.flush(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if info, ok := db.infoCache.Load().(*AccountInfo); ok &amp;&amp; !info.invalid &amp;&amp; time.Since(info.updated) &lt; infoCacheTimeout </span><span class="cov8" title="1">{
                return info, nil
        }</span>
        <span class="cov8" title="1">info := &amp;AccountInfo{updated: time.Now()}
        row := db.QueryRow(`SELECT cs.account, cs.created_at, cs.put_timestamp,
                                                        cs.delete_timestamp, cs.status_changed_at,
                                                        cs.object_count, cs.bytes_used, cs.container_count,
                                                        cs.hash, cs.id, cs.metadata, maxrowid.max
                                                FROM account_stat cs, maxrowid`)
        if err := row.Scan(&amp;info.Account, &amp;info.CreatedAt, &amp;info.PutTimestamp,
                &amp;info.DeleteTimestamp, &amp;info.StatusChangedAt,
                &amp;info.ObjectCount, &amp;info.BytesUsed, &amp;info.ContainerCount,
                &amp;info.Hash, &amp;info.ID, &amp;info.RawMetadata, &amp;info.MaxRow); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if info.RawMetadata == "" </span><span class="cov0" title="0">{
                info.Metadata = make(map[string][]string)
        }</span><span class="cov8" title="1"> else if err := json.Unmarshal([]byte(info.RawMetadata), &amp;info.Metadata); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db.infoCache.Store(info)
        return info, nil</span>
}

func (db *sqliteAccount) PolicyStats() ([]*PolicyStat, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := db.flush(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if ps, ok := db.policyStatsCache.Load().(*policyStats); ok &amp;&amp; !ps.invalid &amp;&amp; time.Since(ps.updated) &lt; policyStatsCacheTimeout </span><span class="cov8" title="1">{
                return ps.list, nil
        }</span>
        <span class="cov8" title="1">ps := &amp;policyStats{updated: time.Now()}
        rows, err := db.Query(`SELECT storage_policy_index, container_count, object_count, bytes_used FROM policy_stat`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                e := &amp;PolicyStat{}
                if err := rows.Scan(&amp;e.StoragePolicyIndex, &amp;e.ContainerCount, &amp;e.ObjectCount, &amp;e.BytesUsed); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ps.list = append(ps.list, e)</span>
        }
        <span class="cov8" title="1">db.policyStatsCache.Store(ps)
        return ps.list, nil</span>
}

func (db *sqliteAccount) invalidateCache() <span class="cov8" title="1">{
        db.infoCache.Store(&amp;AccountInfo{invalid: true})
        db.policyStatsCache.Store(&amp;policyStats{invalid: true})
}</span>

// IsDeleted returns true if the account is deleted - if its delete timestamp is later than its put timestamp.
func (db *sqliteAccount) IsDeleted() (bool, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return info.DeleteTimestamp &gt; info.PutTimestamp, nil</span>
}

// Delete sets the account's deleted timestamp and tombstones any metadata older than that timestamp.
// This may or may not make the account "deleted".
func (db *sqliteAccount) Delete(timestamp string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var deleteTimestamp, metastr string
        var metadata map[string][]string
        if err := tx.QueryRow("SELECT delete_timestamp, metadata FROM account_stat").Scan(&amp;deleteTimestamp, &amp;metastr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if deleteTimestamp &gt;= timestamp </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                if value[1] &lt; timestamp </span><span class="cov8" title="1">{
                        metadata[key] = []string{"", timestamp}
                }</span>
        }
        <span class="cov8" title="1">serializedMetadata, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE account_stat SET delete_timestamp = ?, metadata = ?", timestamp, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// MergeItems merges ContainerRecords into the account.  If a remote id is provided (incoming replication), the incoming_sync table is updated.
func (db *sqliteAccount) MergeItems(records []*ContainerRecord, remoteID string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">names := make([]interface{}, len(records))
        existing := make(map[string]*ContainerRecord)
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for i, record := range records </span><span class="cov8" title="1">{
                names[i] = record.Name
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(records); i += maxQueryArgs </span><span class="cov8" title="1">{
                j := i + maxQueryArgs
                if j &gt; len(records) </span><span class="cov8" title="1">{
                        j = len(records)
                }</span>
                <span class="cov8" title="1">batch := names[i:j]
                query := ""
                if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                        query = fmt.Sprintf("SELECT name, put_timestamp, delete_timestamp, ROWID FROM container WHERE deleted IN (0, 1) AND name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span><span class="cov0" title="0"> else {
                        query = fmt.Sprintf("SELECT name, put_timestamp, delete_timestamp, ROWID FROM container WHERE name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span>
                <span class="cov8" title="1">rows, err := tx.Query(query, batch...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                for rows.Next() </span><span class="cov8" title="1">{
                        var name, putTimestamp, deleteTimestamp string
                        var rowid int64
                        if err := rows.Scan(&amp;name, &amp;putTimestamp, &amp;deleteTimestamp, &amp;rowid); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">existing[name] = &amp;ContainerRecord{PutTimestamp: putTimestamp, DeleteTimestamp: deleteTimestamp, Rowid: rowid}</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">dst, err := tx.Prepare("DELETE FROM container WHERE ROWID=?")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dst.Close()

        ast, err := tx.Prepare(`INSERT INTO container (name, put_timestamp, delete_timestamp, object_count, bytes_used, deleted, storage_policy_index)
                                                        VALUES (?, ?, ?, ?, ?, ?, ?)`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer ast.Close()

        var maxRowid int64 = -1
        for _, record := range records </span><span class="cov8" title="1">{
                if record.Rowid &gt; maxRowid </span><span class="cov8" title="1">{
                        maxRowid = record.Rowid
                }</span>
                <span class="cov8" title="1">if er, exists := existing[record.Name]; exists </span><span class="cov8" title="1">{
                        if _, err := dst.Exec(er.Rowid); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if er.PutTimestamp &gt; record.PutTimestamp </span><span class="cov0" title="0">{
                                record.PutTimestamp = er.PutTimestamp
                        }</span>
                        <span class="cov8" title="1">if er.DeleteTimestamp &gt; record.DeleteTimestamp </span><span class="cov0" title="0">{
                                record.DeleteTimestamp = er.DeleteTimestamp
                        }</span>
                        <span class="cov8" title="1">if record.DeleteTimestamp &gt; record.PutTimestamp </span><span class="cov8" title="1">{
                                record.Deleted = 1
                        }</span><span class="cov0" title="0"> else {
                                record.Deleted = 0
                        }</span>
                }
                <span class="cov8" title="1">if res, err := ast.Exec(record.Name, record.PutTimestamp, record.DeleteTimestamp, record.ObjectCount,
                        record.BytesUsed, record.Deleted, record.StoragePolicyIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if record.Rowid, err = res.LastInsertId(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">existing[record.Name] = record</span>
        }

        <span class="cov8" title="1">if remoteID != "" &amp;&amp; maxRowid &gt; -1 </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        maxRowid, remoteID, remoteID, maxRowid); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

func indexAfter(s, sep string, after int) int <span class="cov8" title="1">{
        index := strings.Index(s[after:], sep)
        if index == -1 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return index + after</span>
}

// ListContainers implements object listings.
func (db *sqliteAccount) ListContainers(limit int, marker string, endMarker string, prefix string, delimiter string,
        reverse bool) ([]interface{}, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var point, pointDirection, queryTail, queryStart string

        queryStart = "SELECT name, object_count, bytes_used, put_timestamp FROM container WHERE "
        if reverse </span><span class="cov8" title="1">{
                marker, endMarker = endMarker, marker
                queryTail = "ORDER BY name DESC LIMIT ?"
                pointDirection = "name &lt; ?"
        }</span><span class="cov8" title="1"> else {
                queryTail = "ORDER BY name LIMIT ?"
                pointDirection = "name &gt; ?"
        }</span>

        <span class="cov8" title="1">results := []interface{}{}
        queryArgs := make([]interface{}, 8)
        wheres := make([]string, 8)
        gotResults := true

        for len(results) &lt; limit &amp;&amp; gotResults </span><span class="cov8" title="1">{
                if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                        wheres = append(wheres[:0], "deleted = 0")
                }</span><span class="cov0" title="0"> else {
                        wheres = append(wheres[:0], "+deleted = 0")
                }</span>
                <span class="cov8" title="1">queryArgs = queryArgs[:0]
                if prefix != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name BETWEEN ? AND ?")
                        queryArgs = append(queryArgs, prefix, prefix+"\xFF")
                }</span>
                <span class="cov8" title="1">if marker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &gt; ?")
                        queryArgs = append(queryArgs, marker)
                }</span>
                <span class="cov8" title="1">if endMarker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &lt; ?")
                        queryArgs = append(queryArgs, endMarker)
                }</span>
                <span class="cov8" title="1">if point != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, pointDirection)
                        queryArgs = append(queryArgs, point)
                }</span>
                <span class="cov8" title="1">rows, err := db.Query(queryStart+" "+strings.Join(wheres, " AND ")+" "+queryTail,
                        append(queryArgs, limit-len(results))...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                gotResults = false
                for rows.Next() &amp;&amp; len(results) &lt; limit </span><span class="cov8" title="1">{
                        gotResults = true
                        record := &amp;ContainerListingRecord{}
                        if err := rows.Scan(&amp;record.Name, &amp;record.Count, &amp;record.Bytes, &amp;record.LastModified); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if f, err := strconv.ParseFloat(record.LastModified, 64); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span><span class="cov8" title="1"> else {
                                whole, nans := math.Modf(f)
                                record.LastModified = time.Unix(int64(whole), int64(nans*1.0e9)).In(common.GMT).Format("2006-01-02T15:04:05.000000")
                        }</span>
                        <span class="cov8" title="1">point = record.Name
                        if delimiter != "" </span><span class="cov8" title="1">{
                                end := indexAfter(record.Name, delimiter, len(prefix))
                                if end &gt;= 0 &amp;&amp; len(record.Name) &gt; end+1 </span><span class="cov8" title="1">{
                                        dirName := record.Name[:end] + delimiter
                                        if reverse </span><span class="cov8" title="1">{
                                                point = record.Name[:end+len(delimiter)]
                                        }</span><span class="cov8" title="1"> else {
                                                point = dirName + "\xFF"
                                        }</span>
                                        <span class="cov8" title="1">if dirName != marker </span><span class="cov8" title="1">{
                                                results = append(results, &amp;SubdirListingRecord{Name2: dirName, Name: dirName})
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">results = append(results, record)</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">rows.Close()
                if delimiter == "" </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return results, nil</span>
}

// NewID sets the account's ID to a new, random string.
func (db *sqliteAccount) NewID() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        _, err = tx.Exec(`INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point)
                                          SELECT account_stat.id, maxrowid.max FROM account_stat, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE account_stat SET id = ?", common.UUID()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// ItemsSince returns (count) object records with a rowid greater than (start).
func (db *sqliteAccount) ItemsSince(start int64, count int) ([]*ContainerRecord, error) <span class="cov8" title="1">{
        db.flush()
        records := []*ContainerRecord{}
        rows, err := db.Query(`SELECT ROWID, name, put_timestamp, delete_timestamp, object_count,
                                                   bytes_used, deleted, storage_policy_index
                                                   FROM container WHERE ROWID &gt; ? ORDER BY ROWID ASC LIMIT ?`, start, count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                r := &amp;ContainerRecord{}
                if err := rows.Scan(&amp;r.Rowid, &amp;r.Name, &amp;r.PutTimestamp, &amp;r.DeleteTimestamp, &amp;r.ObjectCount, &amp;r.BytesUsed, &amp;r.Deleted, &amp;r.StoragePolicyIndex); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">records = append(records, r)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return records, nil</span>
}

// GetMetadata returns the current account metadata as a simple map[string]string, i.e. it leaves out tombstones and timestamps.
func (db *sqliteAccount) GetMetadata() (map[string]string, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">metadata := make(map[string]string)
        for key, value := range info.Metadata </span><span class="cov8" title="1">{
                if value[0] != "" </span><span class="cov8" title="1">{
                        metadata[key] = value[0]
                }</span>
        }
        <span class="cov8" title="1">return metadata, nil</span>
}

func (db *sqliteAccount) mergeMetas(a map[string][]string, b map[string][]string, deleteTimestamp string) (string, error) <span class="cov8" title="1">{
        newMeta := map[string][]string{}
        for k, v := range a </span><span class="cov8" title="1">{
                newMeta[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if existing, ok := a[k]; ok </span><span class="cov8" title="1">{
                        if existing[1] &lt; v[1] </span><span class="cov8" title="1">{
                                newMeta[k] = v
                        }</span>
                }<span class="cov8" title="1"> else {
                        newMeta[k] = v
                }</span>
        }
        <span class="cov8" title="1">metaSize := 0
        metaCount := 0
        for k, v := range newMeta </span><span class="cov8" title="1">{
                if deleteTimestamp != "" &amp;&amp; v[1] &lt; deleteTimestamp </span><span class="cov8" title="1">{
                        newMeta[k] = []string{"", deleteTimestamp}
                }</span><span class="cov8" title="1"> else if v[0] != "" &amp;&amp; strings.HasPrefix(strings.ToLower(k), "x-account-meta-") </span><span class="cov8" title="1">{
                        metaSize += len(k) - 15
                        metaSize += len(v[0])
                        metaCount++
                }</span>
        }
        <span class="cov8" title="1">if metaCount &gt; maxMetaCount || metaSize &gt; maxMetaOverallSize </span><span class="cov0" title="0">{
                return "", ErrorInvalidMetadata
        }</span>
        <span class="cov8" title="1">serMeta, err := json.Marshal(newMeta)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(serMeta), nil</span>
}

// UpdateMetadata merges the current account metadata with new incoming metadata.
func (db *sqliteAccount) UpdateMetadata(newMetadata map[string][]string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(newMetadata) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var metadataValue, deleteTimestamp string
        if err := tx.QueryRow("SELECT metadata, delete_timestamp FROM account_stat").Scan(&amp;metadataValue, &amp;deleteTimestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if metadataValue == "" </span><span class="cov0" title="0">{
                existingMetadata = map[string][]string{}
        }</span><span class="cov8" title="1"> else if err := json.Unmarshal([]byte(metadataValue), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(existingMetadata, newMetadata, deleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE account_stat SET metadata=?", metastr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// MergeSyncTable updates the account's current incoming_sync table records.
func (db *sqliteAccount) MergeSyncTable(records []*SyncRecord) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for _, record := range records </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        record.SyncPoint, record.RemoteID, record.RemoteID, record.SyncPoint); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return tx.Commit()</span>
}

// CleanupTombstones removes any expired tombstoned objects or metadata.
func (db *sqliteAccount) CleanupTombstones(reclaimAge int64) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">now := float64(time.Now().UnixNano()) / 1000000000.0
        reclaimTimestamp := common.CanonicalTimestamp(now - float64(reclaimAge))

        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err = tx.Exec("DELETE FROM container WHERE deleted=1 AND delete_timestamp &lt; ?", reclaimTimestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var metastr string
        if err := tx.QueryRow("SELECT metadata FROM account_stat").Scan(&amp;metastr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var metadata map[string][]string
        updated := false
        if metastr == "" </span><span class="cov0" title="0">{
                metadata = map[string][]string{}
                updated = true
        }</span><span class="cov8" title="1"> else {
                if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for k, v := range metadata </span><span class="cov0" title="0">{
                        if v[0] == "" </span><span class="cov0" title="0">{
                                if ts, err := common.GetEpochFromTimestamp(v[1]); err != nil || ts &lt; reclaimTimestamp </span><span class="cov0" title="0">{
                                        delete(metadata, k)
                                        updated = true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if updated </span><span class="cov0" title="0">{
                if mb, err := json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov0" title="0"> else if _, err = tx.Exec("UPDATE account_stat SET metadata = ?", string(mb)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// SyncTable returns the account's current incoming_sync table, and also includes the current account's id and max row as an entry.
func (db *sqliteAccount) SyncTable() ([]*SyncRecord, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">records := []*SyncRecord{}
        rows, err := db.Query(`SELECT sync_point, remote_id FROM incoming_sync
                                                   WHERE remote_id NOT IN (SELECT id FROM account_stat)
                                                   UNION
                                                   SELECT maxrowid.max AS sync_point, account_stat.id AS remote_id
                                                   FROM account_stat, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                rec := &amp;SyncRecord{}
                if err := rows.Scan(&amp;rec.SyncPoint, &amp;rec.RemoteID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">records = append(records, rec)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return records, nil</span>
}

// SyncRemoteData compares a remote account's info to the local info and updates any necessary replication bookkeeping, returning the current account's info.
func (db *sqliteAccount) SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*AccountInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var localMeta, localHash, localDeleteTimestamp string
        var localPoint int64
        if err := tx.QueryRow("SELECT hash, metadata, delete_timestamp FROM account_stat").Scan(&amp;localHash, &amp;localMeta, &amp;localDeleteTimestamp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var lm, rm map[string][]string
        if err := json.Unmarshal([]byte(metadata), &amp;rm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(localMeta), &amp;lm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if deleteTimestamp &gt; localDeleteTimestamp </span><span class="cov8" title="1">{
                localDeleteTimestamp = deleteTimestamp
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(lm, rm, localDeleteTimestamp)
        if _, err = tx.Exec(`UPDATE account_stat SET created_at=MIN(?, created_at), put_timestamp=MAX(?, put_timestamp),
                                                   delete_timestamp=MAX(?, delete_timestamp), metadata=?`,
                createdAt, putTimestamp, deleteTimestamp, metastr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := tx.QueryRow("SELECT IFNULL(MAX(sync_point), -1) FROM incoming_sync WHERE remote_id = ?", id).Scan(&amp;localPoint); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if localHash == hash &amp;&amp; maxRow &gt; localPoint </span><span class="cov8" title="1">{
                localPoint = maxRow
                if _, err = tx.Exec("INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point) VALUES (?, ?)", id, localPoint); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db.invalidateCache()
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">info.Point = localPoint
        return info, nil</span>
}

// OpenDatabaseFile blocks updates and opens the underlying database file for reading, so it can be uploaded to a remote server.
func (db *sqliteAccount) OpenDatabaseFile() (*os.File, func(), error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">var fp *os.File
        if _, err := db.Exec(`
                PRAGMA locking_mode = EXCLUSIVE;      -- grab and hold a shared lock
                SELECT 1 FROM account_stat LIMIT 1;   -- it doesn't actually lock until you hit the database
                PRAGMA wal_checkpoint(TRUNCATE);      -- truncate the wal file, if it exists`,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error locking database%s: %v", db.accountFile, err)
        }</span>
        <span class="cov8" title="1">cleanup := func() </span><span class="cov8" title="1">{
                db.Exec(`
                        PRAGMA locking_mode = NORMAL;         -- release shared lock
                        SELECT 1 FROM account_stat LIMIT 1; -- actually release shared lock
                `)
                if fp != nil </span><span class="cov8" title="1">{
                        fp.Close()
                }</span>
        }
        // make sure there aren't any journals lying around
        <span class="cov8" title="1">if stat, err := os.Stat(db.accountFile + "-wal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn wal file still exists: %s", db.accountFile)
        }</span>
        <span class="cov8" title="1">if stat, err := os.Stat(db.accountFile + "-journal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn journal file still exists: %s", db.accountFile)
        }</span>
        <span class="cov8" title="1">fp, err := os.Open(db.accountFile)
        if err != nil </span><span class="cov0" title="0">{
                fp = nil
                cleanup()
                return nil, nil, fmt.Errorf("Error opening %s: %v", db.accountFile, err)
        }</span>
        <span class="cov8" title="1">return fp, cleanup, nil</span>
}

// ID returns the account's ring hash as a unique identifier for it.
func (db *sqliteAccount) ID() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

// RingHash returns the account's ring hash as a string.
func (db *sqliteAccount) RingHash() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

func (db *sqliteAccount) flushAlreadyLocked() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if stat, err := os.Stat(db.accountFile + ".pending"); err != nil || stat.Size() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">contents, err := ioutil.ReadFile(db.accountFile + ".pending")
        if err != nil || len(contents) == 0 </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var records []*ContainerRecord
        for _, base64ed := range strings.Split(string(contents), ":") </span><span class="cov8" title="1">{
                if len(base64ed) &lt; 1 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">pickled, err := base64.StdEncoding.DecodeString(base64ed)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">r, err := pickle.PickleLoads(pickled)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">record, ok := r.([]interface{})
                if !ok || len(record) &lt; 7 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Invalid commit pending record")
                }</span>
                <span class="cov8" title="1">casts := make([]bool, 7)
                var deleted, spi int64
                rec := &amp;ContainerRecord{}
                rec.Name, casts[0] = record[0].(string)
                rec.PutTimestamp, casts[1] = record[1].(string)
                rec.DeleteTimestamp, casts[2] = record[2].(string)
                rec.ObjectCount, casts[3] = int64MaybeStringified(record[3])
                rec.BytesUsed, casts[4] = int64MaybeStringified(record[4])
                deleted, casts[5] = record[5].(int64)
                rec.Deleted = int(deleted)
                spi, casts[6] = int64MaybeStringified(record[6])
                rec.StoragePolicyIndex = int(spi)
                for i := 0; i &lt; 7; i++ </span><span class="cov8" title="1">{
                        if !casts[i] </span><span class="cov0" title="0">{
                                return fmt.Errorf("Invalid commit pending record")
                        }</span>
                }
                <span class="cov8" title="1">records = append(records, rec)</span>
        }
        <span class="cov8" title="1">err = db.MergeItems(records, "")
        if err == nil </span><span class="cov8" title="1">{
                err = os.Truncate(db.accountFile+".pending", 0)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func int64MaybeStringified(i interface{}) (int64, bool) <span class="cov8" title="1">{
        if a, ok := i.(int64); ok </span><span class="cov8" title="1">{
                return a, true
        }</span><span class="cov8" title="1"> else if b, ok := i.(string); !ok </span><span class="cov8" title="1">{
                return 0, false
        }</span><span class="cov8" title="1"> else {
                c, err := strconv.ParseInt(b, 10, 64)
                return c, err == nil
        }</span>
}

func (db *sqliteAccount) flush() error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.accountFile), 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        return db.flushAlreadyLocked()</span>
}

// PutContainer adds a container to the account, by way of pending file.
func (db *sqliteAccount) PutContainer(name string, putTimestamp string, deleteTimestamp string, objectCount int64, bytesUsed int64, storagePolicyIndex int) error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.accountFile), 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        deleted := 0
        if deleteTimestamp &gt; putTimestamp </span><span class="cov0" title="0">{
                deleted = 1
        }</span>
        <span class="cov8" title="1">tuple := []interface{}{name, putTimestamp, deleteTimestamp, objectCount, bytesUsed, deleted, storagePolicyIndex}
        file, err := os.OpenFile(db.accountFile+".pending", os.O_RDWR|os.O_APPEND|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        if _, err := file.WriteString(":" + base64.StdEncoding.EncodeToString(pickle.PickleDumps(tuple))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if info, err := file.Stat(); err == nil &amp;&amp; info.Size() &gt; pendingCap </span><span class="cov0" title="0">{
                db.flushAlreadyLocked()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Close closes the underlying sqlite database connection.
func (db *sqliteAccount) Close() error <span class="cov8" title="1">{
        db.connectLock.Lock()
        defer func() </span><span class="cov8" title="1">{
                db.DB = nil
                db.connectLock.Unlock()
        }</span>()
        <span class="cov8" title="1">if db.DB != nil </span><span class="cov8" title="1">{
                return db.DB.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sqliteCreateExistingAccount(db Account, putTimestamp string, newMetadata map[string][]string) (bool, error) <span class="cov8" title="1">{
        cdb, ok := db.(*sqliteAccount)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("Unable to work with non-sqliteAccount")
        }</span>
        <span class="cov8" title="1">if err := cdb.connect(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">tx, err := cdb.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var cDeleteTimestamp, cPutTimestamp, cMetadata string
        row := tx.QueryRow("SELECT put_timestamp, delete_timestamp, metadata FROM account_stat")
        if err := row.Scan(&amp;cPutTimestamp, &amp;cDeleteTimestamp, &amp;cMetadata); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if cMetadata == "" </span><span class="cov0" title="0">{
                existingMetadata = make(map[string][]string)
        }</span><span class="cov8" title="1"> else if err := json.Unmarshal([]byte(cMetadata), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">metastr, err := cdb.mergeMetas(existingMetadata, newMetadata, cDeleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec("UPDATE account_stat SET put_timestamp = ?, metadata = ?",
                putTimestamp, metastr); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer cdb.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return (cDeleteTimestamp &gt; cPutTimestamp &amp;&amp; putTimestamp &gt; cDeleteTimestamp), nil</span>
}

func sqliteCreateAccount(accountFile string, account string, putTimestamp string, metadata map[string][]string) error <span class="cov8" title="1">{
        var serializedMetadata []byte
        var err error

        if fs.Exists(accountFile) </span><span class="cov0" title="0">{
                return errors.New("Account exists!")
        }</span>
        <span class="cov8" title="1">if metadata == nil </span><span class="cov8" title="1">{
                serializedMetadata = []byte("{}")
        }</span><span class="cov8" title="1"> else if serializedMetadata, err = json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">hashDir := filepath.Dir(accountFile)
        if err := os.MkdirAll(hashDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tfp, err := ioutil.TempFile(hashDir, ".newdb")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tfp.Chmod(0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tfp.Close()
        tempFile := tfp.Name()
        dbConn, err := sql.Open("sqlite3_account", "file:"+tempFile+"?psow=1&amp;_txlock=immediate&amp;mode=rwc")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dbConn.Close()
        tx, err := dbConn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err := tx.Exec(accountDBScript + policyStatTableScript + policyStatTriggerScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(`INSERT INTO account_stat (account, created_at, id, put_timestamp,
                                                  status_changed_at, metadata, container_count) VALUES (?, ?, ?, ?, ?, ?, 0)`,
                account, common.GetTimestamp(), common.UUID(), putTimestamp, putTimestamp, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.Rename(tempFile, accountFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sqliteOpenAccount(accountFile string) (ReplicableAccount, error) <span class="cov8" title="1">{
        if !fs.Exists(accountFile) </span><span class="cov0" title="0">{
                return nil, ErrorNoSuchAccount
        }</span>
        <span class="cov8" title="1">db := &amp;sqliteAccount{
                accountFile:         accountFile,
                hasDeletedNameIndex: false,
                ringhash:            filepath.Base(filepath.Dir(accountFile)),
        }
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package bench

import (
        "fmt"
        "io"
        "io/ioutil"
        "math/rand"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
)

type ContainerObject struct {
        Url string
}

func (obj *ContainerObject) Put() bool <span class="cov0" title="0">{
        req, err := http.NewRequest("PUT", obj.Url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Timestamp", common.GetTimestamp())
        req.Header.Set("X-Content-Type", "application/octet-stream")
        req.Header.Set("X-Size", "0")
        req.Header.Set("X-Etag", "d41d8cd98f00b204e9800998ecf8427e")
        resp, err := http.DefaultClient.Do(req)
        if resp != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2</span>
}

func (obj *ContainerObject) Delete() bool <span class="cov0" title="0">{
        req, _ := http.NewRequest("DELETE", obj.Url, nil)
        req.Header.Set("X-Timestamp", common.GetTimestamp())
        resp, err := http.DefaultClient.Do(req)
        if resp != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2</span>
}

func RunCBench(args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: [configuration file]")
                fmt.Println("The configuration file should look something like:")
                fmt.Println("    [cbench]")
                fmt.Println("    address = http://127.0.0.1:6011/")
                fmt.Println("    containers = 5")
                fmt.Println("    concurrency = 10")
                fmt.Println("    num_objects = 10000")
                fmt.Println("    num_gets = 500")
                fmt.Println("    delete = yes")
                fmt.Println("    check_mounted = false")
                fmt.Println("    #drive_list = sdb1,sdb2")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">benchconf, err := conf.LoadConfig(args[0])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing ini file:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">address := benchconf.GetDefault("cbench", "address", "http://127.0.0.1:6011/")
        if !strings.HasSuffix(address, "/") </span><span class="cov0" title="0">{
                address = address + "/"
        }</span>
        <span class="cov0" title="0">concurrency := int(benchconf.GetInt("cbench", "concurrency", 10))
        containerCount := int(benchconf.GetInt("cbench", "containers", 5))
        numObjects := benchconf.GetInt("cbench", "num_objects", 10000)
        numGets := int(benchconf.GetInt("cbench", "num_gets", 500))
        checkMounted := benchconf.GetBool("cbench", "check_mounted", false)
        driveList := benchconf.GetDefault("cbench", "drive_list", "")
        numPartitions := int64(100)
        delete := benchconf.GetBool("cbench", "delete", true)

        deviceList := GetDevices(address, checkMounted)
        if driveList != "" </span><span class="cov0" title="0">{
                deviceList = strings.Split(driveList, ",")
        }</span>

        <span class="cov0" title="0">containers := make([]string, containerCount)
        for i := 0; i &lt; containerCount; i++ </span><span class="cov0" title="0">{
                device := strings.Trim(deviceList[i%len(deviceList)], " ")
                part := rand.Int63() % numPartitions
                cid := rand.Int63()
                containers[i] = fmt.Sprintf("%s%s/%d/%s/%d", address, device, part, "a", cid)
                req, _ := http.NewRequest("PUT", containers[i], nil)
                req.Header.Set("X-Timestamp", common.GetTimestamp())
                resp, err := http.DefaultClient.Do(req)
                if resp != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                }</span>
                <span class="cov0" title="0">if err != nil || resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        fmt.Println("Container PUT failed: ", resp.StatusCode, err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">objects := make([]*ContainerObject, numObjects)
        for i := range objects </span><span class="cov0" title="0">{
                container := containers[i%len(containers)]
                objects[i] = &amp;ContainerObject{
                        Url: fmt.Sprintf("%s/%d", container, rand.Int63()),
                }
        }</span>

        <span class="cov0" title="0">work := make([]func() bool, len(objects))
        for i := range objects </span><span class="cov0" title="0">{
                work[i] = objects[i].Put
        }</span>
        <span class="cov0" title="0">DoJobs("OBJECT PUT", work, concurrency)

        time.Sleep(time.Second * 2)

        getContainer := func() bool </span><span class="cov0" title="0">{
                container := containers[rand.Int()%len(containers)]
                req, _ := http.NewRequest("GET", container+"?format=json", nil)
                resp, err := http.DefaultClient.Do(req)
                if err == nil </span><span class="cov0" title="0">{
                        defer resp.Body.Close()
                        w, err := io.Copy(ioutil.Discard, resp.Body)
                        if err != nil || w &lt; 2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2 &amp;&amp; resp.Header.Get("Content-Type") == "application/json; charset=utf-8"</span>
        }
        <span class="cov0" title="0">work = make([]func() bool, numGets)
        for i := 0; i &lt; numGets; i++ </span><span class="cov0" title="0">{
                work[i] = getContainer
        }</span>
        <span class="cov0" title="0">DoJobs("CONTAINER GET", work, concurrency)

        time.Sleep(time.Second * 2)

        if delete </span><span class="cov0" title="0">{
                work = make([]func() bool, len(objects))
                for i := range objects </span><span class="cov0" title="0">{
                        work[i] = objects[i].Delete
                }</span>
                <span class="cov0" title="0">DoJobs("OBJECT DELETE", work, concurrency)</span>
        }
}

func RunCGBench(args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: [configuration file]")
                fmt.Println("The configuration file should look something like:")
                fmt.Println("    [cgbench]")
                fmt.Println("    address = http://127.0.0.1:6011/")
                fmt.Println("    concurrency = 5")
                fmt.Println("    num_objects = 5000000")
                fmt.Println("    report_interval = 100000")
                fmt.Println("    num_gets = 10")
                fmt.Println("    check_mounted = false")
                fmt.Println("    #drive_list = sdb1,sdb2")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">benchconf, err := conf.LoadConfig(args[0])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing ini file:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">address := benchconf.GetDefault("cgbench", "address", "http://127.0.0.1:6011/")
        if !strings.HasSuffix(address, "/") </span><span class="cov0" title="0">{
                address = address + "/"
        }</span>
        <span class="cov0" title="0">concurrency := int(benchconf.GetInt("cgbench", "concurrency", 5))
        reportInterval := benchconf.GetInt("cgbench", "report_interval", 100000)
        numObjects := benchconf.GetInt("cgbench", "num_objects", 5000000)
        numGets := int(benchconf.GetInt("cgbench", "num_gets", 10))
        checkMounted := benchconf.GetBool("cgbench", "check_mounted", false)
        driveList := benchconf.GetDefault("cgbench", "drive_list", "")
        numPartitions := int64(100)

        deviceList := GetDevices(address, checkMounted)
        if driveList != "" </span><span class="cov0" title="0">{
                deviceList = strings.Split(driveList, ",")
        }</span>

        <span class="cov0" title="0">device := strings.Trim(deviceList[0], " ")
        part := rand.Int63() % numPartitions
        cid := rand.Int63()
        container := fmt.Sprintf("%s%s/%d/%s/%d", address, device, part, "a", cid)
        req, _ := http.NewRequest("PUT", container, nil)
        req.Header.Set("X-Timestamp", common.GetTimestamp())
        resp, err := http.DefaultClient.Do(req)
        if resp != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
        }</span>
        <span class="cov0" title="0">if err != nil || resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                fmt.Println("Container PUT failed: ", resp.StatusCode, err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">for totalObjects := int64(0); totalObjects &lt; numObjects; totalObjects += reportInterval </span><span class="cov0" title="0">{
                fmt.Println("Object count:", totalObjects)
                objects := make([]*ContainerObject, int(reportInterval))
                for i := range objects </span><span class="cov0" title="0">{
                        objects[i] = &amp;ContainerObject{
                                Url: fmt.Sprintf("%s/%d", container, rand.Int63()),
                        }
                }</span>

                <span class="cov0" title="0">work := make([]func() bool, len(objects))
                for i := range objects </span><span class="cov0" title="0">{
                        work[i] = objects[i].Put
                }</span>
                <span class="cov0" title="0">DoJobs("OBJECT PUT", work, concurrency)

                time.Sleep(time.Second * 2)

                getContainer := func() bool </span><span class="cov0" title="0">{
                        req, _ := http.NewRequest("GET", container+"?format=json&amp;marker=5", nil)
                        resp, err := http.DefaultClient.Do(req)
                        if err == nil </span><span class="cov0" title="0">{
                                defer resp.Body.Close()
                                w, err := io.Copy(ioutil.Discard, resp.Body)
                                if err != nil || w &lt; 2 </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                        <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2 &amp;&amp; resp.Header.Get("Content-Type") == "application/json; charset=utf-8"</span>
                }
                <span class="cov0" title="0">work = make([]func() bool, numGets)
                for i := 0; i &lt; numGets; i++ </span><span class="cov0" title="0">{
                        work[i] = getContainer
                }</span>
                <span class="cov0" title="0">DoJobs("CONTAINER GET", work, concurrency)

                time.Sleep(time.Second * 2)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package bench

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "math/rand"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
)

type DirectObject struct {
        Url  string
        Data []byte
}

func (obj *DirectObject) Put() bool <span class="cov0" title="0">{
        req, _ := http.NewRequest("PUT", obj.Url, bytes.NewReader(obj.Data))
        req.Header.Set("Content-Length", strconv.FormatInt(int64(len(obj.Data)), 10))
        req.Header.Set("X-Timestamp", common.GetTimestamp())
        req.Header.Set("Content-Type", "application/octet-stream")
        req.ContentLength = int64(len(obj.Data))
        resp, err := http.DefaultClient.Do(req)
        if resp != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed Put: ", err)
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2</span>
}

func (obj *DirectObject) Get() bool <span class="cov0" title="0">{
        req, _ := http.NewRequest("GET", obj.Url, nil)
        resp, err := http.DefaultClient.Do(req)
        if resp != nil </span><span class="cov0" title="0">{
                io.Copy(ioutil.Discard, resp.Body)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed Get: ", err)
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2</span>
}

func (obj *DirectObject) Replicate() bool <span class="cov0" title="0">{
        req, _ := http.NewRequest("REPLICATE", obj.Url, nil)
        resp, err := http.DefaultClient.Do(req)
        if resp != nil </span><span class="cov0" title="0">{
                io.Copy(ioutil.Discard, resp.Body)
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2</span>
}

func (obj *DirectObject) Delete() bool <span class="cov0" title="0">{
        req, _ := http.NewRequest("DELETE", obj.Url, nil)
        req.Header.Set("X-Timestamp", common.GetTimestamp())
        resp, err := http.DefaultClient.Do(req)
        if resp != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed Delete: ", err)
        }</span>
        <span class="cov0" title="0">return err == nil &amp;&amp; resp.StatusCode/100 == 2</span>
}

func GetDevices(address string, checkMounted bool) []string <span class="cov0" title="0">{
        deviceUrl := fmt.Sprintf("%srecon/diskusage", address)
        req, err := http.NewRequest("GET", deviceUrl, nil)
        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(fmt.Sprintf("ERROR GETTING DEVICES: %s", err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">body, _ := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        var rdata interface{}
        json.Unmarshal(body, &amp;rdata)
        retvals := []string{}
        for _, v := range rdata.([]interface{}) </span><span class="cov0" title="0">{
                val := v.(map[string]interface{})
                if !checkMounted || val["mounted"].(bool) </span><span class="cov0" title="0">{
                        retvals = append(retvals, val["device"].(string))
                }</span>
        }
        <span class="cov0" title="0">return retvals</span>
}

func RunDBench(args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: [configuration file]")
                fmt.Println("The configuration file should look something like:")
                fmt.Println("    [dbench]")
                fmt.Println("    address = http://localhost:6010/")
                fmt.Println("    concurrency = 15")
                fmt.Println("    object_size = 131072")
                fmt.Println("    num_objects = 5000")
                fmt.Println("    num_gets = 30000")
                fmt.Println("    do_replicates = false")
                fmt.Println("    delete = yes")
                fmt.Println("    minimum_partition_number = 1000000000")
                fmt.Println("    check_mounted = false")
                fmt.Println("    #drive_list = sdb1,sdb2")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">benchconf, err := conf.LoadConfig(args[0])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing ini file:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">address := benchconf.GetDefault("dbench", "address", "http://localhost:6010/")
        if !strings.HasSuffix(address, "/") </span><span class="cov0" title="0">{
                address = address + "/"
        }</span>
        <span class="cov0" title="0">concurrency := int(benchconf.GetInt("dbench", "concurrency", 16))
        objectSize := benchconf.GetInt("dbench", "object_size", 131072)
        numObjects := benchconf.GetInt("dbench", "num_objects", 5000)
        numGets := benchconf.GetInt("dbench", "num_gets", 30000)
        doReplicates := benchconf.GetBool("dbench", "do_replicates", false)
        checkMounted := benchconf.GetBool("dbench", "check_mounted", false)
        driveList := benchconf.GetDefault("dbench", "drive_list", "")
        numPartitions := int64(100)
        minPartition := benchconf.GetInt("dbench", "minimum_partition_number", 1000000000)
        delete := benchconf.GetBool("dbench", "delete", true)

        deviceList := GetDevices(address, checkMounted)
        if driveList != "" </span><span class="cov0" title="0">{
                deviceList = strings.Split(driveList, ",")
        }</span>

        <span class="cov0" title="0">data := make([]byte, objectSize)
        objects := make([]*DirectObject, numObjects)
        deviceParts := make(map[string]bool)
        for i := range objects </span><span class="cov0" title="0">{
                device := strings.Trim(deviceList[i%len(deviceList)], " ")
                part := rand.Int63()%numPartitions + minPartition
                objects[i] = &amp;DirectObject{
                        Url:  fmt.Sprintf("%s%s/%d/%s/%s/%d", address, device, part, "a", "c", rand.Int63()),
                        Data: data,
                }
                deviceParts[fmt.Sprintf("%s/%d", device, part)] = true
        }</span>

        <span class="cov0" title="0">work := make([]func() bool, len(objects))
        for i := range objects </span><span class="cov0" title="0">{
                work[i] = objects[i].Put
        }</span>
        <span class="cov0" title="0">DoJobs("PUT", work, concurrency)

        time.Sleep(time.Second * 2)

        replWork := make([]func() bool, 0)
        for replKey := range deviceParts </span><span class="cov0" title="0">{
                devicePart := strings.Split(replKey, "/")
                replWork = append(replWork, (&amp;DirectObject{Url: fmt.Sprintf("%s%s/%s", address, devicePart[0], devicePart[1])}).Replicate)
        }</span>
        <span class="cov0" title="0">if doReplicates </span><span class="cov0" title="0">{
                DoJobs("REPLICATE", replWork, concurrency)
        }</span>

        <span class="cov0" title="0">work = make([]func() bool, numGets)
        for i := int64(0); i &lt; numGets; i++ </span><span class="cov0" title="0">{
                work[i] = objects[int(rand.Int63()%int64(len(objects)))].Get
        }</span>
        <span class="cov0" title="0">DoJobs("GET", work, concurrency)

        if delete </span><span class="cov0" title="0">{
                work = make([]func() bool, len(objects))
                for i := range objects </span><span class="cov0" title="0">{
                        work[i] = objects[i].Delete
                }</span>
                <span class="cov0" title="0">DoJobs("DELETE", work, concurrency)</span>
        }

        <span class="cov0" title="0">if doReplicates </span><span class="cov0" title="0">{
                DoJobs("REPLICATE", replWork, concurrency)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package bench

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "math/rand"
        "net/http"
        "os"
        "sort"
        "sync"
        "time"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common/conf"
)

type Object struct {
        c         client.Client
        state     int
        container string
        name      string
        data      []byte
}

func (obj *Object) Put() bool <span class="cov0" title="0">{
        resp := obj.c.PutObject(obj.container, obj.name, nil, bytes.NewReader(obj.data))
        resp.Body.Close()
        return resp.StatusCode/100 != 2
}</span>

func (obj *Object) Get() bool <span class="cov0" title="0">{
        if resp := obj.c.GetObject(obj.container, obj.name, nil); resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                resp.Body.Close()
                return false
        }</span><span class="cov0" title="0"> else {
                io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                return true
        }</span>
}

func (obj *Object) Delete() bool <span class="cov0" title="0">{
        return obj.c.DeleteObject(obj.container, obj.name, nil) == nil
}</span>

func DoJobs(name string, work []func() bool, concurrency int) <span class="cov0" title="0">{
        wg := sync.WaitGroup{}
        cwg := sync.WaitGroup{}
        errorCount := 0
        jobTimes := make([]float64, 0, len(work))
        times := make(chan float64)
        errors := make(chan int)
        jobqueue := make(chan func() bool)
        cwg.Add(2)
        go func() </span><span class="cov0" title="0">{
                for n := range errors </span><span class="cov0" title="0">{
                        errorCount += n
                }</span>
                <span class="cov0" title="0">cwg.Done()</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for t := range times </span><span class="cov0" title="0">{
                        jobTimes = append(jobTimes, t)
                }</span>
                <span class="cov0" title="0">sort.Float64s(jobTimes)
                cwg.Done()</span>
        }()
        <span class="cov0" title="0">for i := 0; i &lt; concurrency; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        for job := range jobqueue </span><span class="cov0" title="0">{
                                startJob := time.Now()
                                if !job() </span><span class="cov0" title="0">{
                                        errors &lt;- 1
                                }</span>
                                <span class="cov0" title="0">times &lt;- float64(time.Now().Sub(startJob)) / float64(time.Second)</span>
                        }
                        <span class="cov0" title="0">wg.Done()</span>
                }()
        }
        <span class="cov0" title="0">start := time.Now()
        for _, job := range work </span><span class="cov0" title="0">{
                jobqueue &lt;- job
        }</span>
        <span class="cov0" title="0">close(jobqueue)
        wg.Wait()
        totalTime := float64(time.Now().Sub(start)) / float64(time.Second)
        close(errors)
        close(times)
        cwg.Wait()
        sum := 0.0
        for _, val := range jobTimes </span><span class="cov0" title="0">{
                sum += val
        }</span>
        <span class="cov0" title="0">avg := sum / float64(len(work))
        diffsum := 0.0
        for _, val := range jobTimes </span><span class="cov0" title="0">{
                diffsum += math.Pow(val-avg, 2.0)
        }</span>
        <span class="cov0" title="0">fmt.Printf("%ss: %d @ %.2f/s\n", name, len(work), float64(len(work))/totalTime)
        fmt.Println("  Failures:", errorCount)
        fmt.Printf("  Mean: %.5fs (%.1f%% RSD)\n", avg, math.Sqrt(diffsum/float64(len(work)))*100.0/avg)
        fmt.Printf("  Median: %.5fs\n", jobTimes[int(float64(len(jobTimes))*0.5)])
        fmt.Printf("  85%%: %.5fs\n", jobTimes[int(float64(len(jobTimes))*0.85)])
        fmt.Printf("  90%%: %.5fs\n", jobTimes[int(float64(len(jobTimes))*0.90)])
        fmt.Printf("  95%%: %.5fs\n", jobTimes[int(float64(len(jobTimes))*0.95)])
        fmt.Printf("  99%%: %.5fs\n", jobTimes[int(float64(len(jobTimes))*0.99)])</span>
}

func RunBench(args []string) <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: [configuration file]")
                fmt.Println("Only supports auth 1.0.")
                fmt.Println("The configuration file should look something like:")
                fmt.Println("    [bench]")
                fmt.Println("    auth = http://localhost:8080/auth/v1.0")
                fmt.Println("    user = test:tester")
                fmt.Println("    key = testing")
                fmt.Println("    concurrency = 15")
                fmt.Println("    object_size = 131072")
                fmt.Println("    num_objects = 5000")
                fmt.Println("    num_gets = 30000")
                fmt.Println("    delete = yes")
                fmt.Println("    allow_insecure_auth_cert = no")
                fmt.Println("    single_container = false")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">benchconf, err := conf.LoadConfig(args[0])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing ini file:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">authURL := benchconf.GetDefault("bench", "auth", "http://localhost:8080/auth/v1.0")
        authUser := benchconf.GetDefault("bench", "user", "test:tester")
        authKey := benchconf.GetDefault("bench", "key", "testing")
        concurrency := int(benchconf.GetInt("bench", "concurrency", 16))
        objectSize := benchconf.GetInt("bench", "object_size", 131072)
        numObjects := benchconf.GetInt("bench", "num_objects", 5000)
        numGets := benchconf.GetInt("bench", "num_gets", 30000)
        delete := benchconf.GetBool("bench", "delete", true)
        singleContainer := benchconf.GetBool("bench", "single_container", false)
        allowInsecureAuthCert := benchconf.GetBool("bench", "allow_insecure_auth_cert", false)
        salt := fmt.Sprintf("%d", rand.Int63())

        var cli client.Client
        var resp *http.Response
        if allowInsecureAuthCert </span><span class="cov0" title="0">{
                cli, resp = client.NewInsecureClient("", authUser, "", authKey, "", authURL, false)
        }</span><span class="cov0" title="0"> else {
                cli, resp = client.NewClient("", authUser, "", authKey, "", authURL, false)
        }</span>
        <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                msg, _ := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                fmt.Println("Error creating client:", msg)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">numContainers := concurrency
        if singleContainer </span><span class="cov0" title="0">{
                numContainers = 1
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; numContainers; i++ </span><span class="cov0" title="0">{
                if err := cli.PutContainer(fmt.Sprintf("%d-%s", i, salt), nil); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error putting container:", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">data := make([]byte, objectSize)
        objects := make([]*Object, numObjects)
        for i := range objects </span><span class="cov0" title="0">{
                objects[i] = &amp;Object{
                        state:     0,
                        container: fmt.Sprintf("%d-%s", i%numContainers, salt),
                        name:      fmt.Sprintf("%x", rand.Int63()),
                        data:      data,
                        c:         cli,
                }
        }</span>

        <span class="cov0" title="0">work := make([]func() bool, len(objects))
        for i := range objects </span><span class="cov0" title="0">{
                work[i] = objects[i].Put
        }</span>
        <span class="cov0" title="0">DoJobs("PUT", work, concurrency)

        time.Sleep(time.Second * 2)

        work = make([]func() bool, numGets)
        for i := int64(0); i &lt; numGets; i++ </span><span class="cov0" title="0">{
                work[i] = objects[int(rand.Int63()%int64(len(objects)))].Get
        }</span>
        <span class="cov0" title="0">DoJobs("GET", work, concurrency)

        if delete </span><span class="cov0" title="0">{
                work = make([]func() bool, len(objects))
                for i := range objects </span><span class="cov0" title="0">{
                        work[i] = objects[i].Delete
                }</span>
                <span class="cov0" title="0">DoJobs("DELETE", work, concurrency)
                for i := 0; i &lt; numContainers; i++ </span><span class="cov0" title="0">{
                        if err := cli.DeleteContainer(fmt.Sprintf("%d-%s", i, salt), nil); err != nil </span><span class="cov0" title="0">{
                                fmt.Println("Error deleting container:", err)
                                os.Exit(1)
                        }</span>
                }
        }
}

func RunThrash(args []string) <span class="cov0" title="0">{
        rand.Seed(time.Now().UTC().UnixNano())
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fmt.Println("Usage: [configuration file]")
                fmt.Println("Only supports auth 1.0.")
                fmt.Println("The configuration file should look something like:")
                fmt.Println("    [thrash]")
                fmt.Println("    auth = http://localhost:8080/auth/v1.0")
                fmt.Println("    user = test:tester")
                fmt.Println("    key = testing")
                fmt.Println("    concurrency = 15")
                fmt.Println("    object_size = 131072")
                fmt.Println("    num_objects = 5000")
                fmt.Println("    gets_per_object = 5")
                fmt.Println("    allow_insecure_auth_cert = no")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">thrashconf, err := conf.LoadConfig(args[0])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing ini file:", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">authURL := thrashconf.GetDefault("thrash", "auth", "http://localhost:8080/auth/v1.0")
        authUser := thrashconf.GetDefault("thrash", "user", "test:tester")
        authKey := thrashconf.GetDefault("thrash", "key", "testing")
        concurrency := int(thrashconf.GetInt("thrash", "concurrency", 16))
        objectSize := thrashconf.GetInt("thrash", "object_size", 131072)
        numObjects := thrashconf.GetInt("thrash", "num_objects", 5000)
        numGets := int(thrashconf.GetInt("thrash", "gets_per_object", 5))
        allowInsecureAuthCert := thrashconf.GetBool("bench", "allow_insecure_auth_cert", false)
        salt := fmt.Sprintf("%d", rand.Int63())

        var cli client.Client
        var resp *http.Response
        if allowInsecureAuthCert </span><span class="cov0" title="0">{
                cli, resp = client.NewInsecureClient("", authUser, "", authKey, "", authURL, false)
        }</span><span class="cov0" title="0"> else {
                cli, resp = client.NewClient("", authUser, "", authKey, "", authURL, false)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                msg, _ := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                fmt.Println("Error creating client:", msg)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; concurrency; i++ </span><span class="cov0" title="0">{
                if err := cli.PutContainer(fmt.Sprintf("%d-%s", i, salt), nil); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error putting container:", err)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">data := make([]byte, objectSize)
        objects := make([]*Object, numObjects)
        for i := range objects </span><span class="cov0" title="0">{
                objects[i] = &amp;Object{
                        state:     0,
                        container: fmt.Sprintf("%d-%s", i%concurrency, salt),
                        name:      fmt.Sprintf("%x", rand.Int63()),
                        data:      data,
                        c:         cli,
                }
        }</span>

        <span class="cov0" title="0">workch := make(chan func() bool)

        for i := 0; i &lt; concurrency; i++ </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                (&lt;-workch)()
                        }</span>
                }()
        }

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                i := int(rand.Int63() % int64(len(objects)))
                if objects[i].state == 1 </span><span class="cov0" title="0">{
                        workch &lt;- objects[i].Put
                }</span><span class="cov0" title="0"> else if objects[i].state &lt; numGets+2 </span><span class="cov0" title="0">{
                        workch &lt;- objects[i].Get
                }</span><span class="cov0" title="0"> else if objects[i].state &gt;= numGets+2 </span><span class="cov0" title="0">{
                        workch &lt;- objects[i].Delete
                        objects[i] = &amp;Object{
                                container: fmt.Sprintf("%d-%s", i%concurrency, salt),
                                name:      fmt.Sprintf("%x", rand.Int63()),
                                data:      data,
                                c:         cli,
                        }
                        continue</span>
                }
                <span class="cov0" title="0">objects[i].state += 1</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package client

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"

        "github.com/troubling/hummingbird/common/ring"
)

// ResponseStub returns a fake response with the given info.
//
// Note: The Request field of the returned response will be nil; you may want
// to set the Request field if you have a specific request to reference.
func ResponseStub(statusCode int, body string) *http.Response <span class="cov0" title="0">{
        bodyBytes := []byte(body)
        return &amp;http.Response{
                Status:        fmt.Sprintf("%d %s", statusCode, http.StatusText(statusCode)),
                StatusCode:    statusCode,
                Proto:         "HTTP/1.1",
                ProtoMajor:    1,
                ProtoMinor:    1,
                Body:          ioutil.NopCloser(bytes.NewBuffer(bodyBytes)),
                ContentLength: int64(len(bodyBytes)),
                Header:        http.Header{"Content-Length": {fmt.Sprintf("%d", len(bodyBytes))}, "Content-Type": {"text/plain"}},
        }
}</span>

// StubResponse returns a standalone response with the detail from the original
// response; the full body will be read into memory and the original response's
// Body closed. This is used to allow the response to complete and close so the
// transport can be used for another request/response.
//
// Note: Any error reading the original response's body will be ignored.
//
// Note: The Request field of the returned response will be nil; you may want
// to set the Request field if you have a specific request to reference.
func StubResponse(resp *http.Response) *http.Response <span class="cov0" title="0">{
        bodyBytes, _ := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        header := make(http.Header, len(resp.Header))
        for headerName, headerValues := range resp.Header </span><span class="cov0" title="0">{
                copiedHeaderValues := make([]string, len(headerValues))
                for headerValueIndex, headerValue := range headerValues </span><span class="cov0" title="0">{
                        copiedHeaderValues[headerValueIndex] = headerValue
                }</span>
                <span class="cov0" title="0">header[headerName] = copiedHeaderValues</span>
        }
        <span class="cov0" title="0">return &amp;http.Response{
                Status:        resp.Status,
                StatusCode:    resp.StatusCode,
                Proto:         resp.Proto,
                ProtoMajor:    resp.ProtoMajor,
                ProtoMinor:    resp.ProtoMinor,
                Body:          ioutil.NopCloser(bytes.NewBuffer(bodyBytes)),
                ContentLength: int64(len(bodyBytes)),
                Header:        header,
        }</span>
}

// ContainerRecord is an entry in an account listing.
type ContainerRecord struct {
        Count int64  `json:"count"`
        Bytes int64  `json:"bytes"`
        Name  string `json:"name"`
}

// ObjectRecord is an entry in a container listing.
type ObjectRecord struct {
        Hash         string `json:"hash"`
        LastModified string `json:"last_modified"`
        Bytes        int    `json:"bytes"`
        Name         string `json:"name"`
        ContentType  string `json:"content_type"`
}

// Client is an API interface to CloudFiles.
type Client interface {
        PutAccount(headers map[string]string) *http.Response
        PostAccount(headers map[string]string) *http.Response
        // GetAccount reads the body of the response and converts it into a
        // []ContainerRecord while also returning the response instance itself.
        GetAccount(marker string, endMarker string, limit int, prefix string, delimiter string, reverse string, headers map[string]string) ([]ContainerRecord, *http.Response)
        HeadAccount(headers map[string]string) *http.Response
        DeleteAccount(headers map[string]string) *http.Response
        PutContainer(container string, headers map[string]string) *http.Response
        PostContainer(container string, headers map[string]string) *http.Response
        // GetContainer reads the body of the response and converts it into an
        // []ObjectRecord while also returning the response instance itself.
        GetContainer(container string, marker string, endMarker string, limit int, prefix string, delimiter string, reverse string, headers map[string]string) ([]ObjectRecord, *http.Response)
        HeadContainer(container string, headers map[string]string) *http.Response
        DeleteContainer(container string, headers map[string]string) *http.Response
        PutObject(container string, obj string, headers map[string]string, src io.Reader) *http.Response
        PostObject(container string, obj string, headers map[string]string) *http.Response
        GetObject(container string, obj string, headers map[string]string) *http.Response
        HeadObject(container string, obj string, headers map[string]string) *http.Response
        DeleteObject(container string, obj string, headers map[string]string) *http.Response
}

// ProxyClient is similar to Client except it also accepts an account parameter to its operations.  This is meant to be used by the proxy server.
type ProxyClient interface {
        PutAccount(account string, headers http.Header) *http.Response
        PostAccount(account string, headers http.Header) *http.Response
        GetAccount(account string, options map[string]string, headers http.Header) *http.Response
        HeadAccount(account string, headers http.Header) *http.Response
        DeleteAccount(account string, headers http.Header) *http.Response
        PutContainer(account string, container string, headers http.Header) *http.Response
        PostContainer(account string, container string, headers http.Header) *http.Response
        GetContainer(account string, container string, options map[string]string, headers http.Header) *http.Response
        GetContainerInfo(account string, container string) (*ContainerInfo, error)
        HeadContainer(account string, container string, headers http.Header) *http.Response
        DeleteContainer(account string, container string, headers http.Header) *http.Response
        PutObject(account string, container string, obj string, headers http.Header, src io.Reader) *http.Response
        PostObject(account string, container string, obj string, headers http.Header) *http.Response
        GetObject(account string, container string, obj string, headers http.Header) *http.Response
        HeadObject(account string, container string, obj string, headers http.Header) *http.Response
        DeleteObject(account string, container string, obj string, headers http.Header) *http.Response
        // ObjectRingFor returns the object ring for the given account/container or
        // a response as to why the ring could not be returned.
        ObjectRingFor(account string, container string) (ring.Ring, *http.Response)
}

// ContainerInfo is persisted in memcache via JSON; so this needs to continue to have public fields.
type ContainerInfo struct {
        ReadACL            string
        WriteACL           string
        SyncKey            string
        ObjectCount        int64
        ObjectBytes        int64
        Metadata           map[string]string
        SysMetadata        map[string]string
        StoragePolicyIndex int
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package client

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "net"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
)

const PostQuorumTimeoutMs = 50

func mkquery(options map[string]string) string <span class="cov0" title="0">{
        query := ""
        for k, v := range options </span><span class="cov0" title="0">{
                query += url.QueryEscape(k) + "=" + url.QueryEscape(v) + "&amp;"
        }</span>
        <span class="cov0" title="0">if query != "" </span><span class="cov0" title="0">{
                return "?" + strings.TrimRight(query, "&amp;")
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ProxyDirectClient struct {
        policyList    conf.PolicyList
        client        *http.Client
        AccountRing   ring.Ring
        ContainerRing ring.Ring
}

func NewProxyDirectClient(policyList conf.PolicyList) (*ProxyDirectClient, error) <span class="cov0" title="0">{
        c := &amp;ProxyDirectClient{
                policyList: policyList,
                client: &amp;http.Client{
                        Transport: &amp;http.Transport{
                                DisableCompression: true,
                                Dial: (&amp;net.Dialer{
                                        Timeout:   10 * time.Second,
                                        KeepAlive: 5 * time.Second,
                                }).Dial,
                        },
                        Timeout: 120 * time.Minute,
                },
        }
        hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c.ContainerRing, err = ring.GetRing("container", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c.AccountRing, err = ring.GetRing("account", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}

func (c *ProxyDirectClient) quorumResponse(reqs ...*http.Request) *http.Response <span class="cov0" title="0">{
        // this is based on swift's best_response function.
        responses := make(chan *http.Response)
        cancel := make(chan struct{})
        defer close(cancel)
        for _, req := range reqs </span><span class="cov0" title="0">{
                go func(req *http.Request) </span><span class="cov0" title="0">{
                        var entry *http.Response
                        if resp, err := c.client.Do(req); err != nil </span><span class="cov0" title="0">{
                                entry = ResponseStub(http.StatusInternalServerError, err.Error())
                        }</span><span class="cov0" title="0"> else {
                                entry = StubResponse(resp)
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case responses &lt;- entry:</span><span class="cov0" title="0">
                        case &lt;-cancel:</span><span class="cov0" title="0">
                        }
                }(req)
        }
        <span class="cov0" title="0">quorum := int(math.Ceil(float64(len(reqs)) / 2.0))
        responseClasses := []int{0, 0, 0, 0, 0, 0}
        responseCount := 0
        var chosenResponse *http.Response
        for response := range responses </span><span class="cov0" title="0">{
                responseCount++
                class := response.StatusCode / 100
                if class &lt;= 5 </span><span class="cov0" title="0">{
                        responseClasses[class]++
                        if responseClasses[class] &gt;= quorum </span><span class="cov0" title="0">{
                                chosenResponse = response
                                break</span>
                        }
                }
        }
        // Give any pending requests *some* chance to finish. This will increase
        // the likelihood that a read immediately after a write will get the latest
        // information, as we'll force the caller to wait until all backends have
        // responded, with a timeout limit.
        <span class="cov0" title="0">timeout := time.After(PostQuorumTimeoutMs * time.Millisecond)
waiting:
        for responseCount &lt; len(reqs) </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-responses:<span class="cov0" title="0">
                        responseCount++</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        break waiting</span>
                }
        }
        <span class="cov0" title="0">return chosenResponse</span>
}

func (c *ProxyDirectClient) firstResponse(reqs ...*http.Request) (resp *http.Response) <span class="cov0" title="0">{
        success := make(chan *http.Response)
        returned := make(chan struct{})
        defer close(returned)

        for _, req := range reqs </span><span class="cov0" title="0">{
                go func(r *http.Request) </span><span class="cov0" title="0">{
                        cancel := make(chan struct{})
                        r.Cancel = cancel
                        response, err := c.client.Do(r)
                        if err != nil </span><span class="cov0" title="0">{
                                response = nil
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case success &lt;- response:</span><span class="cov0" title="0">
                        case &lt;-returned:<span class="cov0" title="0">
                                close(cancel)</span>
                        }
                }(req)

                <span class="cov0" title="0">select </span>{
                case resp = &lt;-success:<span class="cov0" title="0">
                        if resp != nil &amp;&amp; (resp.StatusCode/100 == 2 || resp.StatusCode == http.StatusPreconditionFailed || resp.StatusCode == http.StatusNotModified || resp.StatusCode == http.StatusRequestedRangeNotSatisfiable) </span><span class="cov0" title="0">{
                                resp = StubResponse(resp)
                                resp.Header.Set("Accept-Ranges", "bytes")
                                if etag := resp.Header.Get("Etag"); etag != "" </span><span class="cov0" title="0">{
                                        resp.Header.Set("Etag", strings.Trim(etag, "\""))
                                }</span>
                                <span class="cov0" title="0">return resp</span>
                        }
                case &lt;-time.After(time.Second):</span><span class="cov0" title="0">
                }
        }
        <span class="cov0" title="0">return ResponseStub(http.StatusNotFound, "")</span>
}

type proxyClient struct {
        pdc *ProxyDirectClient
        mc  ring.MemcacheRing
        lc  map[string]*ContainerInfo
}

var _ ProxyClient = &amp;proxyClient{}

func NewProxyClient(pdc *ProxyDirectClient, mc ring.MemcacheRing, lc map[string]*ContainerInfo) ProxyClient <span class="cov8" title="1">{
        return &amp;proxyClient{pdc: pdc, mc: mc, lc: lc}
}</span>

func (c *proxyClient) invalidateContainerInfo(account string, container string) <span class="cov0" title="0">{
        key := fmt.Sprintf("container/%s/%s", account, container)
        if c.lc != nil </span><span class="cov0" title="0">{
                delete(c.lc, key)
        }</span>
        <span class="cov0" title="0">if c.mc != nil </span><span class="cov0" title="0">{
                c.mc.Delete(key)
        }</span>
}

func (c *proxyClient) PutAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.PutAccount(account, headers)
}</span>
func (c *proxyClient) PostAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.PostAccount(account, headers)
}</span>
func (c *proxyClient) GetAccount(account string, options map[string]string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.GetAccount(account, options, headers)
}</span>
func (c *proxyClient) HeadAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.HeadAccount(account, headers)
}</span>
func (c *proxyClient) DeleteAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.DeleteAccount(account, headers)
}</span>
func (c *proxyClient) PutContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        defer c.invalidateContainerInfo(account, container)
        return c.pdc.PutContainer(account, container, headers)
}</span>
func (c *proxyClient) PostContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        defer c.invalidateContainerInfo(account, container)
        return c.pdc.PostContainer(account, container, headers)
}</span>
func (c *proxyClient) GetContainer(account string, container string, options map[string]string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.GetContainer(account, container, options, headers)
}</span>
func (c *proxyClient) GetContainerInfo(account string, container string) (*ContainerInfo, error) <span class="cov8" title="1">{
        return c.pdc.GetContainerInfo(account, container, c.mc, c.lc)
}</span>
func (c *proxyClient) HeadContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.HeadContainer(account, container, headers)
}</span>
func (c *proxyClient) DeleteContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        defer c.invalidateContainerInfo(account, container)
        return c.pdc.DeleteContainer(account, container, headers)
}</span>
func (c *proxyClient) PutObject(account string, container string, obj string, headers http.Header, src io.Reader) *http.Response <span class="cov0" title="0">{
        return c.pdc.PutObject(account, container, obj, headers, src, c.mc, c.lc)
}</span>
func (c *proxyClient) PostObject(account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.PostObject(account, container, obj, headers, c.mc, c.lc)
}</span>
func (c *proxyClient) GetObject(account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.GetObject(account, container, obj, headers, c.mc, c.lc)
}</span>
func (c *proxyClient) HeadObject(account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.HeadObject(account, container, obj, headers, c.mc, c.lc)
}</span>
func (c *proxyClient) DeleteObject(account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.pdc.DeleteObject(account, container, obj, headers, c.mc, c.lc)
}</span>
func (c *proxyClient) ObjectRingFor(account string, container string) (ring.Ring, *http.Response) <span class="cov0" title="0">{
        return c.pdc.ObjectRingFor(account, container, c.mc, c.lc)
}</span>

func (c *ProxyDirectClient) PutAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.AccountRing.GetPartition(account, "", "")
        reqs := make([]*http.Request, 0)
        for _, device := range c.AccountRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s", device.Ip, device.Port, device.Device, partition, common.Urlencode(account))
                req, _ := http.NewRequest("PUT", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.quorumResponse(reqs...)</span>
}

func (c *ProxyDirectClient) PostAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.AccountRing.GetPartition(account, "", "")
        reqs := make([]*http.Request, 0)
        for _, device := range c.AccountRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s", device.Ip, device.Port, device.Device, partition, common.Urlencode(account))
                req, _ := http.NewRequest("POST", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.quorumResponse(reqs...)</span>
}

func (c *ProxyDirectClient) GetAccount(account string, options map[string]string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.AccountRing.GetPartition(account, "", "")
        reqs := make([]*http.Request, 0)
        query := mkquery(options)
        for _, device := range c.AccountRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(account), query)
                req, _ := http.NewRequest("GET", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.firstResponse(reqs...)</span>
}

func (c *ProxyDirectClient) HeadAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.AccountRing.GetPartition(account, "", "")
        reqs := make([]*http.Request, 0)
        for _, device := range c.AccountRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(account))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.firstResponse(reqs...)</span>
}

func (c *ProxyDirectClient) DeleteAccount(account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.AccountRing.GetPartition(account, "", "")
        reqs := make([]*http.Request, 0)
        for _, device := range c.AccountRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s", device.Ip, device.Port, device.Device, partition, common.Urlencode(account))
                req, _ := http.NewRequest("DELETE", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.quorumResponse(reqs...)</span>
}

func (c *ProxyDirectClient) PutContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.ContainerRing.GetPartition(account, container, "")
        accountPartition := c.AccountRing.GetPartition(account, "", "")
        accountDevices := c.AccountRing.GetNodes(accountPartition)
        policyIndex := -1
        if c.policyList == nil </span><span class="cov0" title="0">{
                c.policyList = conf.LoadPolicies()
        }</span>
        <span class="cov0" title="0">policyDefault := c.policyList.Default()
        policyName := headers.Get("X-Storage-Policy")
        if policyName != "" </span><span class="cov0" title="0">{
                var policy *conf.Policy
                for _, v := range c.policyList </span><span class="cov0" title="0">{
                        if v.Name == policyName </span><span class="cov0" title="0">{
                                policy = v
                                break</span>
                        }
                }
                <span class="cov0" title="0">if policy == nil </span><span class="cov0" title="0">{
                        return ResponseStub(http.StatusBadRequest, fmt.Sprintf("Invalid X-Storage-Policy %q", policyName))
                }</span>
                <span class="cov0" title="0">if policy.Deprecated </span><span class="cov0" title="0">{
                        return ResponseStub(http.StatusBadRequest, fmt.Sprintf("Storage Policy %q is deprecated", policyName))
                }</span>
                <span class="cov0" title="0">policyIndex = policy.Index</span>
        }
        <span class="cov0" title="0">reqs := make([]*http.Request, 0)
        for i, device := range c.ContainerRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, _ := http.NewRequest("PUT", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Account-Partition", strconv.FormatUint(accountPartition, 10))
                req.Header.Set("X-Account-Host", fmt.Sprintf("%s:%d", accountDevices[i].Ip, accountDevices[i].Port))
                req.Header.Set("X-Account-Device", accountDevices[i].Device)
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policyIndex))
                req.Header.Set("X-Backend-Storage-Policy-Default", strconv.Itoa(policyDefault))
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.quorumResponse(reqs...)</span>
}

func (c *ProxyDirectClient) PostContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.ContainerRing.GetPartition(account, container, "")
        reqs := make([]*http.Request, 0)
        for _, device := range c.ContainerRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, _ := http.NewRequest("POST", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.quorumResponse(reqs...)</span>
}

func (c *ProxyDirectClient) GetContainer(account string, container string, options map[string]string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.ContainerRing.GetPartition(account, container, "")
        reqs := make([]*http.Request, 0)
        query := mkquery(options)
        for _, device := range c.ContainerRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(account), common.Urlencode(container), query)
                req, _ := http.NewRequest("GET", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.firstResponse(reqs...)</span>
}

// NilContainerInfo is useful for testing.
var NilContainerInfo = &amp;ContainerInfo{}

func (c *ProxyDirectClient) GetContainerInfo(account string, container string, mc ring.MemcacheRing, lc map[string]*ContainerInfo) (*ContainerInfo, error) <span class="cov8" title="1">{
        key := fmt.Sprintf("container/%s/%s", account, container)
        var ci *ContainerInfo
        if lc != nil </span><span class="cov8" title="1">{
                ci = lc[key]
        }</span>
        <span class="cov8" title="1">if ci == nil &amp;&amp; mc != nil </span><span class="cov0" title="0">{
                if err := mc.GetStructured(key, &amp;ci); err != nil </span><span class="cov0" title="0">{
                        ci = nil
                }</span>
        }
        <span class="cov8" title="1">if ci == nil </span><span class="cov0" title="0">{
                resp := c.HeadContainer(account, container, nil)
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%d error retrieving info for container %s/%s", resp.StatusCode, account, container)
                }</span>
                <span class="cov0" title="0">ci = &amp;ContainerInfo{
                        Metadata:    make(map[string]string),
                        SysMetadata: make(map[string]string),
                }
                var err error
                if ci.ObjectCount, err = strconv.ParseInt(resp.Header.Get("X-Container-Object-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for container %s/%s : %s", account, container, err)
                }</span>
                <span class="cov0" title="0">if ci.ObjectBytes, err = strconv.ParseInt(resp.Header.Get("X-Container-Bytes-Used"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for container %s/%s : %s", account, container, err)
                }</span>
                <span class="cov0" title="0">if ci.StoragePolicyIndex, err = strconv.Atoi(resp.Header.Get("X-Backend-Storage-Policy-Index")); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for container %s/%s : %s", account, container, err)
                }</span>
                <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                        if strings.HasPrefix(k, "X-Container-Meta-") </span><span class="cov0" title="0">{
                                ci.Metadata[k[17:]] = resp.Header.Get(k)
                        }</span><span class="cov0" title="0"> else if strings.HasPrefix(k, "X-Container-Sysmeta-") </span><span class="cov0" title="0">{
                                ci.SysMetadata[k[20:]] = resp.Header.Get(k)
                        }</span><span class="cov0" title="0"> else if k == "X-Container-Read" </span><span class="cov0" title="0">{
                                ci.ReadACL = resp.Header.Get(k)
                        }</span><span class="cov0" title="0"> else if k == "X-Container-Write" </span><span class="cov0" title="0">{
                                ci.WriteACL = resp.Header.Get(k)
                        }</span><span class="cov0" title="0"> else if k == "X-Container-Sync-Key" </span><span class="cov0" title="0">{
                                ci.SyncKey = resp.Header.Get(k)
                        }</span>
                }
                <span class="cov0" title="0">if mc != nil </span><span class="cov0" title="0">{
                        mc.Set(key, ci, 30)
                }</span>
        }
        <span class="cov8" title="1">if ci == NilContainerInfo </span><span class="cov8" title="1">{
                return nil, errors.New("No container info for testing")
        }</span>
        <span class="cov8" title="1">return ci, nil</span>
}

func (c *ProxyDirectClient) HeadContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.ContainerRing.GetPartition(account, container, "")
        reqs := make([]*http.Request, 0)
        for _, device := range c.ContainerRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.firstResponse(reqs...)</span>
}

func (c *ProxyDirectClient) DeleteContainer(account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.ContainerRing.GetPartition(account, container, "")
        accountPartition := c.AccountRing.GetPartition(account, "", "")
        accountDevices := c.AccountRing.GetNodes(accountPartition)
        reqs := make([]*http.Request, 0)
        for i, device := range c.ContainerRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, _ := http.NewRequest("DELETE", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Account-Partition", strconv.FormatUint(accountPartition, 10))
                req.Header.Set("X-Account-Host", fmt.Sprintf("%s:%d", accountDevices[i].Ip, accountDevices[i].Port))
                req.Header.Set("X-Account-Device", accountDevices[i].Device)
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return c.quorumResponse(reqs...)</span>
}

func (c *ProxyDirectClient) PutObject(account string, container string, obj string, headers http.Header, src io.Reader, mc ring.MemcacheRing, lc map[string]*ContainerInfo) *http.Response <span class="cov0" title="0">{
        return newObjectClient(c, account, container, mc, lc).putObject(obj, headers, src)
}</span>

func (c *ProxyDirectClient) PostObject(account string, container string, obj string, headers http.Header, mc ring.MemcacheRing, lc map[string]*ContainerInfo) *http.Response <span class="cov0" title="0">{
        return newObjectClient(c, account, container, mc, lc).postObject(obj, headers)
}</span>

func (c *ProxyDirectClient) GetObject(account string, container string, obj string, headers http.Header, mc ring.MemcacheRing, lc map[string]*ContainerInfo) *http.Response <span class="cov0" title="0">{
        return newObjectClient(c, account, container, mc, lc).getObject(obj, headers)
}</span>

func (c *ProxyDirectClient) GrepObject(account string, container string, obj string, search string, mc ring.MemcacheRing, lc map[string]*ContainerInfo) *http.Response <span class="cov0" title="0">{
        return newObjectClient(c, account, container, mc, lc).grepObject(obj, search)
}</span>

func (c *ProxyDirectClient) HeadObject(account string, container string, obj string, headers http.Header, mc ring.MemcacheRing, lc map[string]*ContainerInfo) *http.Response <span class="cov0" title="0">{
        return newObjectClient(c, account, container, mc, lc).headObject(obj, headers)
}</span>

func (c *ProxyDirectClient) DeleteObject(account string, container string, obj string, headers http.Header, mc ring.MemcacheRing, lc map[string]*ContainerInfo) *http.Response <span class="cov0" title="0">{
        return newObjectClient(c, account, container, mc, lc).deleteObject(obj, headers)
}</span>

func (c *ProxyDirectClient) ObjectRingFor(account string, container string, mc ring.MemcacheRing, lc map[string]*ContainerInfo) (ring.Ring, *http.Response) <span class="cov0" title="0">{
        return newObjectClient(c, account, container, mc, lc).ring()
}</span>

type proxyObjectClient interface {
        putObject(obj string, headers http.Header, src io.Reader) *http.Response
        postObject(obj string, headers http.Header) *http.Response
        getObject(obj string, headers http.Header) *http.Response
        grepObject(obj string, search string) *http.Response
        headObject(obj string, headers http.Header) *http.Response
        deleteObject(obj string, headers http.Header) *http.Response
        ring() (ring.Ring, *http.Response)
}

type erroringObjectClient struct {
        body string
}

func (oc *erroringObjectClient) putObject(obj string, headers http.Header, src io.Reader) *http.Response <span class="cov0" title="0">{
        return ResponseStub(http.StatusInternalServerError, oc.body)
}</span>
func (oc *erroringObjectClient) postObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return ResponseStub(http.StatusInternalServerError, oc.body)
}</span>
func (oc *erroringObjectClient) getObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return ResponseStub(http.StatusInternalServerError, oc.body)
}</span>
func (oc *erroringObjectClient) grepObject(obj string, search string) *http.Response <span class="cov0" title="0">{
        return ResponseStub(http.StatusInternalServerError, oc.body)
}</span>
func (oc *erroringObjectClient) headObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return ResponseStub(http.StatusInternalServerError, oc.body)
}</span>
func (oc *erroringObjectClient) deleteObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return ResponseStub(http.StatusInternalServerError, oc.body)
}</span>
func (oc *erroringObjectClient) ring() (ring.Ring, *http.Response) <span class="cov0" title="0">{
        return nil, ResponseStub(http.StatusInternalServerError, oc.body)
}</span>

type standardObjectClient struct {
        proxyDirectClient *ProxyDirectClient
        account           string
        container         string
        policy            int
        objectRing        ring.Ring
}

func newObjectClient(proxyDirectClient *ProxyDirectClient, account string, container string, mc ring.MemcacheRing, lc map[string]*ContainerInfo) proxyObjectClient <span class="cov0" title="0">{
        ci, err := proxyDirectClient.GetContainerInfo(account, container, mc, lc)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;erroringObjectClient{body: "Could not retrieve container information."}
        }</span>
        <span class="cov0" title="0">hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;erroringObjectClient{body: "Could not retrieve hash path prefix and suffix."}
        }</span>
        <span class="cov0" title="0">objectRing, err := ring.GetRing("object", hashPathPrefix, hashPathSuffix, ci.StoragePolicyIndex)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;erroringObjectClient{body: fmt.Sprintf("Could not load object ring for policy %d.", ci.StoragePolicyIndex)}
        }</span>
        <span class="cov0" title="0">return &amp;standardObjectClient{proxyDirectClient: proxyDirectClient, account: account, container: container, policy: ci.StoragePolicyIndex, objectRing: objectRing}</span>
}

func (oc *standardObjectClient) putObject(obj string, headers http.Header, src io.Reader) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(oc.account, oc.container, obj)
        containerPartition := oc.proxyDirectClient.ContainerRing.GetPartition(oc.account, oc.container, "")
        containerDevices := oc.proxyDirectClient.ContainerRing.GetNodes(containerPartition)
        var writers []*io.PipeWriter
        reqs := make([]*http.Request, 0)
        for i, device := range oc.objectRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(oc.account), common.Urlencode(oc.container), common.Urlencode(obj))
                rp, wp := io.Pipe()
                defer wp.Close()
                defer rp.Close()
                req, err := http.NewRequest("PUT", url, rp)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">writers = append(writers, wp)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                // req.ContentLength = request.ContentLength // TODO
                <span class="cov0" title="0">if req.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                        req.Header.Set("Content-Type", "application/octet-stream")
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Container-Partition", strconv.FormatUint(containerPartition, 10))
                req.Header.Set("X-Container-Host", fmt.Sprintf("%s:%d", containerDevices[i].Ip, containerDevices[i].Port))
                req.Header.Set("X-Container-Device", containerDevices[i].Device)
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                req.Header.Set("Expect", "100-Continue")
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // TODO: Need to change up this code because MultiWriter will stop everything on any error.
                ws := make([]io.Writer, len(writers))
                for i, w := range writers </span><span class="cov0" title="0">{
                        ws[i] = w
                }</span>
                <span class="cov0" title="0">mw := io.MultiWriter(ws...)
                io.Copy(mw, src)
                for _, writer := range writers </span><span class="cov0" title="0">{
                        writer.Close()
                }</span>
        }()
        <span class="cov0" title="0">return oc.proxyDirectClient.quorumResponse(reqs...)</span>
}

func (oc *standardObjectClient) postObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(oc.account, oc.container, obj)
        containerPartition := oc.proxyDirectClient.ContainerRing.GetPartition(oc.account, oc.container, "")
        containerDevices := oc.proxyDirectClient.ContainerRing.GetNodes(containerPartition)
        reqs := make([]*http.Request, 0)
        for i, device := range oc.objectRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(oc.account), common.Urlencode(oc.container), common.Urlencode(obj))
                req, _ := http.NewRequest("POST", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Container-Partition", strconv.FormatUint(containerPartition, 10))
                req.Header.Set("X-Container-Host", fmt.Sprintf("%s:%d", containerDevices[i].Ip, containerDevices[i].Port))
                req.Header.Set("X-Container-Device", containerDevices[i].Device)
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return oc.proxyDirectClient.quorumResponse(reqs...)</span>
}

func (oc *standardObjectClient) getObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(oc.account, oc.container, obj)
        nodes := oc.objectRing.GetNodes(partition)
        reqs := make([]*http.Request, 0, len(nodes))
        for _, device := range nodes </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(oc.account), common.Urlencode(oc.container), common.Urlencode(obj))
                req, err := http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return oc.proxyDirectClient.firstResponse(reqs...)</span>
}

func (oc *standardObjectClient) grepObject(obj string, search string) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(oc.account, oc.container, obj)
        nodes := oc.objectRing.GetNodes(partition)
        reqs := make([]*http.Request, 0, len(nodes))
        for _, device := range nodes </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s/%s?e=%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(oc.account), common.Urlencode(oc.container), common.Urlencode(obj), common.Urlencode(search))
                req, err := http.NewRequest("GREP", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return oc.proxyDirectClient.firstResponse(reqs...)</span>
}

func (oc *standardObjectClient) headObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(oc.account, oc.container, obj)
        nodes := oc.objectRing.GetNodes(partition)
        reqs := make([]*http.Request, 0, len(nodes))
        for _, device := range nodes </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(oc.account), common.Urlencode(oc.container), common.Urlencode(obj))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return oc.proxyDirectClient.firstResponse(reqs...)</span>
}

func (oc *standardObjectClient) deleteObject(obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(oc.account, oc.container, obj)
        containerPartition := oc.proxyDirectClient.ContainerRing.GetPartition(oc.account, oc.container, "")
        containerDevices := oc.proxyDirectClient.ContainerRing.GetNodes(containerPartition)
        reqs := make([]*http.Request, 0)
        for i, device := range oc.objectRing.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("http://%s:%d/%s/%d/%s/%s/%s", device.Ip, device.Port, device.Device, partition,
                        common.Urlencode(oc.account), common.Urlencode(oc.container), common.Urlencode(obj))
                req, _ := http.NewRequest("DELETE", url, nil)
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">if req.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                        req.Header.Set("Content-Type", "application/octet-stream")
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Container-Partition", strconv.FormatUint(containerPartition, 10))
                req.Header.Set("X-Container-Host", fmt.Sprintf("%s:%d", containerDevices[i].Ip, containerDevices[i].Port))
                req.Header.Set("X-Container-Device", containerDevices[i].Device)
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                reqs = append(reqs, req)</span>
        }
        <span class="cov0" title="0">return oc.proxyDirectClient.quorumResponse(reqs...)</span>
}

func (oc *standardObjectClient) ring() (ring.Ring, *http.Response) <span class="cov0" title="0">{
        return oc.objectRing, nil
}</span>

type directClient struct {
        pc      ProxyClient
        account string
}

var _ Client = &amp;directClient{}

func (c *directClient) PutAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PutAccount(c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) PostAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PostAccount(c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) GetAccount(marker string, endMarker string, limit int, prefix string, delimiter string, reverse string, headers map[string]string) ([]ContainerRecord, *http.Response) <span class="cov0" title="0">{
        options := map[string]string{
                "format":     "json",
                "marker":     marker,
                "end_marker": endMarker,
                "prefix":     prefix,
                "delimiter":  delimiter,
                "reverse":    reverse,
        }
        if limit != 0 </span><span class="cov0" title="0">{
                options["limit"] = strconv.Itoa(limit)
        }</span>
        <span class="cov0" title="0">resp := c.pc.GetAccount(c.account, options, common.Map2Headers(headers))
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, resp
        }</span>
        <span class="cov0" title="0">var accountListing []ContainerRecord
        if err := json.NewDecoder(resp.Body).Decode(&amp;accountListing); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        return accountListing, resp</span>
}

func (c *directClient) HeadAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.HeadAccount(c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) DeleteAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.DeleteAccount(c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) PutContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PutContainer(c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) PostContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PostContainer(c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) GetContainer(container string, marker string, endMarker string, limit int, prefix string, delimiter string, reverse string, headers map[string]string) ([]ObjectRecord, *http.Response) <span class="cov0" title="0">{
        options := map[string]string{
                "format":     "json",
                "marker":     marker,
                "end_marker": endMarker,
                "prefix":     prefix,
                "delimiter":  delimiter,
                "reverse":    reverse,
        }
        if limit != 0 </span><span class="cov0" title="0">{
                options["limit"] = strconv.Itoa(limit)
        }</span>
        <span class="cov0" title="0">resp := c.pc.GetContainer(c.account, container, options, common.Map2Headers(headers))
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, resp
        }</span>
        <span class="cov0" title="0">var containerListing []ObjectRecord
        if err := json.NewDecoder(resp.Body).Decode(&amp;containerListing); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        return containerListing, resp</span>
}

func (c *directClient) HeadContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.HeadContainer(c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) DeleteContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.DeleteContainer(c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) PutObject(container string, obj string, headers map[string]string, src io.Reader) *http.Response <span class="cov0" title="0">{
        return c.pc.PutObject(c.account, container, obj, common.Map2Headers(headers), src)
}</span>

func (c *directClient) PostObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PostObject(c.account, container, obj, common.Map2Headers(headers))
}</span>

func (c *directClient) GetObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.GetObject(c.account, container, obj, common.Map2Headers(headers))
}</span>

func (c *directClient) HeadObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.HeadObject(c.account, container, obj, common.Map2Headers(headers))
}</span>

func (c *directClient) DeleteObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.DeleteObject(c.account, container, obj, common.Map2Headers(headers))
}</span>

// NewDirectClient creates a new direct client with the given account name.
func NewDirectClient(account string) (Client, error) <span class="cov0" title="0">{
        pdc, err := NewProxyDirectClient(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;directClient{account: account, pc: NewProxyClient(pdc, nil, nil)}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package client

import (
        "bytes"
        "crypto/tls"
        "encoding/json"
        "io"
        "net/http"
        "strconv"
        "strings"
        "time"
)

// userClient is a Client to be used by end-users.  It knows how to authenticate with auth v1 and v2.
type userClient struct {
        client                                              *http.Client
        ServiceURL                                          string
        AuthToken                                           string
        tenant, username, password, apikey, region, authurl string
        private                                             bool
}

var _ Client = &amp;userClient{}

func (c *userClient) authedRequest(method string, path string, body io.Reader, headers map[string]string) (*http.Request, error) <span class="cov0" title="0">{
        req, err := http.NewRequest(method, c.ServiceURL+path, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Auth-Token", c.AuthToken)
        req.Header.Set("User-Agent", "Hummingbird Client")
        for k, v := range headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>
        <span class="cov0" title="0">return req, nil</span>
}

func (c *userClient) do(req *http.Request) *http.Response <span class="cov0" title="0">{
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                resp.Body.Close()
                if aResp := c.authenticate(); aResp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        return aResp
                }</span>
                <span class="cov0" title="0">resp, err = c.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return ResponseStub(http.StatusBadRequest, err.Error())
                }</span>
        }
        <span class="cov0" title="0">return resp</span>
}

func (c *userClient) doRequest(method string, path string, body io.Reader, headers map[string]string) *http.Response <span class="cov0" title="0">{
        req, err := c.authedRequest(method, path, body, headers)
        if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">return c.do(req)</span>
}

func (c *userClient) PutAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("PUT", "", nil, headers)
}</span>

func (c *userClient) PostAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("POST", "", nil, headers)
}</span>

func (c *userClient) GetAccount(marker string, endMarker string, limit int, prefix string, delimiter string, reverse string, headers map[string]string) ([]ContainerRecord, *http.Response) <span class="cov0" title="0">{
        limitStr := ""
        if limit &gt; 0 </span><span class="cov0" title="0">{
                limitStr = strconv.Itoa(limit)
        }</span>
        <span class="cov0" title="0">path := mkquery(map[string]string{"marker": marker, "end_marker": endMarker, "prefix": prefix, "delimiter": delimiter, "limit": limitStr, "reverse": reverse})
        req, err := c.authedRequest("GET", path, nil, headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")
        resp := c.do(req)
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, resp
        }</span>
        <span class="cov0" title="0">var accountListing []ContainerRecord
        if err := json.NewDecoder(resp.Body).Decode(&amp;accountListing); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        return accountListing, resp</span>
}

func (c *userClient) HeadAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("HEAD", "", nil, headers)
}</span>

func (c *userClient) DeleteAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("DELETE", "", nil, nil)
}</span>

func (c *userClient) PutContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("PUT", "/"+container, nil, headers)
}</span>

func (c *userClient) PostContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("POST", "/"+container, nil, headers)
}</span>

func (c *userClient) GetContainer(container string, marker string, endMarker string, limit int, prefix string, delimiter string, reverse string, headers map[string]string) ([]ObjectRecord, *http.Response) <span class="cov0" title="0">{
        limitStr := ""
        if limit &gt; 0 </span><span class="cov0" title="0">{
                limitStr = strconv.Itoa(limit)
        }</span>
        <span class="cov0" title="0">path := "/" + container + mkquery(map[string]string{"marker": marker, "end_marker": endMarker, "prefix": prefix, "delimiter": delimiter, "limit": limitStr, "reverse": reverse})
        req, err := c.authedRequest("GET", path, nil, headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")
        resp := c.do(req)
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, resp
        }</span>
        <span class="cov0" title="0">var containerListing []ObjectRecord
        if err := json.NewDecoder(resp.Body).Decode(&amp;containerListing); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        return containerListing, resp</span>
}

func (c *userClient) HeadContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("HEAD", "/"+container, nil, headers)
}</span>

func (c *userClient) DeleteContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("DELETE", "/"+container, nil, headers)
}</span>

func (c *userClient) PutObject(container string, obj string, headers map[string]string, src io.Reader) *http.Response <span class="cov0" title="0">{
        return c.doRequest("PUT", "/"+container+"/"+obj, src, headers)
}</span>

func (c *userClient) PostObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("POST", "/"+container+"/"+obj, nil, headers)
}</span>

func (c *userClient) GetObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("GET", "/"+container+"/"+obj, nil, headers)
}</span>

func (c *userClient) HeadObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("HEAD", "/"+container+"/"+obj, nil, headers)
}</span>

func (c *userClient) DeleteObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.doRequest("DELETE", "/"+container+"/"+obj, nil, headers)
}</span>

func (c *userClient) authenticatev1() *http.Response <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", c.authurl, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Auth-User", c.username)
        req.Header.Set("X-Auth-Key", c.apikey)
        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return resp
        }</span>
        <span class="cov0" title="0">c.ServiceURL = resp.Header.Get("X-Storage-Url")
        c.AuthToken = resp.Header.Get("X-Auth-Token")
        if c.ServiceURL == "" || c.AuthToken != "" </span><span class="cov0" title="0">{
                resp.Body.Close()
                return ResponseStub(http.StatusInternalServerError, "Response did not have X-Storage-Url or X-Auth-Token headers.")
        }</span>
        <span class="cov0" title="0">return resp</span>
}

type KeystoneRequestV2 struct {
        Auth interface{} `json:"auth"`
}

type KeystonePasswordAuthV2 struct {
        TenantName          string `json:"tenantName"`
        PasswordCredentials struct {
                Username string `json:"username"`
                Password string `json:"password"`
        } `json:"passwordCredentials"`
}

type RaxAPIKeyAuthV2 struct {
        APIKeyCredentials struct {
                Username string `json:"username"`
                APIKey   string `json:"apiKey"`
        } `json:"RAX-KSKEY:apiKeyCredentials"`
}

type KeystoneResponseV2 struct {
        Access struct {
                Token struct {
                        ID     string `json:"id"`
                        Tenant struct {
                                Name string `json:"name"`
                                ID   string `json:"id"`
                        } `json:"tenant"`
                } `json:"token"`
                ServiceCatalog []struct {
                        Endpoints []struct {
                                PublicURL   string `json:"publicURL"`
                                InternalURL string `json:"internalURL"`
                                Region      string `json:"region"`
                        } `json:"endpoints"`
                        Type string `json:"type"`
                } `json:"serviceCatalog"`
                User struct {
                        RaxDefaultRegion string `json:"RAX-AUTH:defaultRegion"`
                } `json:"user"`
        } `json:"access"`
}

func (c *userClient) authenticatev2() *http.Response <span class="cov0" title="0">{
        if !strings.HasSuffix(c.authurl, "tokens") </span><span class="cov0" title="0">{
                if c.authurl[len(c.authurl)-1] == '/' </span><span class="cov0" title="0">{
                        c.authurl = c.authurl + "tokens"
                }</span><span class="cov0" title="0"> else {
                        c.authurl = c.authurl + "/tokens"
                }</span>
        }
        <span class="cov0" title="0">var authReq []byte
        var err error
        if c.password != "" </span><span class="cov0" title="0">{
                creds := &amp;KeystonePasswordAuthV2{TenantName: c.tenant}
                creds.PasswordCredentials.Username = c.username
                creds.PasswordCredentials.Password = c.password
                authReq, err = json.Marshal(&amp;KeystoneRequestV2{Auth: creds})
        }</span><span class="cov0" title="0"> else if c.apikey != "" </span><span class="cov0" title="0">{
                creds := &amp;RaxAPIKeyAuthV2{}
                creds.APIKeyCredentials.Username = c.username
                creds.APIKeyCredentials.APIKey = c.apikey
                authReq, err = json.Marshal(&amp;KeystoneRequestV2{Auth: creds})
        }</span><span class="cov0" title="0"> else {
                return ResponseStub(http.StatusInternalServerError, "Couldn't figure out what credentials to use.")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp, err := c.client.Post(c.authurl, "application/json", bytes.NewBuffer(authReq))
        if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return resp
        }</span>
        <span class="cov0" title="0">var authResponse KeystoneResponseV2
        if err := json.NewDecoder(resp.Body).Decode(&amp;authResponse); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                return ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        c.AuthToken = authResponse.Access.Token.ID
        region := c.region
        if region == "" </span><span class="cov0" title="0">{
                region = authResponse.Access.User.RaxDefaultRegion
        }</span>
        <span class="cov0" title="0">for _, s := range authResponse.Access.ServiceCatalog </span><span class="cov0" title="0">{
                if s.Type == "object-store" </span><span class="cov0" title="0">{
                        for _, e := range s.Endpoints </span><span class="cov0" title="0">{
                                if e.Region == region || region == "" || len(s.Endpoints) == 1 </span><span class="cov0" title="0">{
                                        if c.private </span><span class="cov0" title="0">{
                                                c.ServiceURL = e.InternalURL
                                        }</span><span class="cov0" title="0"> else {
                                                c.ServiceURL = e.PublicURL
                                        }</span>
                                        <span class="cov0" title="0">return ResponseStub(http.StatusOK, "")</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return ResponseStub(http.StatusInternalServerError, "Didn't find endpoint")</span>
}

type keystoneRequestV3 struct {
        Auth struct {
                Identity struct {
                        Methods  []string `json:"methods"`
                        Password struct {
                                User struct {
                                        Name   string `json:"name"`
                                        Domain struct {
                                                Name string `json:"name"`
                                        } `json:"domain"`
                                        Password string `json:"password"`
                                } `json:"user"`
                        } `json:"password"`
                } `json:"identity"`
        } `json:"auth"`
}

type keystoneResponseV3 struct {
        Token struct {
                Catalog []struct {
                        Type      string `json:"type"`
                        Endpoints []struct {
                                Region    string `json:"region"`
                                URL       string `json:"url"`
                                Interface string `json:"interface"`
                        } `json:"endpoints"`
                } `json:"catalog"`
        } `json:"token"`
}

func (c *userClient) authenticatev3() *http.Response <span class="cov0" title="0">{
        if !strings.HasSuffix(c.authurl, "auth/tokens") </span><span class="cov0" title="0">{
                if c.authurl[len(c.authurl)-1] == '/' </span><span class="cov0" title="0">{
                        c.authurl = c.authurl + "auth/tokens"
                }</span><span class="cov0" title="0"> else {
                        c.authurl = c.authurl + "/auth/tokens"
                }</span>
        }
        <span class="cov0" title="0">var authReq []byte
        var err error
        if c.password != "" </span><span class="cov0" title="0">{
                creds := &amp;keystoneRequestV3{}
                creds.Auth.Identity.Methods = []string{"password"}
                creds.Auth.Identity.Password.User.Domain.Name = "Default"
                creds.Auth.Identity.Password.User.Name = c.username
                creds.Auth.Identity.Password.User.Password = c.password
                authReq, err = json.Marshal(creds)
        }</span><span class="cov0" title="0"> else if c.apikey != "" </span><span class="cov0" title="0">{
                panic("v3 by api key not implemented yet")</span>
        }<span class="cov0" title="0"> else {
                return ResponseStub(http.StatusInternalServerError, "Couldn't figure out what credentials to use.")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp, err := c.client.Post(c.authurl, "application/json", bytes.NewBuffer(authReq))
        if err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return resp
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        c.AuthToken = resp.Header.Get("X-Subject-Token")
        if c.AuthToken == "" </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusInternalServerError, "No X-Subject-Token in response.")
        }</span>
        <span class="cov0" title="0">var authResponse keystoneResponseV3
        if err := json.NewDecoder(resp.Body).Decode(&amp;authResponse); err != nil </span><span class="cov0" title="0">{
                return ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">intrfc := "public"
        if c.private </span><span class="cov0" title="0">{
                intrfc = "private"
        }</span>
        <span class="cov0" title="0">for _, s := range authResponse.Token.Catalog </span><span class="cov0" title="0">{
                if s.Type == "object-store" </span><span class="cov0" title="0">{
                        for _, e := range s.Endpoints </span><span class="cov0" title="0">{
                                if ((e.Region == c.region || c.region == "") &amp;&amp; e.Interface == intrfc) || len(s.Endpoints) == 1 </span><span class="cov0" title="0">{
                                        c.ServiceURL = e.URL
                                        return ResponseStub(http.StatusOK, "")
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ResponseStub(http.StatusInternalServerError, "Didn't find endpoint")</span>
}

func (c *userClient) authenticate() *http.Response <span class="cov0" title="0">{
        if strings.Contains(c.authurl, "/v3") </span><span class="cov0" title="0">{
                return c.authenticatev3()
        }</span><span class="cov0" title="0"> else if strings.Contains(c.authurl, "/v2") </span><span class="cov0" title="0">{
                return c.authenticatev2()
        }</span><span class="cov0" title="0"> else {
                return c.authenticatev1()
        }</span>
}

// NewClient creates a new end-user client. It authenticates immediately, and
// returns the error response if unable to.
func NewClient(tenant string, username string, password string, apikey string, region string, authurl string, private bool) (Client, *http.Response) <span class="cov0" title="0">{
        c := &amp;userClient{
                client:   &amp;http.Client{Timeout: 30 * time.Minute},
                tenant:   tenant,
                username: username,
                password: password,
                apikey:   apikey,
                region:   region,
                authurl:  authurl,
                private:  private,
        }
        if aResp := c.authenticate(); aResp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, aResp
        }</span><span class="cov0" title="0"> else {
                aResp.Body.Close()
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}

// NewInsecureClient creates a new end-user client with SSL verification turned
// off. It authenticates immediately, and returns the error response if unable
// to.
func NewInsecureClient(tenant string, username string, password string, apikey string, region string, authurl string, private bool) (Client, *http.Response) <span class="cov0" title="0">{
        c := &amp;userClient{
                client: &amp;http.Client{
                        Timeout: 30 * time.Minute,
                        Transport: &amp;http.Transport{
                                TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
                        },
                },
                tenant:   tenant,
                username: username,
                password: password,
                apikey:   apikey,
                region:   region,
                authurl:  authurl,
                private:  private,
        }
        if aResp := c.authenticate(); aResp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, aResp
        }</span><span class="cov0" title="0"> else {
                aResp.Body.Close()
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package main

import (
        "errors"
        "flag"
        "fmt"
        "math/rand"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "syscall"
        "time"

        "github.com/troubling/hummingbird/accountserver"
        "github.com/troubling/hummingbird/bench"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/containerserver"
        "github.com/troubling/hummingbird/objectserver"
        "github.com/troubling/hummingbird/proxyserver"
)

const (
        runPath = "/var/run/hummingbird"
        logPath = "/var/log/hummingbird"
)

func getProcess(name string) (*os.Process, error) <span class="cov0" title="0">{
        var pid int
        file, err := os.Open(filepath.Join(runPath, fmt.Sprintf("%s.pid", name)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, err = fmt.Fscanf(file, "%d", &amp;pid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = process.Signal(syscall.Signal(0))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return process, nil</span>
}

func findConfig(name string) string <span class="cov0" title="0">{
        configName := strings.Split(name, "-")[0]
        configSearch := []string{
                fmt.Sprintf("/etc/hummingbird/%s-server.conf", configName),
                fmt.Sprintf("/etc/hummingbird/%s-server.conf.d", configName),
                fmt.Sprintf("/etc/hummingbird/%s-server", configName),
                fmt.Sprintf("/etc/swift/%s-server.conf", configName),
                fmt.Sprintf("/etc/swift/%s-server.conf.d", configName),
                fmt.Sprintf("/etc/swift/%s-server", configName),
        }
        for _, config := range configSearch </span><span class="cov0" title="0">{
                if fs.Exists(config) </span><span class="cov0" title="0">{
                        return config
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func startServer(name string, args ...string) error <span class="cov0" title="0">{
        process, err := getProcess(name)
        if err == nil </span><span class="cov0" title="0">{
                process.Release()
                return errors.New("Found already running " + name + " server")
        }</span>

        <span class="cov0" title="0">serverConf := findConfig(name)
        if serverConf == "" </span><span class="cov0" title="0">{
                return errors.New("Unable to find config file.")
        }</span>

        <span class="cov0" title="0">serverExecutable, err := exec.LookPath(os.Args[0])
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Unable to find hummingbird executable in path.")
        }</span>

        <span class="cov0" title="0">uid, gid, err := conf.UidFromConf(serverConf)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Unable to find uid to execute process:" + err.Error())
        }</span>

        <span class="cov0" title="0">logfile := filepath.Join(logPath, name+".log")
        errfile := filepath.Join(logPath, name+".err")
        cmd := exec.Command(serverExecutable, append([]string{name, "-c", serverConf, "-l", logfile, "-e", errfile}, args...)...)
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{Setsid: true}
        if uint32(os.Getuid()) != uid </span><span class="cov0" title="0">{ // This is goofy.
                cmd.SysProcAttr.Credential = &amp;syscall.Credential{Uid: uid, Gid: gid}
        }</span>
        <span class="cov0" title="0">cmd.Stdin = nil

        syscall.Umask(022)
        err = cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Error starting server:" + err.Error())
        }</span>
        <span class="cov0" title="0">file, err := os.Create(filepath.Join(runPath, fmt.Sprintf("%s.pid", name)))
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Error creating pidfile:" + err.Error())
        }</span>
        <span class="cov0" title="0">defer file.Close()
        fmt.Fprintf(file, "%d", cmd.Process.Pid)
        fmt.Println(strings.Title(name), "server started.")
        return nil</span>
}

func stopServer(name string, args ...string) error <span class="cov0" title="0">{
        process, err := getProcess(name)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(strings.Title(name) + " server not found.")
        }</span>
        <span class="cov0" title="0">process.Signal(os.Kill)
        process.Wait()
        os.Remove(filepath.Join(runPath, fmt.Sprintf("%s.pid", name)))
        fmt.Println(strings.Title(name), "server stopped.")
        return nil</span>
}

func restartServer(name string, args ...string) error <span class="cov0" title="0">{
        process, err := getProcess(name)
        if err == nil </span><span class="cov0" title="0">{
                process.Signal(os.Kill)
                process.Wait()
                fmt.Println(strings.Title(name), "server stopped.")
        }</span><span class="cov0" title="0"> else {
                fmt.Println(strings.Title(name), "server not found.")
        }</span>
        <span class="cov0" title="0">os.Remove(filepath.Join(runPath, fmt.Sprintf("%s.pid", name)))
        return startServer(name, args...)</span>
}

func gracefulRestartServer(name string, args ...string) error <span class="cov0" title="0">{
        process, err := getProcess(name)
        if err == nil </span><span class="cov0" title="0">{
                process.Signal(syscall.SIGTERM)
                time.Sleep(time.Second)
                fmt.Println(strings.Title(name), "server graceful shutdown began.")
        }</span><span class="cov0" title="0"> else {
                fmt.Println(strings.Title(name), "server not found.")
        }</span>
        <span class="cov0" title="0">process.Release()
        os.Remove(filepath.Join(runPath, fmt.Sprintf("%s.pid", name)))
        return startServer(name, args...)</span>
}

func gracefulShutdownServer(name string, args ...string) error <span class="cov0" title="0">{
        process, err := getProcess(name)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(strings.Title(name) + " server not found.")
        }</span>
        <span class="cov0" title="0">process.Signal(syscall.SIGTERM)
        process.Release()
        os.Remove(filepath.Join(runPath, fmt.Sprintf("%s.pid", name)))
        fmt.Println(strings.Title(name), "server graceful shutdown began.")
        return nil</span>
}

func processControlCommand(serverCommand func(name string, args ...string) error) <span class="cov0" title="0">{
        for _, reqDir := range []string{runPath, logPath} </span><span class="cov0" title="0">{
                if !fs.Exists(reqDir) </span><span class="cov0" title="0">{
                        err := os.MkdirAll(reqDir, 0600)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, reqDir, "does not exist, and unable to create it.")
                                fmt.Fprintln(os.Stderr, "You should create it, writable by the user you wish to launch servers with.")
                                os.Exit(1)
                        }</span>
                }
        }

        <span class="cov0" title="0">if flag.NArg() &lt; 2 </span><span class="cov0" title="0">{
                flag.Usage()
                return
        }</span>

        <span class="cov0" title="0">switch flag.Arg(1) </span>{
        case "proxy", "object", "object-replicator", "object-auditor", "container", "container-replicator", "account", "account-replicator":<span class="cov0" title="0">
                if err := serverCommand(flag.Arg(1), flag.Args()[2:]...); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }</span>
        case "main":<span class="cov0" title="0">
                exc := 0
                for _, server := range []string{"proxy", "object", "container", "account"} </span><span class="cov0" title="0">{
                        if err := serverCommand(server); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, server, ":", err)
                                exc = 1
                        }</span>
                }
                <span class="cov0" title="0">os.Exit(exc)</span>
        case "all":<span class="cov0" title="0">
                exc := 0
                for _, server := range []string{"proxy", "object", "object-replicator", "object-auditor",
                        "container", "container-replicator", "account", "account-replicator"} </span><span class="cov0" title="0">{
                        if err := serverCommand(server); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, server, ":", err)
                                exc = 1
                        }</span>
                }
                <span class="cov0" title="0">os.Exit(exc)</span>
        default:<span class="cov0" title="0">
                flag.Usage()</span>
        }
}

func init() <span class="cov8" title="1">{
        rand.Seed(time.Now().UTC().UnixNano())
}</span>

func main() <span class="cov0" title="0">{
        proxyFlags := flag.NewFlagSet("proxy server", flag.ExitOnError)
        proxyFlags.String("c", findConfig("proxy"), "Config file/directory to use")
        proxyFlags.String("l", "stdout", "Log location")
        proxyFlags.String("e", "stderr", "Error log location")
        proxyFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird proxy [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run proxy server")
                proxyFlags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">objectFlags := flag.NewFlagSet("object server", flag.ExitOnError)
        objectFlags.String("c", findConfig("object"), "Config file/directory to use")
        objectFlags.String("l", "stdout", "Log location")
        objectFlags.String("e", "stderr", "Error log location")
        objectFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird object [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run object server")
                objectFlags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">objectReplicatorFlags := flag.NewFlagSet("object replicator", flag.ExitOnError)
        objectReplicatorFlags.Bool("q", false, "Quorum Delete. Will delete handoff node if pushed to #replicas/2 + 1 nodes.")
        objectReplicatorFlags.String("c", findConfig("object"), "Config file/directory to use")
        objectReplicatorFlags.String("l", "stdout", "Log location")
        objectReplicatorFlags.String("e", "stderr", "Error log location")
        objectReplicatorFlags.Bool("once", false, "Run one pass of the replicator")
        objectReplicatorFlags.String("devices", "", "Replicate only given devices. Comma-separated list.")
        objectReplicatorFlags.String("partitions", "", "Replicate only given partitions. Comma-separated list.")
        objectReplicatorFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird object-replicator [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run object replicator")
                objectReplicatorFlags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">objectAuditorFlags := flag.NewFlagSet("object auditor", flag.ExitOnError)
        objectAuditorFlags.String("c", findConfig("object"), "Config file/directory to use")
        objectAuditorFlags.String("l", "stdout", "Log location")
        objectAuditorFlags.String("e", "stderr", "Error log location")
        objectAuditorFlags.Bool("once", false, "Run one pass of the auditor")
        objectAuditorFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird object-auditor [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run object auditor")
                objectAuditorFlags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">containerFlags := flag.NewFlagSet("container server", flag.ExitOnError)
        containerFlags.String("c", findConfig("container"), "Config file/directory to use")
        containerFlags.String("l", "stdout", "Log location")
        containerFlags.String("e", "stderr", "Error log location")
        containerFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird container [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run container server")
                containerFlags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">containerReplicatorFlags := flag.NewFlagSet("container replicator", flag.ExitOnError)
        containerReplicatorFlags.String("c", findConfig("container"), "Config file/directory to use")
        containerReplicatorFlags.String("l", "stdout", "Log location")
        containerReplicatorFlags.String("e", "stderr", "Error log location")
        containerReplicatorFlags.Bool("once", false, "Run one pass of the replicator")
        containerReplicatorFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird container-replicator [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run container replicator")
                containerReplicatorFlags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">accountFlags := flag.NewFlagSet("account server", flag.ExitOnError)
        accountFlags.String("c", findConfig("account"), "Config file/directory to use")
        accountFlags.String("l", "stdout", "Log location")
        accountFlags.String("e", "stderr", "Error log location")
        accountFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird account [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run account server")
                accountFlags.PrintDefaults()
        }</span>

        <span class="cov0" title="0">accountReplicatorFlags := flag.NewFlagSet("account replicator", flag.ExitOnError)
        accountReplicatorFlags.String("c", findConfig("account"), "Config file/directory to use")
        accountReplicatorFlags.String("l", "stdout", "Log location")
        accountReplicatorFlags.String("e", "stderr", "Error log location")
        accountReplicatorFlags.Bool("once", false, "Run one pass of the replicator")
        accountReplicatorFlags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "hummingbird account-replicator [ARGS]")
                fmt.Fprintln(os.Stderr, "  Run account replicator")
                accountReplicatorFlags.PrintDefaults()
        }</span>

        /* main flag parser, which doesn't do much */

        <span class="cov0" title="0">flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Hummingbird Usage")
                flag.PrintDefaults()
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "The built-in process control is for entertainment purposes only. Please use a real service manager.")
                fmt.Fprintln(os.Stderr, "     hummingbird start [daemon name]    -- start a server")
                fmt.Fprintln(os.Stderr, "     hummingbird stop [daemon name]     -- stop a server immediately")
                fmt.Fprintln(os.Stderr, "     hummingbird shutdown [daemon name] -- gracefully stop a server")
                fmt.Fprintln(os.Stderr, "     hummingbird reload [daemon name]   -- alias for graceful-restart")
                fmt.Fprintln(os.Stderr, "     hummingbird restart [daemon name]  -- stop then restart a server")
                fmt.Fprintln(os.Stderr, "  The daemons are: object, proxy, object-replicator, object-auditor, all, main")
                fmt.Fprintln(os.Stderr)
                objectFlags.Usage()
                fmt.Fprintln(os.Stderr)
                objectReplicatorFlags.Usage()
                fmt.Fprintln(os.Stderr)
                objectAuditorFlags.Usage()
                fmt.Fprintln(os.Stderr)
                proxyFlags.Usage()
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "hummingbird moveparts [old ring.gz]")
                fmt.Fprintln(os.Stderr, "  Prioritize replication for moving partitions after a ring change")
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "hummingbird restoredevice [ip] [device-name]")
                fmt.Fprintln(os.Stderr, "  Reconstruct a device from its peers")
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "hummingbird rescueparts [partnum1,partnum2,...]")
                fmt.Fprintln(os.Stderr, "  Will send requests to all the object nodes to try to fully replicate given partitions if they have them.")
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "hummingbird bench CONFIG")
                fmt.Fprintln(os.Stderr, "  Run bench tool")
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "hummingbird dbench CONFIG")
                fmt.Fprintln(os.Stderr, "  Run direct to object server bench tool")
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "hummingbird thrash CONFIG")
                fmt.Fprintln(os.Stderr, "  Run thrash bench tool")
                fmt.Fprintln(os.Stderr)
                fmt.Fprintln(os.Stderr, "hummingbird grep [ACCOUNT/CONTAINER/PREFIX] [SEARCH-STRING]")
                fmt.Fprintln(os.Stderr, "  Run grep on the edge")
        }</span>

        <span class="cov0" title="0">flag.Parse()

        if flag.NArg() &lt; 1 </span><span class="cov0" title="0">{
                flag.Usage()
                return
        }</span>

        <span class="cov0" title="0">switch flag.Arg(0) </span>{
        case "version":<span class="cov0" title="0">
                fmt.Println(common.Version)</span>
        case "start":<span class="cov0" title="0">
                processControlCommand(startServer)</span>
        case "stop":<span class="cov0" title="0">
                processControlCommand(stopServer)</span>
        case "restart":<span class="cov0" title="0">
                processControlCommand(restartServer)</span>
        case "reload", "graceful-restart":<span class="cov0" title="0">
                processControlCommand(gracefulRestartServer)</span>
        case "shutdown", "graceful-shutdown":<span class="cov0" title="0">
                processControlCommand(gracefulShutdownServer)</span>
        case "proxy":<span class="cov0" title="0">
                proxyFlags.Parse(flag.Args()[1:])
                srv.RunServers(proxyserver.GetServer, proxyFlags)</span>
        case "container":<span class="cov0" title="0">
                containerFlags.Parse(flag.Args()[1:])
                srv.RunServers(containerserver.GetServer, containerFlags)</span>
        case "container-replicator":<span class="cov0" title="0">
                containerReplicatorFlags.Parse(flag.Args()[1:])
                srv.RunDaemon(containerserver.GetReplicator, containerReplicatorFlags)</span>
        case "account":<span class="cov0" title="0">
                accountFlags.Parse(flag.Args()[1:])
                srv.RunServers(accountserver.GetServer, accountFlags)</span>
        case "account-replicator":<span class="cov0" title="0">
                accountReplicatorFlags.Parse(flag.Args()[1:])
                srv.RunDaemon(accountserver.GetReplicator, accountReplicatorFlags)</span>
        case "object":<span class="cov0" title="0">
                objectFlags.Parse(flag.Args()[1:])
                srv.RunServers(objectserver.GetServer, objectFlags)</span>
        case "object-replicator":<span class="cov0" title="0">
                objectReplicatorFlags.Parse(flag.Args()[1:])
                srv.RunDaemon(objectserver.NewReplicator, objectReplicatorFlags)</span>
        case "object-auditor":<span class="cov0" title="0">
                objectAuditorFlags.Parse(flag.Args()[1:])
                srv.RunDaemon(objectserver.NewAuditor, objectAuditorFlags)</span>
        case "bench":<span class="cov0" title="0">
                bench.RunBench(flag.Args()[1:])</span>
        case "dbench":<span class="cov0" title="0">
                bench.RunDBench(flag.Args()[1:])</span>
        case "cbench":<span class="cov0" title="0">
                bench.RunCBench(flag.Args()[1:])</span>
        case "cgbench":<span class="cov0" title="0">
                bench.RunCGBench(flag.Args()[1:])</span>
        case "thrash":<span class="cov0" title="0">
                bench.RunThrash(flag.Args()[1:])</span>
        case "moveparts":<span class="cov0" title="0">
                objectserver.MoveParts(flag.Args()[1:])</span>
        case "restoredevice":<span class="cov0" title="0">
                objectserver.RestoreDevice(flag.Args()[1:])</span>
        case "rescueparts":<span class="cov0" title="0">
                objectserver.RescueParts(flag.Args()[1:])</span>
        default:<span class="cov0" title="0">
                flag.Usage()</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package conf

import (
        "bytes"
        "errors"
        "fmt"
        "os"
        "os/user"
        "path/filepath"
        "sort"
        "strconv"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/vaughan0/go-ini"
)

// Config represents an ini file.
type Config struct{ ini.File }

type Section struct {
        ini.Section
        c       Config
        section string
}

// Get fetches a value from the Config, looking in the DEFAULT section if not found in the specific section.  Also ignores "set " key prefixes, like paste.
func (f Config) Get(section string, key string) (string, bool) <span class="cov8" title="1">{
        if value, ok := f.File.Get(section, key); ok </span><span class="cov8" title="1">{
                return value, true
        }</span><span class="cov8" title="1"> else if value, ok := f.File.Get("DEFAULT", key); ok </span><span class="cov8" title="1">{
                return value, true
        }</span><span class="cov8" title="1"> else if value, ok := f.File.Get(section, "set "+key); ok </span><span class="cov8" title="1">{
                return value, true
        }</span><span class="cov8" title="1"> else if value, ok := f.File.Get("DEFAULT", "set "+key); ok </span><span class="cov0" title="0">{
                return value, true
        }</span>
        <span class="cov8" title="1">return "", false</span>
}

// GetDefault returns a value from the config, or returns the default setting if the entry doesn't exist.
func (f Config) GetDefault(section string, key string, dfl string) string <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return dfl</span>
}

// GetBool loads a true/false value from the config, with support for things like "yes", "true", "1", "t", etc.
func (f Config) GetBool(section string, key string, dfl bool) bool <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                return common.LooksTrue(value)
        }</span>
        <span class="cov8" title="1">return dfl</span>
}

// GetInt loads an entry from the config, parsed as an integer value.
func (f Config) GetInt(section string, key string, dfl int64) int64 <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                if val, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov8" title="1">{
                        return val
                }</span>
                <span class="cov0" title="0">panic(fmt.Sprintf("Error parsing integer %s/%s from config.", section, key))</span>
        }
        <span class="cov8" title="1">return dfl</span>
}

// GetFloat loads an entry from the config, parsed as a floating point value.
func (f Config) GetFloat(section string, key string, dfl float64) float64 <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                if val, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                        return val
                }</span>
                <span class="cov0" title="0">panic(fmt.Sprintf("Error parsing float %s/%s from config.", section, key))</span>
        }
        <span class="cov8" title="1">return dfl</span>
}

// GetLimit loads an entry from the config in the format of %d/%d.
func (f Config) GetLimit(section string, key string, dfla int64, dflb int64) (int64, int64) <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                fmt.Sscanf(value, "%d/%d", &amp;dfla, &amp;dflb)
        }</span>
        <span class="cov8" title="1">return dfla, dflb</span>
}

// HasSection determines whether or not the section exists in the ini file.
func (f Config) HasSection(section string) bool <span class="cov8" title="1">{
        return f.File[section] != nil
}</span>

// GetSection returns a Section struct.
func (f Config) GetSection(section string) Section <span class="cov8" title="1">{
        return Section{f.File[section], f, section}
}</span>

func (s Section) Get(key string) (string, bool) <span class="cov8" title="1">{
        return s.c.Get(s.section, key)
}</span>

func (s Section) GetDefault(key string, dfl string) string <span class="cov8" title="1">{
        return s.c.GetDefault(s.section, key, dfl)
}</span>

func (s Section) GetBool(key string, dfl bool) bool <span class="cov0" title="0">{
        return s.c.GetBool(s.section, key, dfl)
}</span>

func (s Section) GetInt(key string, dfl int64) int64 <span class="cov0" title="0">{
        return s.c.GetInt(s.section, key, dfl)
}</span>

func (s Section) GetFloat(key string, dfl float64) float64 <span class="cov0" title="0">{
        return s.c.GetFloat(s.section, key, dfl)
}</span>

func (s Section) GetLimit(key string, dfla int64, dflb int64) (int64, int64) <span class="cov0" title="0">{
        return s.c.GetLimit(s.section, key, dfla, dflb)
}</span>

// LoadConfig loads an ini from a path.  The path should be a *.conf file or a *.conf.d directory.
func LoadConfig(path string) (Config, error) <span class="cov8" title="1">{
        file := Config{make(ini.File)}
        if fi, err := os.Stat(path); err != nil </span><span class="cov8" title="1">{
                return file, err
        }</span><span class="cov8" title="1"> else if fi.IsDir() </span><span class="cov8" title="1">{
                files, err := filepath.Glob(filepath.Join(path, "*.conf"))
                if err != nil </span><span class="cov0" title="0">{
                        return file, err
                }</span>
                <span class="cov8" title="1">sort.Strings(files)
                for _, subfile := range files </span><span class="cov8" title="1">{
                        sf, err := LoadConfig(subfile)
                        if err != nil </span><span class="cov0" title="0">{
                                return file, err
                        }</span>
                        <span class="cov8" title="1">for sec, val := range sf.File </span><span class="cov8" title="1">{
                                file.File[sec] = val
                        }</span>
                }
                <span class="cov8" title="1">return file, nil</span>
        }
        <span class="cov8" title="1">return file, file.LoadFile(path)</span>
}

// LoadConfigs finds and loads any configs that exist for the given path.  Multiple configs are supported for things like SAIO setups.
func LoadConfigs(path string) ([]Config, error) <span class="cov8" title="1">{
        configPaths := []string{}
        configs := []Config{}
        if fi, err := os.Stat(path); err == nil &amp;&amp; fi.IsDir() &amp;&amp; !strings.HasSuffix(path, ".conf.d") </span><span class="cov8" title="1">{
                if multiConfigs, err := filepath.Glob(filepath.Join(path, "*.conf")); err == nil </span><span class="cov8" title="1">{
                        configPaths = append(configPaths, multiConfigs...)
                }</span>
                <span class="cov8" title="1">if multiConfigs, err := filepath.Glob(filepath.Join(path, "*.conf.d")); err == nil </span><span class="cov8" title="1">{
                        configPaths = append(configPaths, multiConfigs...)
                }</span>
        }<span class="cov8" title="1"> else {
                configPaths = append(configPaths, path)
        }</span>
        <span class="cov8" title="1">for _, p := range configPaths </span><span class="cov8" title="1">{
                if config, err := LoadConfig(p); err == nil </span><span class="cov8" title="1">{
                        configs = append(configs, config)
                }</span>
        }
        <span class="cov8" title="1">if len(configs) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("Unable to find any configs")
        }</span>
        <span class="cov8" title="1">return configs, nil</span>
}

// StringConfig returns an Config from a string, for use in tests.
func StringConfig(data string) (Config, error) <span class="cov8" title="1">{
        file := Config{make(ini.File)}
        return file, file.Load(bytes.NewBufferString(data))
}</span>

// UidFromConf returns the uid and gid for the user set in the first config found.
func UidFromConf(path string) (uint32, uint32, error) <span class="cov8" title="1">{
        configs, err := LoadConfigs(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov8" title="1">for _, config := range configs </span><span class="cov8" title="1">{
                username := config.GetDefault("DEFAULT", "user", "swift")
                usr, err := user.Lookup(username)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, 0, err
                }</span>
                <span class="cov8" title="1">uid, err := strconv.ParseUint(usr.Uid, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, err
                }</span>
                <span class="cov8" title="1">gid, err := strconv.ParseUint(usr.Gid, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, err
                }</span>
                <span class="cov8" title="1">return uint32(uid), uint32(gid), nil</span>
        }
        <span class="cov0" title="0">return 0, 0, fmt.Errorf("Unable to find config")</span>
}

var configLocations = []string{"/etc/hummingbird/hummingbird.conf", "/etc/swift/swift.conf"}

// GetHashPrefixAndSuffix retrieves the hash path prefix and suffix from
// the correct configs based on the environments setup. The suffix cannot
// be nil
type getHashPrefixAndSuffixFunc func() (pfx string, sfx string, err error)

var GetHashPrefixAndSuffix getHashPrefixAndSuffixFunc = normalGetHashPrefixAndSuffix

func normalGetHashPrefixAndSuffix() (prefix string, suffix string, err error) <span class="cov8" title="1">{
        for _, loc := range configLocations </span><span class="cov8" title="1">{
                if conf, e := LoadConfig(loc); e == nil </span><span class="cov8" title="1">{
                        var ok bool
                        prefix, _ = conf.Get("swift-hash", "swift_hash_path_prefix")
                        if suffix, ok = conf.Get("swift-hash", "swift_hash_path_suffix"); !ok </span><span class="cov0" title="0">{
                                err = errors.New("Hash path suffix not defined")
                                return
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func ReadResellerOptions(conf Section, defaults map[string][]string) ([]string, map[string]map[string][]string) <span class="cov8" title="1">{
        resellerPrefixOpt := conf.GetDefault("reseller_prefix", "AUTH")
        s := []string{}
        for _, val := range strings.Split(resellerPrefixOpt, ",") </span><span class="cov8" title="1">{
                v := strings.TrimSpace(val)
                if v != "" </span><span class="cov8" title="1">{
                        s = append(s, strings.TrimSpace(v))
                }</span>
        }
        <span class="cov8" title="1">resellerPrefix := []string{}
        for _, prefix := range s </span><span class="cov8" title="1">{
                if prefix == "''" </span><span class="cov8" title="1">{
                        prefix = ""
                }</span>
                <span class="cov8" title="1">if prefix != "" &amp;&amp; !strings.HasSuffix(prefix, "_") </span><span class="cov8" title="1">{
                        prefix = prefix + "_"
                }</span>
                <span class="cov8" title="1">if !common.StringInSlice(prefix, resellerPrefix) </span><span class="cov8" title="1">{
                        resellerPrefix = append(resellerPrefix, prefix)
                }</span>
        }
        <span class="cov8" title="1">if len(resellerPrefix) == 0 </span><span class="cov8" title="1">{
                resellerPrefix = append(resellerPrefix, "")
        }</span>
        <span class="cov8" title="1">associatedOptions := make(map[string]map[string][]string)
        for _, prefix := range resellerPrefix </span><span class="cov8" title="1">{
                associatedOptions[prefix] = make(map[string][]string)
                for k, v := range defaults </span><span class="cov8" title="1">{
                        associatedOptions[prefix][k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range ReadPrefixedOptions(conf, "", defaults) </span><span class="cov8" title="1">{
                        associatedOptions[prefix][k] = v
                }</span>
                <span class="cov8" title="1">prefix_name := "''"
                if prefix != "" </span><span class="cov8" title="1">{
                        prefix_name = prefix
                }</span>
                <span class="cov8" title="1">for k, v := range ReadPrefixedOptions(conf, prefix_name, defaults) </span><span class="cov8" title="1">{
                        associatedOptions[prefix][k] = v
                }</span>
        }
        <span class="cov8" title="1">return resellerPrefix, associatedOptions</span>
}

func ReadPrefixedOptions(conf Section, prefixName string, defaults map[string][]string) map[string][]string <span class="cov8" title="1">{
        params := make(map[string][]string)
        for optionName := range defaults </span><span class="cov8" title="1">{
                if value, ok := conf.Get(fmt.Sprintf("%s%s", prefixName, optionName)); ok </span><span class="cov8" title="1">{
                        params[optionName] = []string{}
                        for _, role := range strings.Split(strings.ToLower(value), ",") </span><span class="cov8" title="1">{
                                params[optionName] = append(params[optionName], strings.TrimSpace(role))
                        }</span>
                }
        }
        <span class="cov8" title="1">return params</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package conf

import (
        "fmt"
        "strings"
)

type Policy struct {
        Index      int
        Type       string
        Name       string
        Aliases    []string
        Default    bool
        Deprecated bool
        Config     map[string]string
}

type PolicyList map[int]*Policy

func (p PolicyList) Default() int <span class="cov8" title="1">{
        for _, v := range p </span><span class="cov8" title="1">{
                if v.Default </span><span class="cov8" title="1">{
                        return v.Index
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (p PolicyList) GetPolicyInfo() []map[string]interface{} <span class="cov8" title="1">{
        policyInfo := []map[string]interface{}{}
        for _, v := range p </span><span class="cov8" title="1">{
                if v.Deprecated </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">pol := map[string]interface{}{}
                pol["name"] = v.Name
                if v.Default </span><span class="cov8" title="1">{
                        pol["default"] = v.Default
                }</span>
                <span class="cov8" title="1">pol["aliases"] = strings.Join(v.Aliases, ", ")
                policyInfo = append(policyInfo, pol)</span>
        }
        <span class="cov8" title="1">return policyInfo</span>
}

// LoadPolicies loads policies, probably from /etc/swift/swift.conf
func normalLoadPolicies() PolicyList <span class="cov8" title="1">{
        policies := map[int]*Policy{0: {
                Index:      0,
                Type:       "replication",
                Name:       "Policy-0",
                Aliases:    nil,
                Default:    false,
                Deprecated: false,
        }}
        for _, loc := range configLocations </span><span class="cov8" title="1">{
                if conf, e := LoadConfig(loc); e == nil </span><span class="cov8" title="1">{
                        for key := range conf.File </span><span class="cov8" title="1">{
                                var policyIndex int
                                if c, err := fmt.Sscanf(key, "storage-policy:%d", &amp;policyIndex); err == nil &amp;&amp; c == 1 </span><span class="cov8" title="1">{
                                        name := conf.GetDefault(key, "name", fmt.Sprintf("Policy-%d", policyIndex))
                                        aliases := []string{name}
                                        aliasList := conf.GetDefault(key, "aliases", "")
                                        for _, alias := range strings.Split(aliasList, ",") </span><span class="cov8" title="1">{
                                                alias = strings.Trim(alias, " ")
                                                if alias != "" &amp;&amp; alias != name </span><span class="cov8" title="1">{
                                                        aliases = append(aliases, alias)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">policies[policyIndex] = &amp;Policy{
                                                Index:      policyIndex,
                                                Type:       conf.GetDefault(key, "policy_type", "replication"),
                                                Name:       name,
                                                Aliases:    aliases,
                                                Deprecated: conf.GetBool(key, "deprecated", false),
                                                Default:    conf.GetBool(key, "default", false),
                                                Config:     map[string]string(conf.File[key]),
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">defaultFound := false
        for _, policy := range policies </span><span class="cov8" title="1">{
                if policy.Default </span><span class="cov8" title="1">{
                        defaultFound = true
                }</span>
        }
        <span class="cov8" title="1">if !defaultFound </span><span class="cov8" title="1">{
                policies[0].Default = true
        }</span>
        <span class="cov8" title="1">return PolicyList(policies)</span>
}

type loadPoliciesFunc func() PolicyList

var LoadPolicies loadPoliciesFunc = normalLoadPolicies
</pre>
		
		<pre class="file" id="file15" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package conf

import "strings"

type SyncRealm struct {
        Name     string
        Key1     string
        Key2     string
        Clusters map[string]string
}

type SyncRealmList map[string]SyncRealm

func (l SyncRealmList) ValidateSyncTo(syncHeader string) bool <span class="cov8" title="1">{
        if !strings.HasPrefix(syncHeader, "//") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">parts := strings.Split(syncHeader[2:], "/")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">realm := parts[0]
        cluster := parts[1]
        account := parts[2]
        container := parts[3]
        if account == "" || container == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if l[realm].Key1 == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if l[realm].Clusters[cluster] == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

var syncRealmConfigLocations = []string{"/etc/hummingbird/container-sync-realms.conf", "/etc/swift/container-sync-realms.conf"}

func GetSyncRealms() SyncRealmList <span class="cov0" title="0">{
        resp := make(map[string]SyncRealm)
        for _, loc := range syncRealmConfigLocations </span><span class="cov0" title="0">{
                if conf, err := LoadConfig(loc); err == nil </span><span class="cov0" title="0">{
                        for realm, config := range conf.File </span><span class="cov0" title="0">{
                                realm := SyncRealm{Name: realm, Clusters: make(map[string]string)}
                                for k, v := range config </span><span class="cov0" title="0">{
                                        if k == "key" </span><span class="cov0" title="0">{
                                                realm.Key1 = v
                                        }</span><span class="cov0" title="0"> else if k == "key2" </span><span class="cov0" title="0">{
                                                realm.Key2 = v
                                        }</span><span class="cov0" title="0"> else if strings.HasPrefix(k, "cluster_") </span><span class="cov0" title="0">{
                                                realm.Clusters[k[8:]] = v
                                        }</span>
                                }
                                <span class="cov0" title="0">resp[realm.Name] = realm</span>
                        }
                }
        }
        <span class="cov0" title="0">return SyncRealmList(resp)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package common

import (
        "sync/atomic"
        "unsafe"
)

type FreePool []*unsafe.Pointer

func (a FreePool) Get() interface{} <span class="cov8" title="1">{
        for _, p := range a </span><span class="cov8" title="1">{
                if v := atomic.SwapPointer(p, nil); v != nil </span><span class="cov8" title="1">{
                        return *(*interface{})(v)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (a FreePool) Put(v interface{}) <span class="cov8" title="1">{
        vp := unsafe.Pointer(&amp;v)
        for _, p := range a </span><span class="cov8" title="1">{
                if atomic.CompareAndSwapPointer(p, nil, vp) </span><span class="cov8" title="1">{
                        return
                }</span>
        }
}

func NewFreePool(size int) FreePool <span class="cov8" title="1">{
        a := make(FreePool, size)
        for i := range a </span><span class="cov8" title="1">{
                a[i] = new(unsafe.Pointer)
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// +build linux

package fs

import (
        "errors"
        "fmt"
        "io/ioutil"
        "math/rand"
        "os"
        "path/filepath"
        "syscall"
        "unsafe"
)

/*
#include &lt;fcntl.h&gt;

#ifndef __O_TMPFILE
#define __O_TMPFILE        020000000
#endif
*/
import "C"

var (
        AT_FDCWD          = C.AT_FDCWD
        AT_SYMLINK_FOLLOW = C.AT_SYMLINK_FOLLOW
        O_TMPFILE         = C.__O_TMPFILE | syscall.O_DIRECTORY
        useOTempfile      = false
)

func init() <span class="cov8" title="1">{
        var buf syscall.Utsname
        var linuxMajorVersion = 0
        var linuxMinorVersion = 0
        if syscall.Uname(&amp;buf) == nil </span><span class="cov8" title="1">{
                var release string
                for _, c := range buf.Release </span><span class="cov8" title="1">{
                        if c == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">release += string(byte(c))</span>
                }
                <span class="cov8" title="1">if c, err := fmt.Sscanf(release, "%d.%d.", &amp;linuxMajorVersion, &amp;linuxMinorVersion); err != nil || c != 2 </span><span class="cov0" title="0">{
                        linuxMajorVersion = 0
                        linuxMinorVersion = 0
                }</span>
        }
        // Linux 3.15 is where XFS got O_TMPFILE support.
        <span class="cov8" title="1">useOTempfile = (linuxMajorVersion &gt; 3 || (linuxMajorVersion == 3 &amp;&amp; linuxMinorVersion &gt;= 15))</span>
}

func linkat(fd uintptr, dst string) error <span class="cov8" title="1">{
        prodFd := []byte(fmt.Sprintf("/proc/self/fd/%d\x00", fd))
        dstName := append([]byte(dst), 0)
        _, _, err := syscall.Syscall6(syscall.SYS_LINKAT,
                uintptr(AT_FDCWD), uintptr(unsafe.Pointer(&amp;prodFd[0])),
                uintptr(AT_FDCWD), uintptr(unsafe.Pointer(&amp;dstName[0])),
                uintptr(AT_SYMLINK_FOLLOW), 0)
        if err != 0 </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// TempFile implements an atomic file writer using linux's O_TMPFILE/linkat mechanism if available, otherwise by writing to a temp directory and renaming.
type TempFile struct {
        *os.File
        tempDir   string
        saved     bool
        otempfile bool
}

// Abandon removes any resources associated with this file, if it hasn't already been saved.
func (o *TempFile) Abandon() error <span class="cov8" title="1">{
        if o.saved </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if !o.otempfile </span><span class="cov0" title="0">{
                os.Remove(o.Name())
        }</span>
        <span class="cov8" title="1">return o.File.Close()</span>
}

// Save atomically writes the file to its destination.
func (o *TempFile) Save(dst string) error <span class="cov8" title="1">{
        defer o.File.Close()
        if err := o.File.Sync(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if o.otempfile </span><span class="cov8" title="1">{
                if err := linkat(o.File.Fd(), dst); err != nil </span><span class="cov8" title="1">{
                        if err := os.MkdirAll(o.tempDir, 0770); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">tmpLocation := filepath.Join(o.tempDir, fmt.Sprintf(".%016X", rand.Int63()))
                        if err := linkat(o.File.Fd(), tmpLocation); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(dst), 0770); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return os.Rename(tmpLocation, dst)</span>
                }
        }<span class="cov0" title="0"> else {
                if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := os.Rename(o.File.Name(), dst); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">o.saved = true
        return nil</span>
}

// Preallocate pre-allocates space for the file.
func (o *TempFile) Preallocate(size int64, reserve int64) error <span class="cov8" title="1">{
        var st syscall.Statfs_t
        if reserve &gt; 0 </span><span class="cov0" title="0">{
                if err := syscall.Fstatfs(int(o.Fd()), &amp;st); err == nil </span><span class="cov0" title="0">{
                        freeSpace := int64(st.Frsize) * int64(st.Bavail)
                        if freeSpace-size &lt; reserve </span><span class="cov0" title="0">{
                                return errors.New("Not enough reserve space on disk.")
                        }</span>
                }
        }
        <span class="cov8" title="1">if size &gt; 0 </span><span class="cov8" title="1">{
                syscall.Fallocate(int(o.Fd()), 1, 0, size)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewAtomicFileWriter returns an AtomicFileWriter, which handles atomically writing files.
func NewAtomicFileWriter(tempDir string, dstDir string) (AtomicFileWriter, error) <span class="cov8" title="1">{
        if useOTempfile </span><span class="cov8" title="1">{
                if err := os.MkdirAll(dstDir, 0770); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tempFile, err := os.OpenFile(dstDir, O_TMPFILE|os.O_RDWR, 0660)
                if err == nil </span><span class="cov8" title="1">{
                        return &amp;TempFile{File: tempFile, tempDir: tempDir, saved: false, otempfile: true}, nil
                }</span>
        }
        <span class="cov0" title="0">if err := os.MkdirAll(tempDir, 0770); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tempFile, err := ioutil.TempFile(tempDir, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TempFile{File: tempFile, tempDir: tempDir, saved: false, otempfile: false}, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package fs

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "syscall"
        "time"
)

// AtomicFileWriter saves a new file atomically.
type AtomicFileWriter interface {
        // Write writes the data to the underlying file.
        Write([]byte) (int, error)
        // Fd returns the file's underlying file descriptor.
        Fd() uintptr
        // Save atomically writes the file to its destination.
        Save(string) error
        // Abandon removes any resources associated with this file.
        Abandon() error
        // Preallocate pre-allocates space on disk, given the expected file size and disk reserve size.
        Preallocate(int64, int64) error
}

// LockPath locks a directory with a timeout.
func LockPath(directory string, timeout time.Duration) (*os.File, error) <span class="cov8" title="1">{
        lockfile := filepath.Join(directory, ".lock")
        file, err := os.OpenFile(lockfile, os.O_RDWR|os.O_CREATE, 0660)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) &amp;&amp; os.MkdirAll(directory, 0755) == nil </span><span class="cov0" title="0">{
                        file, err = os.OpenFile(lockfile, os.O_RDWR|os.O_CREATE, 0660)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("Unable to open lock file (%v)", err))
                }</span>
        }
        <span class="cov8" title="1">success := make(chan error)
        cancel := make(chan struct{})
        defer close(cancel)
        timer := time.NewTimer(timeout)
        defer timer.Stop()
        go func(fd int) </span><span class="cov8" title="1">{
                select </span>{
                case success &lt;- syscall.Flock(fd, syscall.LOCK_EX):</span><span class="cov8" title="1">
                case &lt;-cancel:</span><span class="cov8" title="1">
                }
        }(int(file.Fd()))
        <span class="cov8" title="1">select </span>{
        case err = &lt;-success:<span class="cov8" title="1">
                if err == nil </span><span class="cov8" title="1">{
                        return file, nil
                }</span>
        case &lt;-timer.C:<span class="cov8" title="1">
                err = errors.New("Flock timed out")</span>
        }
        <span class="cov8" title="1">file.Close()
        return nil, err</span>
}

func IsMount(dir string) (bool, error) <span class="cov8" title="1">{
        dir = filepath.Clean(dir)
        if fileinfo, err := os.Stat(dir); err == nil </span><span class="cov8" title="1">{
                if parentinfo, err := os.Stat(filepath.Dir(dir)); err == nil </span><span class="cov8" title="1">{
                        return fileinfo.Sys().(*syscall.Stat_t).Dev != parentinfo.Sys().(*syscall.Stat_t).Dev, nil
                }</span><span class="cov0" title="0"> else {
                        return false, errors.New("Unable to stat parent")
                }</span>
        }<span class="cov8" title="1"> else {
                return false, errors.New("Unable to stat directory")
        }</span>
}

func IsNotDir(err error) bool <span class="cov8" title="1">{
        if se, ok := err.(*os.SyscallError); ok </span><span class="cov8" title="1">{
                return se.Err == syscall.ENOTDIR || se.Err == syscall.EINVAL
        }</span>
        <span class="cov8" title="1">if se, ok := err.(*os.PathError); ok </span><span class="cov8" title="1">{
                return os.IsNotExist(se)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func ReadDirNames(path string) ([]string, error) <span class="cov8" title="1">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">list, err := f.Readdirnames(-1)
        f.Close()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(list) &gt; 1 </span><span class="cov8" title="1">{
                sort.Strings(list)
        }</span>
        <span class="cov8" title="1">return list, nil</span>
}

func Exists(file string) bool <span class="cov8" title="1">{
        if _, err := os.Stat(file); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package fs

import "errors"

// Setxattr sets xattrs for a file, given a file descriptor, attribute name, and value buffer.
func Setxattr(fileNameOrFd interface{}, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        switch v := fileNameOrFd.(type) </span>{
        case string:<span class="cov8" title="1">
                return setxattr(v, attr, value)</span>
        case uintptr:<span class="cov8" title="1">
                return fsetxattr(v, attr, value)</span>
        case int:<span class="cov0" title="0">
                return fsetxattr(uintptr(v), attr, value)</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("Invalid fileNameOrFd")</span>
        }
}

// Getxattr gets xattrs from a file, given a filename(string) or file descriptor(uintptr), an attribute name, and value buffer to store it to.
func Getxattr(fileNameOrFd interface{}, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        switch v := fileNameOrFd.(type) </span>{
        case string:<span class="cov8" title="1">
                return getxattr(v, attr, value)</span>
        case uintptr:<span class="cov8" title="1">
                return fgetxattr(v, attr, value)</span>
        case int:<span class="cov0" title="0">
                return fgetxattr(uintptr(v), attr, value)</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("Invalid fileNameOrFd")</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// +build linux darwin

package fs

import (
        "syscall"
        "unsafe"
)

func fsetxattr(fd uintptr, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">valuep := unsafe.Pointer(&amp;value[0])
        if r0, _, e1 := syscall.Syscall6(syscall.SYS_FSETXATTR, fd, uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0); e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span><span class="cov0" title="0"> else {
                return 0, e1
        }</span>
}

func setxattr(path string, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">pathp, err := syscall.BytePtrFromString(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">valuep := unsafe.Pointer(&amp;value[0])
        if r0, _, e1 := syscall.Syscall6(syscall.SYS_SETXATTR, uintptr(unsafe.Pointer(pathp)), uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0); e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span><span class="cov0" title="0"> else {
                return 0, e1
        }</span>
}

func fgetxattr(fd uintptr, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">var r0 uintptr
        var e1 syscall.Errno
        if len(value) == 0 </span><span class="cov8" title="1">{
                r0, _, e1 = syscall.Syscall6(syscall.SYS_FGETXATTR, fd, uintptr(unsafe.Pointer(attrp)), 0, 0, 0, 0)
        }</span><span class="cov8" title="1"> else {
                valuep := unsafe.Pointer(&amp;value[0])
                r0, _, e1 = syscall.Syscall6(syscall.SYS_FGETXATTR, fd, uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0)
        }</span>
        <span class="cov8" title="1">if e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span><span class="cov8" title="1"> else {
                return 0, e1
        }</span>
}

func getxattr(path string, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">pathp, err := syscall.BytePtrFromString(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">var r0 uintptr
        var e1 syscall.Errno
        if len(value) == 0 </span><span class="cov8" title="1">{
                r0, _, e1 = syscall.Syscall6(syscall.SYS_GETXATTR, uintptr(unsafe.Pointer(pathp)), uintptr(unsafe.Pointer(attrp)), 0, 0, 0, 0)
        }</span><span class="cov8" title="1"> else {
                valuep := unsafe.Pointer(&amp;value[0])
                r0, _, e1 = syscall.Syscall6(syscall.SYS_GETXATTR, uintptr(unsafe.Pointer(pathp)), uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0)
        }</span>
        <span class="cov8" title="1">if e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span><span class="cov8" title="1"> else {
                return 0, e1
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// TODO: Some of this code was pulled from the go stdlib and modified. figure out how to attribute this.
// https://wiki.openstack.org/wiki/LegalIssuesFAQ#Incorporating_BSD.2FMIT_Licensed_Code

package common

import (
        "bytes"
        "crypto/rand"
        "errors"
        "fmt"
        "io"
)

// MultiWriter is a streaming multipart writer, similar to the standard library's multipart.Writer, but
// compatible with Swift's output and with an API geared toward our common use, multi-range responses.
type MultiWriter struct {
        w              io.Writer
        boundary       string
        lastpart       *part
        contentType    string
        contentLength  int64
        lengthEstimate int64
}

// NewMultiWriter instantiates a new MultiWriter.
func NewMultiWriter(w io.Writer, contentType string, contentLength int64) *MultiWriter <span class="cov8" title="1">{
        var buf [32]byte
        _, err := io.ReadFull(rand.Reader, buf[:])
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;MultiWriter{
                w:              w,
                boundary:       fmt.Sprintf("%064x", buf[:]),
                contentType:    contentType,
                contentLength:  contentLength,
                lengthEstimate: int64(68), // length of --boundary--
        }</span>
}

// Expect adds an expected part to the Content-Length estimate for the multipart body.
func (w *MultiWriter) Expect(start, end int64) <span class="cov8" title="1">{
        w.lengthEstimate += int64(len(fmt.Sprintf("--%s\r\nContent-Type: %s\r\nContent-Range: bytes %d-%d/%d\r\n\r\n",
                w.boundary, w.contentType, start, end-1, w.contentLength)))
        w.lengthEstimate += (end - start) + 2 // part data and trailing \r\n
}</span>

// ContentLength returns the expected Content-Length of the multipart body.
func (w *MultiWriter) ContentLength() int64 <span class="cov8" title="1">{
        return w.lengthEstimate
}</span>

// Boundary returns the MultiWriter's boundary string.
func (w *MultiWriter) Boundary() string <span class="cov8" title="1">{
        return w.boundary
}</span>

// CreatePart begins a new part in the multi-part response, with the given content ranges.
func (w *MultiWriter) CreatePart(start, end int64) (io.Writer, error) <span class="cov8" title="1">{
        if w.lastpart != nil </span><span class="cov8" title="1">{
                if err := w.lastpart.close(); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">b := &amp;bytes.Buffer{}
        if w.lastpart != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(b, "\r\n")
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(b, "--%s\r\nContent-Type: %s\r\nContent-Range: bytes %d-%d/%d\r\n\r\n",
                w.boundary, w.contentType, start, end-1, w.contentLength)
        _, err := io.Copy(w.w, b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p := &amp;part{
                mw: w,
        }
        w.lastpart = p
        return p, nil</span>
}

// Close finalizes the output of the MultiWriter.
func (w *MultiWriter) Close() error <span class="cov8" title="1">{
        if w.lastpart != nil </span><span class="cov8" title="1">{
                if err := w.lastpart.close(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">w.lastpart = nil</span>
        }
        <span class="cov8" title="1">_, err := fmt.Fprintf(w.w, "\r\n--%s--", w.boundary)
        return err</span>
}

type part struct {
        mw     *MultiWriter
        closed bool
        we     error
}

func (p *part) close() error <span class="cov8" title="1">{
        p.closed = true
        return p.we
}</span>

func (p *part) Write(d []byte) (n int, err error) <span class="cov8" title="1">{
        if p.closed </span><span class="cov8" title="1">{
                return 0, errors.New("multipart: can't write to finished part")
        }</span>
        <span class="cov8" title="1">n, err = p.mw.w.Write(d)
        if err != nil </span><span class="cov8" title="1">{
                p.we = err
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package pickle

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "math"
        "reflect"
)

func picklestring(val string, buf *bytes.Buffer, scratch []byte) <span class="cov8" title="1">{
        length := len(val)
        if length &lt; 256 </span><span class="cov8" title="1">{
                buf.WriteByte('U') // SHORT_BINSTRING
                buf.WriteByte(byte(length))
                buf.WriteString(val)
        }</span><span class="cov8" title="1"> else {
                scratch[0] = 'T' // BINSTRING
                binary.LittleEndian.PutUint32(scratch[1:5], uint32(length))
                buf.Write(scratch[0:5])
                buf.WriteString(val)
        }</span>
}

func pickleint(val int64, buf *bytes.Buffer, scratch []byte) <span class="cov8" title="1">{
        if int64(uint8(val)) == val </span><span class="cov8" title="1">{
                buf.WriteByte('K') // BININT1
                buf.WriteByte(byte(val))
        }</span><span class="cov8" title="1"> else if int64(uint16(val)) == val </span><span class="cov8" title="1">{
                scratch[0] = 'M' // BININT2
                binary.LittleEndian.PutUint16(scratch[1:3], uint16(val))
                buf.Write(scratch[0:3])
        }</span><span class="cov8" title="1"> else if int64(int32(val)) == val </span><span class="cov8" title="1">{
                scratch[0] = 'J' // BININT
                binary.LittleEndian.PutUint32(scratch[1:5], uint32(val))
                buf.Write(scratch[0:5])
        }</span><span class="cov8" title="1"> else {
                scratch[0] = '\x8a' // LONG1
                scratch[1] = 8      // 8 bytes
                binary.LittleEndian.PutUint64(scratch[2:10], uint64(val))
                buf.Write(scratch[0:10])
        }</span>
}

func pickleobj(o interface{}, buf *bytes.Buffer, scratch []byte) error <span class="cov8" title="1">{
        v := reflect.ValueOf(o)
        switch v.Kind() </span>{
        case reflect.Ptr, reflect.Interface:<span class="cov8" title="1">
                if v.IsNil() </span><span class="cov8" title="1">{
                        buf.WriteByte('N') // NONE
                }</span><span class="cov8" title="1"> else {
                        return pickleobj(v.Elem().Interface(), buf, scratch)
                }</span>
        case reflect.Invalid:<span class="cov8" title="1">
                buf.WriteByte('N')</span> // NONE
        case reflect.Bool:<span class="cov8" title="1">
                if v.Bool() </span><span class="cov8" title="1">{
                        buf.WriteByte('\x88') // NEWTRUE
                }</span><span class="cov8" title="1"> else {
                        buf.WriteByte('\x89') // NEWFALSE
                }</span>
        case reflect.String:<span class="cov8" title="1">
                picklestring(v.String(), buf, scratch)</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                pickleint(v.Int(), buf, scratch)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov8" title="1">
                pickleint(int64(v.Uint()), buf, scratch)</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                scratch[0] = 'G' // BINFLOAT
                bits := math.Float64bits(v.Float())
                binary.BigEndian.PutUint64(scratch[1:9], bits)
                buf.Write(scratch[0:9])</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                buf.WriteByte('(') // MARK
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        if err := pickleobj(v.Index(i).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">buf.WriteByte('l')</span> // LIST
        case reflect.Map:<span class="cov8" title="1">
                buf.WriteByte('(') // MARK
                // Using "range" is way faster than iterating over maps with reflection,
                // but it's verbose and has to be a type we know ahead of time.
                switch o := o.(type) </span>{
                case map[string]string:<span class="cov8" title="1">
                        for k, v := range o </span><span class="cov8" title="1">{
                                picklestring(k, buf, scratch)
                                picklestring(v, buf, scratch)
                        }</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        for k, v := range o </span><span class="cov8" title="1">{
                                picklestring(k, buf, scratch)
                                if err := pickleobj(v, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                case map[interface{}]interface{}:<span class="cov8" title="1">
                        for k, v := range o </span><span class="cov8" title="1">{
                                if err := pickleobj(k, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := pickleobj(v, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        for _, k := range v.MapKeys() </span><span class="cov8" title="1">{
                                if err := pickleobj(k.Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := pickleobj(v.MapIndex(k).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">buf.WriteByte('d')</span> // DICT
        case reflect.Struct:<span class="cov8" title="1">
                switch o := o.(type) </span>{
                case PickleTuple:<span class="cov8" title="1">
                        buf.WriteByte('(') // MARK
                        for _, to := range []interface{}{o.A, o.B, o.C, o.D}[:o.Len] </span><span class="cov8" title="1">{
                                if err := pickleobj(to, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">buf.WriteByte('l')</span> // TUPLE
                case PickleArray:<span class="cov8" title="1">
                        buf.WriteString("carray\narray\n")
                        buf.WriteByte('(') // MARK
                        if err := pickleobj(o.Type, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := pickleobj(o.Data, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">buf.WriteByte('l') // TUPLE
                        buf.WriteByte('R')</span> // REDUCE
                default:<span class="cov8" title="1"> // why not serialize arbitrary structs as dicts while we're here
                        if v.NumField() == 2 &amp;&amp; v.Type().Field(0).Name == "ArrayType" </span><span class="cov8" title="1">{
                                buf.WriteString("carray\narray\n")
                                buf.WriteByte('(') // MARK
                                if err := pickleobj(v.Field(0).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := pickleobj(v.Field(1).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">buf.WriteByte('l') // TUPLE
                                buf.WriteByte('R') // REDUCE
                                return nil</span>
                        }
                        <span class="cov8" title="1">buf.WriteByte('(') // MARK
                        for i := 0; i &lt; v.Type().NumField(); i++ </span><span class="cov8" title="1">{
                                field := v.Type().Field(i)
                                if tag := field.Tag.Get("pickle"); tag != "" </span><span class="cov8" title="1">{
                                        picklestring(tag, buf, scratch)
                                }</span><span class="cov8" title="1"> else {
                                        picklestring(v.Type().Field(i).Name, buf, scratch)
                                }</span>
                                <span class="cov8" title="1">if err := pickleobj(v.Field(i).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">buf.WriteByte('d')</span> // DICT
                }
        default:<span class="cov8" title="1">
                return fmt.Errorf("Unknown object type in pickle: %v", v)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func PickleDumps(o interface{}) []byte <span class="cov8" title="1">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte('\x80') // PROTO
        buf.WriteByte(2)      // Protocol 2
        scratch := make([]byte, 10)
        if err := pickleobj(o, buf, scratch); err != nil </span><span class="cov8" title="1">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">buf.WriteByte('.')
        return buf.Bytes()</span>
}

func Marshal(v interface{}) ([]byte, error) <span class="cov0" title="0">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte('\x80') // PROTO
        buf.WriteByte(2)      // Protocol 2
        scratch := make([]byte, 10)
        if err := pickleobj(v, buf, scratch); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package pickle

import (
        "errors"
        "reflect"
)

func unpack(src reflect.Value, dst reflect.Value) error <span class="cov8" title="1">{
        for src.Kind() == reflect.Ptr || src.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                if src.IsNil() </span><span class="cov8" title="1">{
                        dst.Set(dst)
                        return nil
                }</span>
                <span class="cov8" title="1">src = src.Elem()</span>
        }
        <span class="cov8" title="1">for dst.Kind() == reflect.Ptr || dst.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                if dst.IsNil() </span><span class="cov8" title="1">{
                        dst.Set(reflect.New(dst.Type().Elem()))
                }</span>
                <span class="cov8" title="1">dst = dst.Elem()</span>
        }
        <span class="cov8" title="1">if src.Type().ConvertibleTo(dst.Type()) </span><span class="cov8" title="1">{
                dst.Set(src.Convert(dst.Type()))
                return nil
        }</span>
        <span class="cov8" title="1">switch dst.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                dst.SetBool(src.Interface() != reflect.Zero(src.Type()).Interface())
                return nil</span>
        case reflect.Slice:<span class="cov8" title="1">
                if k := src.Kind(); k != reflect.Slice &amp;&amp; k != reflect.Array </span><span class="cov0" title="0">{
                        return errors.New("Unable to assign slice from non-slice")
                }</span>
                <span class="cov8" title="1">dst.Set(reflect.MakeSlice(dst.Type(), src.Len(), src.Len()))
                for i := 0; i &lt; src.Len(); i++ </span><span class="cov8" title="1">{
                        if err := unpack(src.Index(i), dst.Index(i)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case reflect.Map:<span class="cov8" title="1">
                if src.Kind() != reflect.Map </span><span class="cov0" title="0">{
                        return errors.New("Unable to assign map from non-map")
                }</span>
                <span class="cov8" title="1">dst.Set(reflect.MakeMap(dst.Type()))
                nk := reflect.New(dst.Type().Key())
                nv := reflect.New(dst.Type().Elem())
                for _, k := range src.MapKeys() </span><span class="cov8" title="1">{
                        if err := unpack(k, nk); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := unpack(src.MapIndex(k), nv); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">dst.SetMapIndex(nk.Elem(), nv.Elem())</span>
                }
        case reflect.Struct:<span class="cov8" title="1">
                if src.Type() == reflect.TypeOf(PickleArray{}) &amp;&amp; dst.NumField() == 2 &amp;&amp; dst.Type().Field(0).Name == "ArrayType" </span><span class="cov8" title="1">{
                        if err := unpack(src.Field(0), dst.Field(0)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return unpack(src.Field(1), dst.Field(1))</span>
                }
                <span class="cov8" title="1">for _, k := range src.MapKeys() </span><span class="cov8" title="1">{
                        for k.Kind() == reflect.Ptr || k.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                                k = k.Elem()
                        }</span>
                        <span class="cov8" title="1">for i := 0; i &lt; dst.NumField(); i++ </span><span class="cov8" title="1">{
                                if f := dst.Type().Field(i); f.Name == k.String() || f.Tag.Get("pickle") == k.String() </span><span class="cov8" title="1">{
                                        if err := unpack(src.MapIndex(k), dst.Field(i)); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        default:<span class="cov0" title="0">
                return errors.New("Assign to unknown type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Unmarshal parses the pickled data and stores the result in the value pointed to by v.
// Unmarshal is considerably less performant than PickleLoads, so think twice before using it in performance-sensitive code.
func Unmarshal(data []byte, v interface{}) error <span class="cov8" title="1">{
        src, err := PickleLoads(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return unpack(reflect.ValueOf(src), reflect.ValueOf(v))</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package pickle

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "math"
        "strconv"
)

var markster = "HI, I'M MARK!"
var mark = interface{}(&amp;markster)

type PickleTuple struct {
        Len int
        A   interface{}
        B   interface{}
        C   interface{}
        D   interface{}
}

type PickleArray struct {
        Type string
        Data []interface{}
}

type unpickleState struct {
        stack      []interface{}
        top        int
        data       []byte
        dataOffset int
        memoKey    []int
        memoVal    []interface{}
}

type pickleGlobal struct {
        name string
}

func (s *unpickleState) push(item interface{}) <span class="cov8" title="1">{
        if len(s.stack) &lt; s.top+1 </span><span class="cov8" title="1">{
                s.stack = append(s.stack, item)
        }</span><span class="cov8" title="1"> else {
                s.stack[s.top] = item
        }</span>
        <span class="cov8" title="1">s.top++</span>
}

func (s *unpickleState) pop() (interface{}, error) <span class="cov8" title="1">{
        if s.top &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("empty stack")
        }</span>
        <span class="cov8" title="1">s.top -= 1
        return s.stack[s.top], nil</span>
}

func (s *unpickleState) peek() (interface{}, error) <span class="cov8" title="1">{
        if s.top &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("empty stack")
        }</span>
        <span class="cov8" title="1">return s.stack[s.top-1], nil</span>
}

func (s *unpickleState) setMark() <span class="cov8" title="1">{
        s.push(mark)
}</span>

func (s *unpickleState) mark() ([]interface{}, error) <span class="cov8" title="1">{
        start := s.top
        for s.top &gt; 0 &amp;&amp; s.stack[s.top-1] != mark </span><span class="cov8" title="1">{
                s.top--
        }</span>
        <span class="cov8" title="1">if s.top == 0 </span><span class="cov8" title="1">{
                return make([]interface{}, 0), errors.New("unable to find mark")
        }</span>
        <span class="cov8" title="1">s.top--
        return s.stack[s.top+1 : start], nil</span>
}

func (s *unpickleState) readByte() (byte, error) <span class="cov8" title="1">{
        if s.dataOffset &gt;= len(s.data) </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">c := s.data[s.dataOffset]
        s.dataOffset++
        return c, nil</span>
}

func (s *unpickleState) readBytes(length int) ([]byte, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; length </span><span class="cov8" title="1">{
                return nil, io.EOF
        }</span>
        <span class="cov8" title="1">retval := s.data[s.dataOffset : s.dataOffset+length]
        s.dataOffset += length
        return retval, nil</span>
}

func (s *unpickleState) readString(delim byte) (string, error) <span class="cov8" title="1">{
        offset := bytes.IndexByte(s.data[s.dataOffset:], delim)
        if offset == -1 </span><span class="cov8" title="1">{
                return "", io.EOF
        }</span>
        <span class="cov8" title="1">retval := string(s.data[s.dataOffset : s.dataOffset+offset])
        s.dataOffset += offset + 1
        return retval, nil</span>
}

func (s *unpickleState) readFloat64() (float64, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; 8 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">v := binary.BigEndian.Uint64(s.data[s.dataOffset : s.dataOffset+8])
        s.dataOffset += 8
        return math.Float64frombits(v), nil</span>
}

func (s *unpickleState) readUint64() (uint64, error) <span class="cov0" title="0">{
        if len(s.data)-s.dataOffset &lt; 8 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">v := binary.LittleEndian.Uint64(s.data[s.dataOffset : s.dataOffset+8])
        s.dataOffset += 8
        return v, nil</span>
}

func (s *unpickleState) readUint32() (uint32, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; 4 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">v := binary.LittleEndian.Uint32(s.data[s.dataOffset : s.dataOffset+4])
        s.dataOffset += 4
        return v, nil</span>
}

func (s *unpickleState) readUint16() (uint16, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; 2 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">v := binary.LittleEndian.Uint16(s.data[s.dataOffset : s.dataOffset+2])
        s.dataOffset += 2
        return v, nil</span>
}

func (s *unpickleState) getMemo(m int) interface{} <span class="cov8" title="1">{
        for i, key := range s.memoKey </span><span class="cov8" title="1">{
                if key == m </span><span class="cov8" title="1">{
                        return s.memoVal[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *unpickleState) setMemo(i int, v interface{}) <span class="cov8" title="1">{
        s.memoKey = append(s.memoKey, i)
        s.memoVal = append(s.memoVal, v)
}</span>

func newState(initialSize int, data []byte) *unpickleState <span class="cov8" title="1">{
        return &amp;unpickleState{stack: make([]interface{}, initialSize), top: 0, data: data, dataOffset: 0}
}</span>

// attempt to convert python string representations to golang string
// basically this should return the same thing as eval(src) in python.
func pythonString(src string) (string, error) <span class="cov8" title="1">{
        if len(src) &lt; 2 || src[0] != src[len(src)-1] || (src[0] != '\'' &amp;&amp; src[0] != '"') </span><span class="cov8" title="1">{
                return "", errors.New("invalid syntax")
        }</span>
        <span class="cov8" title="1">quote := src[0]
        src = src[1 : len(src)-1]
        dst := []byte{'"'}
        backslashes := 0
        for _, c := range []byte(src) </span><span class="cov8" title="1">{
                switch c </span>{
                case '\\':<span class="cov8" title="1">
                        backslashes++
                        continue</span>
                case '"':<span class="cov8" title="1">
                        if quote == '\'' &amp;&amp; backslashes%2 == 0 </span><span class="cov8" title="1">{
                                backslashes++
                        }</span>
                case '\'':<span class="cov8" title="1">
                        if backslashes%2 == 1 </span><span class="cov8" title="1">{
                                backslashes--
                        }</span><span class="cov8" title="1"> else if quote == '\'' </span><span class="cov8" title="1">{
                                return "", errors.New("invalid syntax")
                        }</span>
                }
                <span class="cov8" title="1">for ; backslashes &gt; 0; backslashes-- </span><span class="cov8" title="1">{
                        dst = append(dst, '\\')
                }</span>
                <span class="cov8" title="1">dst = append(dst, c)</span>
        }
        <span class="cov8" title="1">for ; backslashes &gt; 0; backslashes-- </span><span class="cov8" title="1">{
                dst = append(dst, '\\')
        }</span>
        <span class="cov8" title="1">dst = append(dst, '"')
        return strconv.Unquote(string(dst))</span>
}

func mapKey(i interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch i := i.(type) </span>{
        case string, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64:<span class="cov8" title="1">
                return i, nil</span>
        case []interface{}:<span class="cov8" title="1">
                pt := PickleTuple{Len: len(i)}
                at := []*interface{}{&amp;pt.A, &amp;pt.B, &amp;pt.C, &amp;pt.D}
                for j, v := range i </span><span class="cov8" title="1">{
                        switch v.(type) </span>{
                        case string, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64:<span class="cov8" title="1">
                                *at[j] = v</span>
                        default:<span class="cov0" title="0">
                                return nil, errors.New("Unhashable tuple entry")</span>
                        }
                }
                <span class="cov8" title="1">return pt, nil</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("Invalid map key type")</span>
        }
}

func PickleLoads(data []byte) (interface{}, error) <span class="cov8" title="1">{
        state := newState(16, data)
        for op, err := state.readByte(); err == nil; op, err = state.readByte() </span><span class="cov8" title="1">{
                switch op </span>{
                case '\x80':<span class="cov8" title="1"> // PROTO
                        state.readByte()</span>
                case '(':<span class="cov8" title="1"> // MARK
                        state.setMark()</span>
                case '.':<span class="cov8" title="1"> // STOP
                        top, err := state.pop()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (STOP): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">return top, nil</span>
                case '0':<span class="cov8" title="1"> // POP
                        if _, err := state.pop(); err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (POP): " + err.Error())
                        }</span>
                case '1':<span class="cov8" title="1"> // POP_MARK
                        _, err := state.mark()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (SETITEMS): unable to find mark")
                        }</span>
                case '2':<span class="cov8" title="1"> // DUP
                        top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (POP): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(top)</span>
                case '\x88':<span class="cov8" title="1"> // NEWTRUE
                        state.push(true)</span>
                case '\x89':<span class="cov8" title="1"> // NEWFALSE
                        state.push(false)</span>
                case 'N':<span class="cov8" title="1"> // NONE
                        state.push(nil)</span>

                case 'S', 'V':<span class="cov8" title="1"> // STRING, UNICODE
                        val, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (STRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">str, err := pythonString(val)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Unable to interpret Python string (STRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(str)</span>
                case 'U':<span class="cov8" title="1"> //SHORT_BINSTRING
                        length, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (SHORT_BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">str, err := state.readBytes(int(length))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (SHORT_BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(string(str))</span>
                case 'T', 'X':<span class="cov8" title="1"> // BINUNICODE, BINSTRING
                        length, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">str, err := state.readBytes(int(length))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(string(str))</span>

                case 's':<span class="cov8" title="1"> // SETITEM
                        val, err1 := state.pop()
                        key, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (SETITEM): stack empty")
                        }</span>
                        <span class="cov8" title="1">if key, err = mapKey(key); err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (SETITEM): invalid key type")
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (SETITEM): stack empty")
                        }</span>
                        <span class="cov8" title="1">d, ok := top.(map[interface{}]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (SETITEM): stack top isn't a map")
                        }</span>
                        <span class="cov8" title="1">d[key] = val</span>
                case 'u':<span class="cov8" title="1"> // SETITEMS
                        vals, err := state.mark()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (SETITEMS): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">if len(vals)%2 != 0 </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (SETITEMS): odd numbered mark")
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (SETITEMS): stack empty")
                        }</span>
                        <span class="cov8" title="1">dict, ok := top.(map[interface{}]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (SETITEMS): stack top isn't a map")
                        }</span>
                        <span class="cov8" title="1">for j := 0; j &lt; len(vals); j += 2 </span><span class="cov8" title="1">{
                                if key, err := mapKey(vals[j]); err != nil </span><span class="cov8" title="1">{
                                        return nil, errors.New("Invalid pickle (SETITEMS): invalid key type")
                                }</span><span class="cov8" title="1"> else {
                                        dict[key] = vals[j+1]
                                }</span>
                        }

                case '}':<span class="cov8" title="1"> // EMPTY_DICT
                        state.push(make(map[interface{}]interface{}, 5))</span>
                case 'd':<span class="cov8" title="1"> // DICT
                        vals, err := state.mark()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (DICT): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">if len(vals)%2 != 0 </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (DICT): odd numbered mark")
                        }</span>
                        <span class="cov8" title="1">dict := make(map[interface{}]interface{}, len(vals)/2)
                        for j := 0; j &lt; len(vals); j += 2 </span><span class="cov8" title="1">{
                                if key, err := mapKey(vals[j]); err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (DICT): invalid key type")
                                }</span><span class="cov8" title="1"> else {
                                        dict[key] = vals[j+1]
                                }</span>
                        }
                        <span class="cov8" title="1">state.push(dict)</span>
                case ']', ')':<span class="cov8" title="1"> // EMPTY_LIST, EMPTY_TUPLE
                        state.push(make([]interface{}, 0))</span>
                case 'l', 't':<span class="cov8" title="1"> // LIST, TUPLE
                        markState, err := state.mark()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (LIST, TUPLE): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">newList := make([]interface{}, len(markState))
                        copy(newList, markState)
                        state.push(newList)</span>
                case 'a':<span class="cov8" title="1"> // APPEND
                        value, err1 := state.pop()
                        list, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (APPEND): stack empty")
                        }</span>
                        <span class="cov8" title="1">if list, ok := list.([]interface{}); !ok </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (APPEND): stack top not list")
                        }</span><span class="cov8" title="1"> else {
                                state.push(append(list, value))
                        }</span>
                case 'e':<span class="cov8" title="1"> // APPENDS
                        items, err := state.mark()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (APPENDS): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">top, err := state.pop()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (APPENDS): stack empty")
                        }</span>
                        <span class="cov8" title="1">l, ok := top.([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (APPENDS): stack top isn't a list")
                        }</span>
                        <span class="cov8" title="1">state.push(append(l, items...))</span>
                case '\x85':<span class="cov8" title="1"> // TUPLE1
                        top, err := state.pop()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (TUPLE1): stack empty")
                        }</span>
                        <span class="cov8" title="1">state.push([]interface{}{top})</span>
                case '\x86':<span class="cov8" title="1"> // TUPLE2
                        a, err1 := state.pop()
                        b, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (TUPLE2): stack empty")
                        }</span>
                        <span class="cov8" title="1">state.push([]interface{}{b, a})</span>
                case '\x87':<span class="cov8" title="1"> // TUPLE3
                        a, err1 := state.pop()
                        b, err2 := state.pop()
                        c, err3 := state.pop()
                        if err1 != nil || err2 != nil || err3 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (TUPLE3): stack empty")
                        }</span>
                        <span class="cov8" title="1">state.push([]interface{}{c, b, a})</span>

                case 'I', 'L':<span class="cov8" title="1"> // INT, LONG
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (INT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">val, err := strconv.ParseInt(line, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (INT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(val)</span>
                case 'F':<span class="cov8" title="1"> // FLOAT
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (FLOAT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">val, err := strconv.ParseFloat(line, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (FLOAT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(val)</span>
                case 'K':<span class="cov8" title="1"> // BININT1
                        val, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BININT1): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(int64(val))</span>
                case 'M':<span class="cov8" title="1"> // BININT2
                        val, err := state.readUint16()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BININT2): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(int64(val))</span>
                case 'J':<span class="cov8" title="1"> // BININT
                        val, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BININT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(int64(int32(val)))</span>
                case '\x8a':<span class="cov8" title="1"> // LONG1
                        length, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (LONG1): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">val := int64(0)
                        if length &gt; 0 </span><span class="cov8" title="1">{
                                valb, err := state.readBytes(int(length))
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, errors.New("Incomplete pickle (LONG1): " + err.Error())
                                }</span>
                                <span class="cov8" title="1">for i, d := range valb </span><span class="cov8" title="1">{
                                        val |= (int64(d) &lt;&lt; uint64(i*8))
                                }</span>
                                <span class="cov8" title="1">if valb[len(valb)-1] &gt;= '\x80' </span><span class="cov8" title="1">{
                                        val -= int64(1) &lt;&lt; uint64(length*8)
                                }</span>
                        }
                        <span class="cov8" title="1">state.push(val)</span>
                case 'G':<span class="cov8" title="1"> // BINFLOAT
                        val, err := state.readFloat64()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINFLOAT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(val)</span>

                case 'p':<span class="cov8" title="1"> // PUT
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">id, err := strconv.ParseInt(line, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.setMemo(int(id), top)</span>
                case 'g':<span class="cov8" title="1"> // GET
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (GET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">id, err := strconv.ParseInt(line, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (GET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(state.getMemo(int(id)))</span>
                case 'q':<span class="cov8" title="1"> // BINPUT
                        id, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINPUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.setMemo(int(id), top)</span>
                case 'h':<span class="cov8" title="1"> // BINGET
                        id, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINGET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(state.getMemo(int(id)))</span>
                case 'j':<span class="cov8" title="1"> // LONG_BINGET
                        id, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (LONG_BINGET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(state.getMemo(int(id)))</span>
                case 'r':<span class="cov8" title="1"> // LONG_BINPUT
                        id, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (LONG_BINPUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.setMemo(int(id), top)</span>
                case 'c':<span class="cov8" title="1"> // GLOBAL
                        module, err := state.readString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (GLOBAL): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">klass, err := state.readString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (GLOBAL): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(pickleGlobal{module + "." + klass})</span>
                case 'R':<span class="cov8" title="1"> // REDUCE
                        arg, err1 := state.pop()
                        c, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (REDUCE): stack empty")
                        }</span>
                        <span class="cov8" title="1">callable, valid := c.(pickleGlobal)
                        if !valid </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (REDUCE): non-callable on stack")
                        }</span>
                        // we'll just have to re-implement/fake python callables as the need arises.
                        <span class="cov8" title="1">switch callable.name </span>{
                        case "array.array":<span class="cov8" title="1">
                                as, valid := arg.([]interface{})
                                if !valid || len(as) != 2 </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): invalid array.array args")
                                }</span>
                                <span class="cov8" title="1">tc, ok1 := as[0].(string)
                                val, ok2 := as[1].([]interface{})
                                if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): invalid array.array args")
                                }</span>
                                <span class="cov8" title="1">state.push(PickleArray{Type: tc, Data: val})</span>
                        case "copy_reg._reconstructor":<span class="cov8" title="1">
                                // this is a pretty hackish way of loading a serialized swift.common.header_key_dict.HeaderKeyDict
                                // and probably any other python object that's just a wrapped dict.
                                a2, ok := arg.([]interface{})
                                if !ok || len(a2) != 3 </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): copy_reg._reconstructor with unknown arg")
                                }</span>
                                <span class="cov8" title="1">if c, ok := a2[1].(pickleGlobal); !ok || c.name != "__builtin__.dict" </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): unknown python object type in pickle")
                                }</span>
                                <span class="cov8" title="1">state.push(a2[2])</span>
                        default:<span class="cov0" title="0">
                                return nil, errors.New("Invalid pickle (REDUCE): unknown callable on stack")</span>
                        }
                default:<span class="cov8" title="1">
                        return nil, errors.New(fmt.Sprintf("Unknown pickle opcode: %c (%x)\n", op, op))</span>
                }
        }
        <span class="cov8" title="1">return nil, errors.New("Incomplete pickle: fell out of loop")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ring

import (
        "bufio"
        "crypto/md5"
        "encoding/binary"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
)

const (
        jsonFlag    = 2
        opGet       = byte(0x00)
        opSet       = byte(0x01)
        opDelete    = byte(0x04)
        opIncrement = byte(0x05)
        opDecrement = byte(0x06)
)

type MemcacheRing interface {
        Decr(key string, delta int64, timeout int) (int64, error)
        Delete(key string) error
        Get(key string) (interface{}, error)
        GetStructured(key string, val interface{}) error
        GetMulti(serverKey string, keys []string) (map[string]interface{}, error)
        Incr(key string, delta int64, timeout int) (int64, error)
        Set(key string, value interface{}, timeout int) error
        SetMulti(serverKey string, values map[string]interface{}, timeout int) error
}

type memcacheRing struct {
        ring                        map[string]string
        serverKeys                  []string
        servers                     map[string]*server
        connTimeout                 int64
        responseTimeout             int64
        maxFreeConnectionsPerServer int64
        tries                       int64
        nodeWeight                  int64
}

func NewMemcacheRing(confPath string) (*memcacheRing, error) <span class="cov0" title="0">{
        config, err := conf.LoadConfig(confPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unable to load conf file: %s", confPath)
        }</span>
        <span class="cov0" title="0">return NewMemcacheRingFromConfig(config)</span>
}

func NewMemcacheRingFromConfig(config conf.Config) (*memcacheRing, error) <span class="cov8" title="1">{
        ring := &amp;memcacheRing{}
        ring.ring = make(map[string]string)
        ring.serverKeys = make([]string, 0)
        ring.servers = make(map[string]*server)

        ring.maxFreeConnectionsPerServer = config.GetInt("memcache", "max_free_connections_per_server", 100)
        ring.connTimeout = config.GetInt("memcache", "conn_timeout", 100)
        ring.responseTimeout = config.GetInt("memcache", "response_timeout", 100)
        ring.nodeWeight = config.GetInt("memcache", "node_weight", 50)
        ring.tries = config.GetInt("memcache", "tries", 5)
        for _, s := range strings.Split(config.GetDefault("memcache", "memcache_servers", ""), ",") </span><span class="cov8" title="1">{
                err := ring.addServer(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(ring.servers) == 0 </span><span class="cov0" title="0">{
                ring.addServer("127.0.0.1:11211")
        }</span>
        <span class="cov8" title="1">ring.sortServerKeys()
        if int64(len(ring.servers)) &lt; ring.tries </span><span class="cov8" title="1">{
                ring.tries = int64(len(ring.servers))
        }</span>
        <span class="cov8" title="1">return ring, nil</span>
}

func hashKey(s string) string <span class="cov8" title="1">{
        h := md5.New()
        io.WriteString(h, s)
        return hex.EncodeToString(h.Sum(nil))
}</span>

func hashKeyToBytes(s string) []byte <span class="cov8" title="1">{
        h := md5.New()
        io.WriteString(h, s)
        buf := make([]byte, 32)
        hex.Encode(buf, h.Sum(nil))
        return buf
}</span>

func (ring *memcacheRing) addServer(serverString string) error <span class="cov8" title="1">{
        server, err := newServer(serverString, ring.connTimeout, ring.responseTimeout, ring.maxFreeConnectionsPerServer)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ring.servers[serverString] = server
        for i := 0; int64(i) &lt; ring.nodeWeight; i++ </span><span class="cov8" title="1">{
                ring.ring[hashKey(fmt.Sprintf("%s-%d", serverString, i))] = serverString
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ring *memcacheRing) sortServerKeys() <span class="cov8" title="1">{
        ring.serverKeys = make([]string, 0)
        for k := range ring.ring </span><span class="cov8" title="1">{
                ring.serverKeys = append(ring.serverKeys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(ring.serverKeys)</span>
}

func (ring *memcacheRing) Decr(key string, delta int64, timeout int) (int64, error) <span class="cov8" title="1">{
        return ring.Incr(key, -delta, timeout)
}</span>

func (ring *memcacheRing) Delete(key string) error <span class="cov8" title="1">{
        fn := func(conn *connection) error </span><span class="cov8" title="1">{
                _, _, err := conn.roundTripPacket(opDelete, hashKeyToBytes(key), nil, nil)
                if err != nil &amp;&amp; err != CacheMiss </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return ring.loop(key, fn)</span>
}

func (ring *memcacheRing) GetStructured(key string, val interface{}) error <span class="cov0" title="0">{
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                value, extras, err := conn.roundTripPacket(opGet, hashKeyToBytes(key), nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags := binary.BigEndian.Uint32(extras[0:4])
                if flags&amp;jsonFlag == 0 </span><span class="cov0" title="0">{
                        return errors.New("Not json data")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(value, val); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return ring.loop(key, fn)</span>
}

func (ring *memcacheRing) Get(key string) (interface{}, error) <span class="cov8" title="1">{
        type Return struct {
                value interface{}
        }
        ret := &amp;Return{}
        fn := func(conn *connection) error </span><span class="cov8" title="1">{
                value, extras, err := conn.roundTripPacket(opGet, hashKeyToBytes(key), nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">flags := binary.BigEndian.Uint32(extras[0:4])
                if flags&amp;jsonFlag != 0 </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(value, &amp;ret.value); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }<span class="cov0" title="0"> else {
                        ret.value = value
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return ret.value, ring.loop(key, fn)</span>
}

func (ring *memcacheRing) GetMulti(serverKey string, keys []string) (map[string]interface{}, error) <span class="cov8" title="1">{
        type Return struct {
                value map[string]interface{}
        }
        ret := &amp;Return{}
        fn := func(conn *connection) error </span><span class="cov8" title="1">{
                ret.value = make(map[string]interface{})
                for _, key := range keys </span><span class="cov8" title="1">{
                        if err := conn.sendPacket(opGet, hashKeyToBytes(key), nil, nil); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                        value, extras, err := conn.receivePacket()
                        if err != nil </span><span class="cov0" title="0">{
                                if err == CacheMiss </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov8" title="1">flags := binary.BigEndian.Uint32(extras[0:4])
                        if flags&amp;jsonFlag != 0 </span><span class="cov8" title="1">{
                                var v interface{}
                                if err := json.Unmarshal(value, &amp;v); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">ret.value[key] = v</span>
                        }<span class="cov0" title="0"> else {
                                ret.value[key] = value
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return ret.value, ring.loop(serverKey, fn)</span>
}

func (ring *memcacheRing) Incr(key string, delta int64, timeout int) (int64, error) <span class="cov8" title="1">{
        type Return struct {
                value int64
        }
        ret := &amp;Return{}
        op := opIncrement
        dfl := delta
        if delta &lt; 0 </span><span class="cov8" title="1">{
                op = opDecrement
                delta = 0 - delta
                dfl = 0
        }</span>
        <span class="cov8" title="1">extras := make([]byte, 20)
        binary.BigEndian.PutUint64(extras[0:8], uint64(delta))
        binary.BigEndian.PutUint64(extras[8:16], uint64(dfl))
        binary.BigEndian.PutUint32(extras[16:20], uint32(timeout))
        fn := func(conn *connection) error </span><span class="cov8" title="1">{
                value, _, err := conn.roundTripPacket(op, hashKeyToBytes(key), nil, extras)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ret.value = int64(binary.BigEndian.Uint64(value[0:8]))
                return nil</span>
        }
        <span class="cov8" title="1">return ret.value, ring.loop(key, fn)</span>
}

func (ring *memcacheRing) Set(key string, value interface{}, timeout int) error <span class="cov8" title="1">{
        serl, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">extras := make([]byte, 8)
        binary.BigEndian.PutUint32(extras[0:4], uint32(jsonFlag))
        binary.BigEndian.PutUint32(extras[4:8], uint32(timeout))
        fn := func(conn *connection) error </span><span class="cov8" title="1">{
                _, _, err = conn.roundTripPacket(opSet, hashKeyToBytes(key), serl, extras)
                return err
        }</span>
        <span class="cov8" title="1">return ring.loop(key, fn)</span>
}

func (ring *memcacheRing) SetMulti(serverKey string, values map[string]interface{}, timeout int) error <span class="cov8" title="1">{
        fn := func(conn *connection) error </span><span class="cov8" title="1">{
                for key, value := range values </span><span class="cov8" title="1">{
                        serl, err := json.Marshal(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">extras := make([]byte, 8)
                        binary.BigEndian.PutUint32(extras[0:4], uint32(jsonFlag))
                        binary.BigEndian.PutUint32(extras[4:8], uint32(timeout))
                        if err = conn.sendPacket(opSet, hashKeyToBytes(key), serl, extras); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">for range values </span><span class="cov8" title="1">{
                        if _, _, err := conn.receivePacket(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return ring.loop(serverKey, fn)</span>
}

type serverIterator struct {
        ring    *memcacheRing
        key     string
        current int
        servers []string
}

func (ring *memcacheRing) newServerIterator(key string) *serverIterator <span class="cov8" title="1">{
        return &amp;serverIterator{ring, hashKey(key), -1, make([]string, 0)}
}</span>

func (it *serverIterator) next() bool <span class="cov8" title="1">{
        return int64(len(it.servers)) &lt; it.ring.tries
}</span>

func (it *serverIterator) value() *server <span class="cov8" title="1">{
        if int64(len(it.servers)) &gt; it.ring.tries </span><span class="cov0" title="0">{
                panic("serverIterator.Value() called when there are no more tries left")</span>
        }
        <span class="cov8" title="1">if it.current == -1 </span><span class="cov8" title="1">{
                it.current = sort.SearchStrings(it.ring.serverKeys, it.key) % len(it.ring.serverKeys)
        }</span><span class="cov8" title="1"> else {
                for common.StringInSlice(it.ring.ring[it.ring.serverKeys[it.current]], it.servers) </span><span class="cov8" title="1">{
                        it.current = (it.current + 1) % len(it.ring.serverKeys)
                }</span>
        }
        <span class="cov8" title="1">serverString := it.ring.ring[it.ring.serverKeys[it.current]]
        it.servers = append(it.servers, serverString)
        return it.ring.servers[serverString]</span>
}

func (ring *memcacheRing) loop(key string, fn func(*connection) error) error <span class="cov8" title="1">{
        it := ring.newServerIterator(key)
        for it.next() </span><span class="cov8" title="1">{
                server := it.value()
                conn, err := server.getConnection()
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">err = fn(conn)
                server.releaseConnection(conn, err)
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span><span class="cov8" title="1"> else if err == CacheMiss </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("Operation failed")</span>
}

type server struct {
        serverString       string
        addr               net.Addr
        lock               sync.Mutex
        connTimeout        time.Duration
        requestTimeout     time.Duration
        maxFreeConnections int64
        connections        []*connection
}

func newServer(serverString string, connTimeout int64, requestTimeout int64, maxFreeConnections int64) (*server, error) <span class="cov8" title="1">{
        var addr net.Addr
        var err error
        s := server{serverString: serverString}
        if strings.Contains(serverString, "/") </span><span class="cov8" title="1">{
                addr, err = net.ResolveUnixAddr("unix", serverString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }<span class="cov0" title="0"> else {
                if !strings.Contains(serverString, ":") </span><span class="cov0" title="0">{
                        serverString = fmt.Sprintf("%s:11211", serverString)
                }</span>
                <span class="cov0" title="0">addr, err = net.ResolveTCPAddr("tcp", serverString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">s.addr = addr
        s.connTimeout = time.Duration(connTimeout) * time.Millisecond
        s.requestTimeout = time.Duration(requestTimeout) * time.Millisecond
        s.maxFreeConnections = maxFreeConnections
        s.connections = make([]*connection, 0)
        return &amp;s, nil</span>
}

func (s *server) connectionCount() uint64 <span class="cov8" title="1">{
        return uint64(len(s.connections))
}</span>

func (s *server) getExistingConnection() *connection <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()
        if len(s.connections) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">conn := s.connections[len(s.connections)-1]
        s.connections = s.connections[:len(s.connections)-1]
        return conn</span>
}

func (s *server) getConnection() (*connection, error) <span class="cov8" title="1">{
        conn := s.getExistingConnection()
        if conn != nil </span><span class="cov8" title="1">{
                return conn, nil
        }</span>
        <span class="cov8" title="1">return newConnection(s.serverString, s.connTimeout, s.requestTimeout)</span>
}

func (s *server) releaseConnection(conn *connection, err error) <span class="cov8" title="1">{
        if err == nil || err != Disconnected </span><span class="cov8" title="1">{
                s.lock.Lock()
                defer s.lock.Unlock()
                if int64(len(s.connections)) &lt; s.maxFreeConnections </span><span class="cov8" title="1">{
                        s.connections = append(s.connections, conn)
                        return
                }</span>
        }
        <span class="cov8" title="1">conn.close()</span>
}

var (
        Disconnected = fmt.Errorf("Disconnected from memcache server")
        CacheMiss    = fmt.Errorf("Server cache miss")
)

type connection struct {
        conn       net.Conn
        rw         *bufio.ReadWriter
        reqTimeout time.Duration
        packetBuf  []byte
}

func newConnection(address string, connTimeout time.Duration, requestTimeout time.Duration) (*connection, error) <span class="cov8" title="1">{
        domain := "tcp"
        if strings.Contains(address, "/") </span><span class="cov8" title="1">{
                domain = "unix"
        }</span><span class="cov0" title="0"> else if !strings.Contains(address, ":") </span><span class="cov0" title="0">{
                address = fmt.Sprintf("%s:%d", address, 11211)
        }</span>
        <span class="cov8" title="1">conn, err := net.DialTimeout(domain, address, connTimeout)
        if err != nil </span><span class="cov8" title="1">{
                return nil, Disconnected
        }</span>
        <span class="cov8" title="1">if c, ok := conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                c.SetNoDelay(true)
        }</span>
        <span class="cov8" title="1">return &amp;connection{
                conn:       conn,
                rw:         bufio.NewReadWriter(bufio.NewReader(conn), bufio.NewWriter(conn)),
                reqTimeout: requestTimeout,
                packetBuf:  make([]byte, 256),
        }, nil</span>
}

func (c *connection) close() error <span class="cov8" title="1">{
        return c.conn.Close()
}</span>

func (c *connection) receivePacket() ([]byte, []byte, error) <span class="cov8" title="1">{
        packet := c.packetBuf[0:24]
        if bytes, err := c.rw.Read(packet); err != nil || bytes != 24 </span><span class="cov0" title="0">{
                c.close()
                return nil, nil, Disconnected
        }</span>
        <span class="cov8" title="1">keyLen := binary.BigEndian.Uint16(packet[2:4])
        extrasLen := packet[4]
        status := binary.BigEndian.Uint16(packet[6:8])
        bodyLen := int(binary.BigEndian.Uint32(packet[8:12]))
        for cap(c.packetBuf) &lt; bodyLen </span><span class="cov0" title="0">{
                c.packetBuf = append(c.packetBuf, ' ')
        }</span>
        <span class="cov8" title="1">body := c.packetBuf[0:bodyLen]
        if bytes, err := c.rw.Read(body); err != nil || bytes != bodyLen </span><span class="cov0" title="0">{
                c.close()
                return nil, nil, Disconnected
        }</span>
        <span class="cov8" title="1">switch status </span>{
        case 0:<span class="cov8" title="1">
                return body[int(keyLen)+int(extrasLen) : int(bodyLen)], body[int(keyLen):int(extrasLen)], nil</span>
        case 1:<span class="cov8" title="1">
                return nil, nil, CacheMiss</span>
        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("Error response from memcache: %d", status)</span>
        }
}

func (c *connection) roundTripPacket(opcode byte, key []byte, value []byte, extras []byte) ([]byte, []byte, error) <span class="cov8" title="1">{
        if err := c.sendPacket(opcode, key, value, extras); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return c.receivePacket()</span>
}

func (c *connection) sendPacket(opcode byte, key []byte, value []byte, extras []byte) error <span class="cov8" title="1">{
        c.conn.SetDeadline(time.Now().Add(c.reqTimeout))
        packet := c.packetBuf[0:24]
        packet[0], packet[1], packet[4], packet[5] = 0x80, opcode, byte(len(extras)), 0
        binary.BigEndian.PutUint16(packet[2:4], uint16(len(key)))
        packet[6], packet[7] = 0, 0
        binary.BigEndian.PutUint32(packet[8:12], uint32(len(key)+len(value)+len(extras)))
        packet[12], packet[13], packet[14], packet[15] = 0, 0, 0, 0
        packet[16], packet[17], packet[18], packet[19], packet[20], packet[21], packet[22], packet[23] = 0, 0, 0, 0, 0, 0, 0, 0
        packet = append(append(append(packet, extras...), key...), value...)
        if _, err := c.rw.Write(packet); err != nil || c.rw.Flush() != nil </span><span class="cov0" title="0">{
                c.close()
                return Disconnected
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ring

import (
        "compress/gzip"
        "crypto/md5"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math/rand"
        "net"
        "os"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

const reloadTime = 15 * time.Second

type Ring interface {
        GetNodes(partition uint64) (response []*Device)
        GetNodesInOrder(partition uint64) (response []*Device)
        GetJobNodes(partition uint64, localDevice int) (response []*Device, handoff bool)
        GetPartition(account string, container string, object string) uint64
        LocalDevices(localPort int) (devs []*Device, err error)
        AllDevices() (devs []Device)
        GetMoreNodes(partition uint64) MoreNodes
        ReplicaCount() (cnt uint64)
        PartitionCount() (cnt uint64)
}

type MoreNodes interface {
        Next() *Device
}

type Device struct {
        Id              int     `json:"id"`
        Device          string  `json:"device"`
        Ip              string  `json:"ip"`
        Meta            string  `json:"meta"`
        Port            int     `json:"port"`
        Region          int     `json:"region"`
        ReplicationIp   string  `json:"replication_ip"`
        ReplicationPort int     `json:"replication_port"`
        Weight          float64 `json:"weight"`
        Zone            int     `json:"zone"`
}

type ringData struct {
        Devs                                []Device `json:"devs"`
        ReplicaCount                        int      `json:"replica_count"`
        PartShift                           uint64   `json:"part_shift"`
        replica2part2devId                  [][]uint16
        regionCount, zoneCount, ipPortCount int
}

type hashRing struct {
        data   atomic.Value
        path   string
        prefix string
        suffix string
        mtime  time.Time
}

type regionZone struct {
        region, zone int
}

type ipPort struct {
        region, zone, port int
        ip                 string
}

type hashMoreNodes struct {
        r                 *hashRing
        used, sameRegions map[int]bool
        sameZones         map[regionZone]bool
        sameIpPorts       map[ipPort]bool
        parts, start, inc int
        partition         uint64
}

func (d *Device) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Device{Id: %d, Device: %s, Ip: %s, Port: %d}", d.Id, d.Device, d.Ip, d.Port)
}</span>

func (r *hashRing) getData() *ringData <span class="cov8" title="1">{
        return r.data.Load().(*ringData)
}</span>

func (r *hashRing) GetNodes(partition uint64) (response []*Device) <span class="cov8" title="1">{
        response = r.GetNodesInOrder(partition)
        for i := range response </span><span class="cov8" title="1">{
                j := rand.Intn(i + 1)
                response[i], response[j] = response[j], response[i]
        }</span>
        <span class="cov8" title="1">return response</span>
}

func (r *hashRing) GetNodesInOrder(partition uint64) (response []*Device) <span class="cov8" title="1">{
        d := r.getData()
        if partition &gt;= uint64(len(d.replica2part2devId[0])) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; d.ReplicaCount; i++ </span><span class="cov8" title="1">{
                response = append(response, &amp;d.Devs[d.replica2part2devId[i][partition]])
        }</span>
        <span class="cov8" title="1">return response</span>
}

func (r *hashRing) GetJobNodes(partition uint64, localDevice int) (response []*Device, handoff bool) <span class="cov8" title="1">{
        d := r.getData()
        handoff = true
        if partition &gt;= uint64(len(d.replica2part2devId[0])) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; d.ReplicaCount; i++ </span><span class="cov8" title="1">{
                dev := &amp;d.Devs[d.replica2part2devId[i][partition]]
                if dev.Id == localDevice </span><span class="cov8" title="1">{
                        handoff = false
                }</span><span class="cov8" title="1"> else {
                        response = append(response, dev)
                }</span>
        }
        <span class="cov8" title="1">return response, handoff</span>
}

func (r *hashRing) GetPartition(account string, container string, object string) uint64 <span class="cov0" title="0">{
        d := r.getData()
        hash := md5.New()
        hash.Write([]byte(r.prefix + "/" + account))
        if container != "" </span><span class="cov0" title="0">{
                hash.Write([]byte("/" + container))
                if object != "" </span><span class="cov0" title="0">{
                        hash.Write([]byte("/" + object))
                }</span>
        }
        <span class="cov0" title="0">hash.Write([]byte(r.suffix))
        digest := hash.Sum(nil)
        // treat as big endian unsigned int
        val := uint64(digest[0])&lt;&lt;24 | uint64(digest[1])&lt;&lt;16 | uint64(digest[2])&lt;&lt;8 | uint64(digest[3])
        return val &gt;&gt; d.PartShift</span>
}

func (r *hashRing) LocalDevices(localPort int) (devs []*Device, err error) <span class="cov0" title="0">{
        d := r.getData()
        var localIPs = make(map[string]bool)

        localAddrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, addr := range localAddrs </span><span class="cov0" title="0">{
                localIPs[strings.Split(addr.String(), "/")[0]] = true
        }</span>

        <span class="cov0" title="0">for i, dev := range d.Devs </span><span class="cov0" title="0">{
                if localIPs[dev.ReplicationIp] &amp;&amp; dev.ReplicationPort == localPort </span><span class="cov0" title="0">{
                        devs = append(devs, &amp;d.Devs[i])
                }</span>
        }
        <span class="cov0" title="0">return devs, nil</span>
}

func (r *hashRing) AllDevices() (devs []Device) <span class="cov0" title="0">{
        d := r.getData()
        return d.Devs
}</span>

func (r *hashRing) GetMoreNodes(partition uint64) MoreNodes <span class="cov0" title="0">{
        return &amp;hashMoreNodes{r: r, partition: partition, used: nil}
}</span>

func (r *hashRing) ReplicaCount() (cnt uint64) <span class="cov8" title="1">{
        d := r.getData()
        return uint64(len(d.replica2part2devId))
}</span>

func (r *hashRing) PartitionCount() (cnt uint64) <span class="cov8" title="1">{
        d := r.getData()
        return uint64(len(d.replica2part2devId[0]))
}</span>

func (r *hashRing) reload() error <span class="cov8" title="1">{
        fi, err := os.Stat(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if fi.ModTime() == r.mtime </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">fp, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">gz, err := gzip.NewReader(fp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">magicBuf := make([]byte, 4)
        io.ReadFull(gz, magicBuf)
        if string(magicBuf) != "R1NG" </span><span class="cov0" title="0">{
                return errors.New("Bad magic string")
        }</span>
        <span class="cov8" title="1">var ringVersion uint16
        binary.Read(gz, binary.BigEndian, &amp;ringVersion)
        if ringVersion != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("Unknown ring version %d", ringVersion)
        }</span>
        <span class="cov8" title="1">var json_len uint32
        binary.Read(gz, binary.BigEndian, &amp;json_len)
        jsonBuf := make([]byte, json_len)
        io.ReadFull(gz, jsonBuf)
        data := &amp;ringData{}
        if err := json.Unmarshal(jsonBuf, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">partitionCount := 1 &lt;&lt; (32 - data.PartShift)
        for i := 0; i &lt; data.ReplicaCount; i++ </span><span class="cov8" title="1">{
                part2dev := make([]uint16, partitionCount)
                binary.Read(gz, binary.LittleEndian, &amp;part2dev)
                data.replica2part2devId = append(data.replica2part2devId, part2dev)
        }</span>
        <span class="cov8" title="1">regionCount := make(map[int]bool)
        zoneCount := make(map[regionZone]bool)
        ipPortCount := make(map[ipPort]bool)
        for _, d := range data.Devs </span><span class="cov8" title="1">{
                regionCount[d.Region] = true
                zoneCount[regionZone{d.Region, d.Zone}] = true
                ipPortCount[ipPort{d.Region, d.Zone, d.Port, d.Ip}] = true
        }</span>
        <span class="cov8" title="1">data.regionCount = len(regionCount)
        data.zoneCount = len(zoneCount)
        data.ipPortCount = len(ipPortCount)
        r.mtime = fi.ModTime()
        r.data.Store(data)
        return nil</span>
}

func (r *hashRing) reloader() error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                time.Sleep(reloadTime)
                r.reload()
        }</span>
}

func (m *hashMoreNodes) addDevice(d *Device) <span class="cov0" title="0">{
        m.used[d.Id] = true
        m.sameRegions[d.Region] = true
        m.sameZones[regionZone{d.Region, d.Zone}] = true
        m.sameIpPorts[ipPort{d.Region, d.Zone, d.Port, d.Ip}] = true
}</span>

func (m *hashMoreNodes) initialize() <span class="cov0" title="0">{
        d := m.r.getData()
        m.parts = len(d.replica2part2devId[0])
        m.used = make(map[int]bool)
        m.sameRegions = make(map[int]bool)
        m.sameZones = make(map[regionZone]bool)
        m.sameIpPorts = make(map[ipPort]bool)
        for _, mp := range d.replica2part2devId </span><span class="cov0" title="0">{
                m.addDevice(&amp;d.Devs[mp[m.partition]])
        }</span>
        <span class="cov0" title="0">hash := md5.New()
        hash.Write([]byte(strconv.FormatUint(m.partition, 10)))
        digest := hash.Sum(nil)
        m.start = int((uint64(digest[0])&lt;&lt;24 | uint64(digest[1])&lt;&lt;16 | uint64(digest[2])&lt;&lt;8 | uint64(digest[3])) &gt;&gt; d.PartShift)
        m.inc = m.parts / 65536
        if m.inc == 0 </span><span class="cov0" title="0">{
                m.inc = 1
        }</span>
}

func (m *hashMoreNodes) Next() *Device <span class="cov0" title="0">{
        d := m.r.getData()
        if m.used == nil </span><span class="cov0" title="0">{
                m.initialize()
        }</span>
        <span class="cov0" title="0">var check func(d *Device) bool
        if len(m.sameRegions) &lt; d.regionCount </span><span class="cov0" title="0">{
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.sameRegions[d.Region] }</span>
        }<span class="cov0" title="0"> else if len(m.sameZones) &lt; d.zoneCount </span><span class="cov0" title="0">{
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.sameZones[regionZone{d.Region, d.Zone}] }</span>
        }<span class="cov0" title="0"> else if len(m.sameIpPorts) &lt; d.ipPortCount </span><span class="cov0" title="0">{
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.sameIpPorts[ipPort{d.Region, d.Zone, d.Port, d.Ip}] }</span>
        }<span class="cov0" title="0"> else {
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.used[d.Id] }</span>
        }
        <span class="cov0" title="0">for i := 0; i &lt; m.parts; i += m.inc </span><span class="cov0" title="0">{
                handoffPart := (i + m.start) % m.parts
                for _, part2devId := range d.replica2part2devId </span><span class="cov0" title="0">{
                        if handoffPart &lt; len(part2devId) </span><span class="cov0" title="0">{
                                if check(&amp;d.Devs[part2devId[handoffPart]]) </span><span class="cov0" title="0">{
                                        m.addDevice(&amp;d.Devs[part2devId[handoffPart]])
                                        return &amp;d.Devs[part2devId[handoffPart]]
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

var loadedRingsLock sync.Mutex
var loadedRings map[string]*hashRing = make(map[string]*hashRing)

func LoadRing(path string, prefix string, suffix string) (Ring, error) <span class="cov8" title="1">{
        loadedRingsLock.Lock()
        defer loadedRingsLock.Unlock()
        ring := loadedRings[path]
        if ring == nil </span><span class="cov8" title="1">{
                ring = &amp;hashRing{prefix: prefix, suffix: suffix, path: path, mtime: time.Unix(0, 0)}
                if err := ring.reload(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">go ring.reloader()
                loadedRings[path] = ring</span>
        }
        <span class="cov8" title="1">return ring, nil</span>
}

// GetRing returns the current ring given the ring_type ("account", "container", "object"),
// hash path prefix, and hash path suffix. An error is raised if the requested ring does
// not exist.
func GetRing(ringType, prefix, suffix string, policy int) (Ring, error) <span class="cov0" title="0">{
        var ring Ring
        var err error
        ringFile := fmt.Sprintf("%s.ring.gz", ringType)
        if policy != 0 </span><span class="cov0" title="0">{
                ringFile = fmt.Sprintf("%s-%d.ring.gz", ringType, policy)
        }</span>
        <span class="cov0" title="0">if ring, err = LoadRing(fmt.Sprintf("/etc/hummingbird/%s", ringFile), prefix, suffix); err != nil </span><span class="cov0" title="0">{
                if ring, err = LoadRing(fmt.Sprintf("/etc/swift/%s", ringFile), prefix, suffix); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error loading %s:%d ring", ringType, policy)
                }</span>
        }
        <span class="cov0" title="0">return ring, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package srv

import (
        "context"
        "net/http"
)

type KeyType int

const logkey KeyType = iota

func GetLogger(r *http.Request) LowLevelLogger <span class="cov8" title="1">{
        if rv := r.Context().Value(logkey); rv != nil </span><span class="cov8" title="1">{
                return rv.(LowLevelLogger)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func SetLogger(r *http.Request, l LowLevelLogger) *http.Request <span class="cov8" title="1">{
        return r.WithContext(context.WithValue(r.Context(), logkey, l))
}</span>

func GetVars(r *http.Request) map[string]string <span class="cov8" title="1">{
        if rv := r.Context().Value("vars"); rv != nil </span><span class="cov8" title="1">{
                return rv.(map[string]string)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func SetVars(r *http.Request, v map[string]string) *http.Request <span class="cov8" title="1">{
        return r.WithContext(context.WithValue(r.Context(), "vars", v))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package srv

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/troubling/hummingbird/common"
)

type variable struct {
        name string
        pos  int
}

type matcher struct {
        method       string
        length       int
        hasCatchall  bool
        endSlash     bool
        catchallName string
        vars         []variable
        static       []variable
        policy       int
        handler      http.Handler
}

type router struct {
        matchers                []*matcher
        NotFoundHandler         http.Handler
        MethodNotAllowedHandler http.Handler
}

const anyPolicy = -1

// Split a string in twain on sep.  Doing it this way over strings.Split*() saves allocating a slice.
func Split2(path string, sep string) (string, string) <span class="cov8" title="1">{
        if nextSlash := strings.Index(path, sep); nextSlash == -1 </span><span class="cov8" title="1">{
                return path, ""
        }</span><span class="cov8" title="1"> else {
                return path[:nextSlash], path[nextSlash+1:]
        }</span>
}

// Given a method and path, return the handler and vars that should be used to serve them.
func (r *router) route(method, path string, policy int) (http.Handler, map[string]string) <span class="cov8" title="1">{
        methodFound := false
        path = path[1:]
        slashCount := strings.Count(path, "/")
        // This code is slightly gnarly because it avoids allocating anything until it's sure of a match.
NEXTMATCH:
        for _, m := range r.matchers </span><span class="cov8" title="1">{
                if m.policy != anyPolicy &amp;&amp; m.policy != policy </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if m.method != method </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">methodFound = true
                if !m.hasCatchall &amp;&amp; len(path) != 0 &amp;&amp; m.endSlash != (path[len(path)-1] == '/') </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if slashCount+1 == m.length || (m.hasCatchall &amp;&amp; slashCount+1 &gt; m.length) </span><span class="cov8" title="1">{
                        var vars map[string]string

                        // make sure all static parts of the route match the pattern
                        j := 0
                        part, tmppath := Split2(path, "/")
                        for _, s := range m.static </span><span class="cov8" title="1">{
                                for ; j &lt; s.pos; j++ </span><span class="cov8" title="1">{
                                        part, tmppath = Split2(tmppath, "/")
                                }</span>
                                <span class="cov8" title="1">if s.name != part </span><span class="cov8" title="1">{
                                        continue NEXTMATCH</span>
                                }
                        }

                        // if there's a catchall, grab it from the end of the path.
                        <span class="cov8" title="1">if m.hasCatchall </span><span class="cov8" title="1">{
                                tmppath = path
                                for i := 0; i &lt; m.length-1; i++ </span><span class="cov8" title="1">{
                                        _, tmppath = Split2(tmppath, "/")
                                }</span>
                                <span class="cov8" title="1">if tmppath == "" </span><span class="cov8" title="1">{
                                        continue NEXTMATCH</span>
                                }
                                <span class="cov8" title="1">vars = map[string]string{m.catchallName: tmppath}</span>
                        }<span class="cov8" title="1"> else {
                                vars = make(map[string]string, len(m.vars))
                        }</span>

                        // extract any vars
                        <span class="cov8" title="1">j = 0
                        part, tmppath = Split2(path, "/")
                        for _, s := range m.vars </span><span class="cov8" title="1">{
                                for ; j &lt; s.pos; j++ </span><span class="cov8" title="1">{
                                        part, tmppath = Split2(tmppath, "/")
                                }</span>
                                <span class="cov8" title="1">vars[s.name] = part</span>
                        }
                        <span class="cov8" title="1">return m.handler, vars</span>
                }
        }
        <span class="cov8" title="1">if !methodFound </span><span class="cov8" title="1">{
                return r.MethodNotAllowedHandler, nil
        }</span>
        <span class="cov8" title="1">return r.NotFoundHandler, nil</span>
}

// HandlePolicy registers a handler for the given method, pattern, and policy header.
// The pattern is pretty much what you're used to, i.e. /static/:variable/*catchall
func (r *router) HandlePolicy(method, pattern string, policy int, handler http.Handler) <span class="cov8" title="1">{
        m := &amp;matcher{method: method, policy: policy}
        parts := strings.Split(pattern[1:], "/")
        m.length = len(parts)
        if pattern[len(pattern)-1] == '/' </span><span class="cov8" title="1">{
                m.endSlash = true
        }</span>
        <span class="cov8" title="1">for i, v := range parts </span><span class="cov8" title="1">{
                if len(v) &gt; 0 &amp;&amp; v[0] == ':' </span><span class="cov8" title="1">{
                        m.vars = append(m.vars, variable{v[1:], i})
                }</span><span class="cov8" title="1"> else if len(v) &gt; 0 &amp;&amp; v[0] == '*' </span><span class="cov8" title="1">{
                        m.catchallName = v[1:]
                        m.hasCatchall = true
                }</span><span class="cov8" title="1"> else {
                        m.static = append(m.static, variable{v, i})
                }</span>
        }
        <span class="cov8" title="1">m.handler = handler
        r.matchers = append(r.matchers, m)</span>
}

// Handle registers a handler for the given method and pattern.
// The pattern is pretty much what you're used to, i.e. /static/:variable/*catchall
func (r *router) Handle(method, pattern string, handler http.Handler) <span class="cov8" title="1">{
        r.HandlePolicy(method, pattern, anyPolicy, handler)
}</span>

func (r *router) Get(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("GET", path, handler)
}</span>

func (r *router) Put(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("PUT", path, handler)
}</span>

func (r *router) Head(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("HEAD", path, handler)
}</span>

func (r *router) Delete(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("DELETE", path, handler)
}</span>

func (r *router) Replicate(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("REPLICATE", path, handler)
}</span>

func (r *router) Sync(path string, handler http.Handler) <span class="cov0" title="0">{
        r.Handle("SYNC", path, handler)
}</span>

func (r *router) Post(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("POST", path, handler)
}</span>

func (r *router) Options(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("OPTIONS", path, handler)
}</span>

func (r *router) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        policy, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policy = 0
        }</span>
        <span class="cov8" title="1">handler, vars := r.route(request.Method, request.URL.Path, policy)
        request = SetVars(request, vars)
        handler.ServeHTTP(writer, request)</span>
}
func routerNotFound(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if pm, err := common.ParseProxyPath(r.URL.Path); err == nil &amp;&amp; pm["account"] == "" </span><span class="cov0" title="0">{
                SimpleErrorResponse(w, http.StatusPreconditionFailed, "Bad URL")
        }</span><span class="cov0" title="0"> else {
                SimpleErrorResponse(w, http.StatusNotFound, "")
        }</span>
}

func NewRouter() *router <span class="cov8" title="1">{
        return &amp;router{
                NotFoundHandler:         http.HandlerFunc(routerNotFound),
                MethodNotAllowedHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{ http.Error(w, "Method Not Allowed", 405) }</span>),
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package srv

import (
        "bufio"
        "context"
        "errors"
        "flag"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"
        "unicode/utf8"

        "github.com/troubling/hummingbird/common/conf"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var responseTemplate = "&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;"

var responseBodies = map[int]string{
        100: "",
        200: "",
        201: "",
        202: fmt.Sprintf(responseTemplate, "Accepted", "The request is accepted for processing."),
        204: "",
        206: "",
        301: fmt.Sprintf(responseTemplate, "Moved Permanently", "The resource has moved permanently."),
        302: fmt.Sprintf(responseTemplate, "Found", "The resource has moved temporarily."),
        303: fmt.Sprintf(responseTemplate, "See Other", "The response to the request can be found under a different URI."),
        304: "",
        307: fmt.Sprintf(responseTemplate, "Temporary Redirect", "The resource has moved temporarily."),
        400: fmt.Sprintf(responseTemplate, "Bad Request", "The server could not comply with the request since it is either malformed or otherwise incorrect."),
        401: fmt.Sprintf(responseTemplate, "Unauthorized", "This server could not verify that you are authorized to access the document you requested."),
        402: fmt.Sprintf(responseTemplate, "Payment Required", "Access was denied for financial reasons."),
        403: fmt.Sprintf(responseTemplate, "Forbidden", "Access was denied to this resource."),
        404: fmt.Sprintf(responseTemplate, "Not Found", "The resource could not be found."),
        405: fmt.Sprintf(responseTemplate, "Method Not Allowed", "The method is not allowed for this resource."),
        406: fmt.Sprintf(responseTemplate, "Not Acceptable", "The resource is not available in a format acceptable to your browser."),
        408: fmt.Sprintf(responseTemplate, "Request Timeout", "The server has waited too long for the request to be sent by the client."),
        409: fmt.Sprintf(responseTemplate, "Conflict", "There was a conflict when trying to complete your request."),
        410: fmt.Sprintf(responseTemplate, "Gone", "This resource is no longer available."),
        411: fmt.Sprintf(responseTemplate, "Length Required", "Content-Length header required."),
        412: "",
        413: fmt.Sprintf(responseTemplate, "Request Entity Too Large", "The body of your request was too large for this server."),
        414: fmt.Sprintf(responseTemplate, "Request URI Too Long", "The request URI was too long for this server."),
        415: fmt.Sprintf(responseTemplate, "Unsupported Media Type", "The request media type is not supported by this server."),
        416: fmt.Sprintf(responseTemplate, "Requested Range Not Satisfiable", "The Range requested is not available."),
        417: fmt.Sprintf(responseTemplate, "Expectation Failed", "Expectation failed."),
        422: fmt.Sprintf(responseTemplate, "Unprocessable Entity", "Unable to process the contained instructions"),
        498: fmt.Sprintf(responseTemplate, "Ratelimited", "The client is sending too many requests and should slow down."),
        499: fmt.Sprintf(responseTemplate, "Client Disconnect", "The client was disconnected during request."),
        500: fmt.Sprintf(responseTemplate, "Internal Error", "The server has either erred or is incapable of performing the requested operation."),
        501: fmt.Sprintf(responseTemplate, "Not Implemented", "The requested method is not implemented by this server."),
        502: fmt.Sprintf(responseTemplate, "Bad Gateway", "Bad gateway."),
        503: fmt.Sprintf(responseTemplate, "Service Unavailable", "The server is currently unavailable. Please try again at a later time."),
        504: fmt.Sprintf(responseTemplate, "Gateway Timeout", "A timeout has occurred speaking to a backend server."),
}

type customWriter struct {
        http.ResponseWriter
        f func(w http.ResponseWriter, status int) int
}

func (w *customWriter) WriteHeader(status int) <span class="cov8" title="1">{
        w.ResponseWriter.WriteHeader(w.f(w.ResponseWriter, status))
}</span>

// NewCustomWriter creates an http.ResponseWriter wrapper that calls your function on WriteHeader.
func NewCustomWriter(w http.ResponseWriter, f func(w http.ResponseWriter, status int) int) http.ResponseWriter <span class="cov8" title="1">{
        return &amp;customWriter{ResponseWriter: w, f: f}
}</span>

// ResponseWriter that saves its status - used for logging.

type WebWriter struct {
        http.ResponseWriter
        Status          int
        ResponseStarted bool
}

func (w *WebWriter) WriteHeader(status int) <span class="cov8" title="1">{
        w.Status = status
        w.ResponseStarted = true
        w.ResponseWriter.WriteHeader(status)
}</span>

func (w WebWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov8" title="1">{
        return w.ResponseWriter.(http.Hijacker).Hijack()
}</span>

func (w *WebWriter) Response() (bool, int) <span class="cov0" title="0">{
        return w.ResponseStarted, w.Status
}</span>

func CopyResponseHeaders(w http.ResponseWriter, src *http.Response) <span class="cov0" title="0">{
        for key := range src.Header </span><span class="cov0" title="0">{
                w.Header().Set(key, src.Header.Get(key))
        }</span>
}

func StandardResponse(w http.ResponseWriter, statusCode int) <span class="cov8" title="1">{
        body := responseBodies[statusCode]
        w.Header().Set("Content-Type", "text/html; charset=UTF-8")
        w.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
        w.WriteHeader(statusCode)
        w.Write([]byte(body))
}</span>

func SimpleErrorResponse(w http.ResponseWriter, statusCode int, body string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/html; charset=UTF-8")
        w.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
        w.WriteHeader(statusCode)
        w.Write([]byte(body))
}</span>

func CustomErrorResponse(w http.ResponseWriter, statusCode int, vars map[string]string) <span class="cov0" title="0">{
        body := ""
        switch statusCode </span>{
        case 507:<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/html; charset=UTF-8")
                if vars["Method"] != "HEAD" </span><span class="cov0" title="0">{
                        body = fmt.Sprintf("&lt;html&gt;&lt;h1&gt;Insufficient Storage&lt;/h1&gt;&lt;p&gt;There was not enough space to save the resource. Drive: %s&lt;/p&gt;&lt;/html&gt;", vars["device"])
                }</span>
        }
        <span class="cov0" title="0">w.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
        w.WriteHeader(statusCode)
        w.Write([]byte(body))</span>
}

func CopyRequestHeaders(r *http.Request, dst *http.Request) <span class="cov0" title="0">{
        for key := range r.Header </span><span class="cov0" title="0">{
                dst.Header.Set(key, r.Header.Get(key))
        }</span>
}

type WebWriterInterface interface {
        http.ResponseWriter
        Response() (bool, int)
}

func ValidateRequest(w http.ResponseWriter, r *http.Request) bool <span class="cov8" title="1">{
        // if invalid request will right own response and return false, otherwise true
        if !utf8.ValidString(r.URL.Path) || strings.Contains(r.URL.Path, "\x00") </span><span class="cov0" title="0">{
                SimpleErrorResponse(w, 412, "Invalid UTF8 or contains NULL")
                return false
        }</span>
        <span class="cov8" title="1">if !utf8.ValidString(r.Header.Get("Content-Type")) || strings.Contains(r.Header.Get("Content-Type"), "\x00") </span><span class="cov0" title="0">{
                SimpleErrorResponse(w, 400, "Invalid UTF8 or contains NULL")
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

type LowLevelLogger interface {
        Error(msg string, fields ...zapcore.Field)
        Info(msg string, fields ...zapcore.Field)
        Debug(msg string, fields ...zapcore.Field)
        With(fields ...zapcore.Field) *zap.Logger
}

func LogPanics(logger LowLevelLogger, msg string) <span class="cov8" title="1">{
        if e := recover(); e != nil </span><span class="cov0" title="0">{
                recoveredMsg := fmt.Sprintf("PANIC (%s)", msg)
                logger.Error(recoveredMsg, zap.Any("err", e))
        }</span>
}

// SetupLogger configures structured logging using uber's zap library.
func SetupLogger(prefix string, atomicLevel *zap.AtomicLevel, flags *flag.FlagSet) (LowLevelLogger, error) <span class="cov8" title="1">{
        productionConfig := zap.NewProductionConfig()
        productionConfig.Level = *atomicLevel
        if lFlag := flags.Lookup("l"); lFlag != nil &amp;&amp; lFlag.Value.(flag.Getter).Get().(string) != "" </span><span class="cov0" title="0">{
                productionConfig.OutputPaths = []string{lFlag.Value.(flag.Getter).Get().(string)}
        }</span><span class="cov8" title="1"> else {
                productionConfig.OutputPaths = []string{"stdout"}
        }</span>
        <span class="cov8" title="1">if eFlag := flags.Lookup("e"); eFlag != nil &amp;&amp; eFlag.Value.(flag.Getter).Get().(string) != "" </span><span class="cov0" title="0">{
                productionConfig.ErrorOutputPaths = []string{eFlag.Value.(flag.Getter).Get().(string)}
        }</span><span class="cov8" title="1"> else {
                productionConfig.ErrorOutputPaths = []string{"stderr"}
        }</span>
        <span class="cov8" title="1">baseLogger, err := productionConfig.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unable to create logger: %v", err)
        }</span>
        <span class="cov8" title="1">logger := baseLogger.With(zap.String("name", prefix))
        return logger, nil</span>
}

/* http.Server that knows how to shut down gracefully */

type HummingbirdServer struct {
        http.Server
        Listener net.Listener
        logger   LowLevelLogger
        finalize func()
}

func RetryListen(ip string, port int) (net.Listener, error) <span class="cov0" title="0">{
        address := fmt.Sprintf("%s:%d", ip, port)
        started := time.Now()
        for </span><span class="cov0" title="0">{
                if sock, err := net.Listen("tcp", address); err == nil </span><span class="cov0" title="0">{
                        return sock, nil
                }</span><span class="cov0" title="0"> else if time.Now().Sub(started) &gt; 10*time.Second </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("Failed to bind for 10 seconds (%v)", err))
                }</span>
                <span class="cov0" title="0">time.Sleep(time.Second / 5)</span>
        }
}

func DumpGoroutinesStackTrace(pid int) <span class="cov0" title="0">{
        filename := filepath.Join("/tmp", strconv.Itoa(pid)+".dump")
        buf := make([]byte, 1&lt;&lt;20)
        for </span><span class="cov0" title="0">{
                n := runtime.Stack(buf, true)
                if n &lt; len(buf) </span><span class="cov0" title="0">{
                        buf = buf[:n]
                        break</span>
                }
                <span class="cov0" title="0">buf = make([]byte, 2*len(buf))</span>
        }
        <span class="cov0" title="0">ioutil.WriteFile(filename, buf, 0644)</span>
}

type Server interface {
        GetHandler(conf.Config) http.Handler
        Finalize() // This is called before stoping gracefully so that a server can clean up before closing
}

func RunServers(GetServer func(conf.Config, *flag.FlagSet) (string, int, Server, LowLevelLogger, error), flags *flag.FlagSet) <span class="cov0" title="0">{
        var servers []*HummingbirdServer

        if flags.NArg() != 0 </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>
        <span class="cov0" title="0">configFile := flags.Lookup("c").Value.(flag.Getter).Get().(string)
        configs, err := conf.LoadConfigs(configFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error finding configs: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">for _, config := range configs </span><span class="cov0" title="0">{
                ip, port, server, logger, err := GetServer(config, flags)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "%v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">sock, err := RetryListen(ip, port)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error listening: %v\n", err)
                        logger.Error("Error listening", zap.Error(err))
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">srv := HummingbirdServer{
                        Server: http.Server{
                                Handler:      server.GetHandler(config),
                                ReadTimeout:  24 * time.Hour,
                                WriteTimeout: 24 * time.Hour,
                        },
                        Listener: sock,
                        logger:   logger,
                        finalize: server.Finalize,
                }
                go srv.Serve(sock)
                servers = append(servers, &amp;srv)
                logger.Info("Server started", zap.Int("port", port))</span>
        }

        <span class="cov0" title="0">if len(servers) &gt; 0 </span><span class="cov0" title="0">{
                c := make(chan os.Signal, 1)
                signal.Notify(c, syscall.SIGHUP, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGABRT)
                s := &lt;-c
                switch s </span>{
                case syscall.SIGTERM, syscall.SIGHUP:<span class="cov0" title="0"> // graceful shutdown
                        var wg sync.WaitGroup
                        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*5)
                        defer cancel()
                        for _, srv := range servers </span><span class="cov0" title="0">{
                                // Shutdown the HTTP server
                                wg.Add(1)
                                go func(hserv *HummingbirdServer) </span><span class="cov0" title="0">{
                                        defer wg.Done()
                                        if err := hserv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                                // failure/timeout shutting down the server gracefully
                                                hserv.logger.Error("Error with graceful shutdown", zap.Error(err))
                                        }</span>
                                        // Wait for any async processes to quit
                                        <span class="cov0" title="0">hserv.finalize()</span>
                                }(srv)
                        }
                        // Wait for everything to complete
                        <span class="cov0" title="0">wgc := make(chan struct{})
                        go func() </span><span class="cov0" title="0">{
                                defer close(wgc)
                                wg.Wait()
                        }</span>()
                        <span class="cov0" title="0">select </span>{
                        case &lt;-wgc:<span class="cov0" title="0">
                                // Everything has completed
                                fmt.Println("Graceful shutdown complete.")
                                return</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Timeout before everything completing
                                fmt.Println("Forcing shutdown after timeout.")
                                return</span>
                        }
                case syscall.SIGABRT, syscall.SIGQUIT:<span class="cov0" title="0"> // drop a traceback
                        pid := os.Getpid()
                        DumpGoroutinesStackTrace(pid)</span>
                default:<span class="cov0" title="0">
                        for _, srv := range servers </span><span class="cov0" title="0">{
                                if err := srv.Close(); err != nil </span><span class="cov0" title="0">{
                                        srv.logger.Error("Error shutdown", zap.Error(err))
                                }</span>
                        }
                }
        }
}

type Daemon interface {
        Run()
        RunForever()
}

func RunDaemon(GetDaemon func(conf.Config, *flag.FlagSet) (Daemon, LowLevelLogger, error), flags *flag.FlagSet) <span class="cov0" title="0">{
        var daemons []Daemon

        if flags.NArg() != 0 </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>

        <span class="cov0" title="0">configFile := flags.Lookup("c").Value.(flag.Getter).Get().(string)
        configs, err := conf.LoadConfigs(configFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error finding configs: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">once := flags.Lookup("once").Value.(flag.Getter).Get() == true

        for _, config := range configs </span><span class="cov0" title="0">{
                if daemon, logger, err := GetDaemon(config, flags); err == nil </span><span class="cov0" title="0">{
                        if once </span><span class="cov0" title="0">{
                                daemon.Run()
                                fmt.Fprintf(os.Stderr, "Daemon pass completed.\n")
                                logger.Error("Daemon pass completed.")
                        }</span><span class="cov0" title="0"> else {
                                daemons = append(daemons, daemon)
                                go daemon.RunForever()
                                fmt.Fprintf(os.Stderr, "Daemon started.\n")
                                logger.Error("Daemon started.")
                        }</span>
                }<span class="cov0" title="0"> else {
                        fmt.Fprintf(os.Stderr, "Failed to create daemon: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if len(daemons) &gt; 0 </span><span class="cov0" title="0">{
                c := make(chan os.Signal, 1)
                signal.Notify(c, syscall.SIGHUP, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGABRT)
                switch &lt;-c </span>{
                case syscall.SIGABRT, syscall.SIGQUIT:<span class="cov0" title="0"> // drop a traceback
                        pid := os.Getpid()
                        DumpGoroutinesStackTrace(pid)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package test

import (
        "bytes"
        "encoding/json"
        "net/http"

        "github.com/troubling/hummingbird/common/ring"
)

// a place for utility functions and interface satisifiers that are used across tests

type CaptureResponse struct {
        Status int
        header http.Header
        Body   *bytes.Buffer
}

func (w *CaptureResponse) WriteHeader(status int) <span class="cov8" title="1">{
        w.Status = status
}</span>

func (w *CaptureResponse) Header() http.Header <span class="cov8" title="1">{
        return w.header
}</span>

func (w *CaptureResponse) Write(b []byte) (int, error) <span class="cov8" title="1">{
        return w.Body.Write(b)
}</span>

func MakeCaptureResponse() *CaptureResponse <span class="cov8" title="1">{
        return &amp;CaptureResponse{
                Status: 0,
                header: make(http.Header),
                Body:   new(bytes.Buffer),
        }
}</span>

// FakeRing
type FakeRing struct {
        // Overrides for function returns
        MockLocalDevices       []*ring.Device
        MockGetJobNodes        []*ring.Device
        MockGetJobNodesHandoff bool
        MockGetMoreNodes       ring.MoreNodes

        // Used for probe
        MockMoreNodes *ring.Device
        MockDevices   []*ring.Device
}

func (r *FakeRing) GetNodes(partition uint64) (response []*ring.Device) <span class="cov0" title="0">{
        if len(r.MockDevices) &gt; 0 </span><span class="cov0" title="0">{
                return r.MockDevices[0:3]
        }</span><span class="cov0" title="0"> else {
                return nil
        }</span>
}

func (r *FakeRing) GetNodesInOrder(partition uint64) (response []*ring.Device) <span class="cov0" title="0">{
        return r.GetNodes(partition)
}</span>

func (r *FakeRing) GetJobNodes(partition uint64, localDevice int) (response []*ring.Device, handoff bool) <span class="cov8" title="1">{
        if len(r.MockDevices) &gt; 0 </span><span class="cov8" title="1">{
                switch localDevice </span>{
                case 0:<span class="cov8" title="1">
                        return []*ring.Device{r.MockDevices[1], r.MockDevices[2]}, false</span>
                case 1:<span class="cov8" title="1">
                        return []*ring.Device{r.MockDevices[0], r.MockDevices[2]}, false</span>
                case 2:<span class="cov0" title="0">
                        return []*ring.Device{r.MockDevices[0], r.MockDevices[1]}, false</span>
                default:<span class="cov8" title="1">
                        return r.MockDevices[0:3], true</span>
                }
        }<span class="cov8" title="1"> else if len(r.MockGetJobNodes) &gt; 0 </span><span class="cov8" title="1">{
                return r.MockGetJobNodes, r.MockGetJobNodesHandoff
        }</span><span class="cov8" title="1"> else {
                return []*ring.Device{
                        {Device: "sda", ReplicationIp: "127.0.0.1", ReplicationPort: 20000},
                        {Device: "sdb", ReplicationIp: "127.0.0.2", ReplicationPort: 2000},
                }, r.MockGetJobNodesHandoff
        }</span>
}

func (r *FakeRing) GetPartition(account string, container string, object string) uint64 <span class="cov8" title="1">{
        return 0
}</span>

func (r *FakeRing) LocalDevices(localPort int) (devs []*ring.Device, err error) <span class="cov8" title="1">{
        if len(r.MockDevices) &gt; 0 </span><span class="cov8" title="1">{
                for _, d := range r.MockDevices </span><span class="cov8" title="1">{
                        if d.ReplicationPort == localPort </span><span class="cov8" title="1">{
                                return []*ring.Device{d}, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, nil</span>
        }<span class="cov8" title="1"> else if len(r.MockLocalDevices) &gt; 0 </span><span class="cov8" title="1">{
                return r.MockLocalDevices, nil
        }</span><span class="cov0" title="0"> else {
                return nil, nil
        }</span>
}

func (r *FakeRing) AllDevices() (devs []ring.Device) <span class="cov0" title="0">{
        return nil
}</span>

func (r *FakeRing) GetMoreNodes(partition uint64) ring.MoreNodes <span class="cov8" title="1">{
        if r.MockMoreNodes != nil </span><span class="cov8" title="1">{
                return &amp;fakeMoreNodes{r.MockMoreNodes}
        }</span><span class="cov8" title="1"> else if r.MockGetMoreNodes != nil </span><span class="cov8" title="1">{
                return r.MockGetMoreNodes
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *FakeRing) PartitionCount() uint64 <span class="cov0" title="0">{
        return 1
}</span>

func (r *FakeRing) ReplicaCount() uint64 <span class="cov0" title="0">{
        return 3
}</span>

type fakeMoreNodes struct {
        dev *ring.Device
}

func (m *fakeMoreNodes) Next() *ring.Device <span class="cov8" title="1">{
        return m.dev
}</span>

// Fake MemcacheRing
type FakeMemcacheRing struct {
        MockIncrResults   []int64
        MockIncrKeys      []string
        MockSetValues     []interface{}
        MockGetStructured map[string][]byte
}

func (mr *FakeMemcacheRing) Decr(key string, delta int64, timeout int) (int64, error) <span class="cov0" title="0">{
        return int64(0), nil
}</span>

func (mr *FakeMemcacheRing) Delete(key string) error <span class="cov0" title="0">{
        return nil
}</span>

func (mr *FakeMemcacheRing) Get(key string) (interface{}, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (mr *FakeMemcacheRing) GetStructured(key string, val interface{}) error <span class="cov8" title="1">{
        if v, ok := mr.MockGetStructured[key]; ok </span><span class="cov8" title="1">{
                json.Unmarshal(v, val)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (mr *FakeMemcacheRing) GetMulti(serverKey string, keys []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (mr *FakeMemcacheRing) Incr(key string, delta int64, timeout int) (int64, error) <span class="cov8" title="1">{
        mr.MockIncrKeys = append(mr.MockIncrKeys, key)
        if len(mr.MockIncrResults) &gt; 0 </span><span class="cov8" title="1">{
                res := mr.MockIncrResults[0] + delta
                mr.MockIncrResults = mr.MockIncrResults[1:]
                return res, nil
        }</span>
        <span class="cov0" title="0">return int64(0), nil</span>
}

func (mr *FakeMemcacheRing) Set(key string, value interface{}, timeout int) error <span class="cov8" title="1">{
        mr.MockSetValues = append(mr.MockSetValues, value)
        return nil
}</span>

func (mr *FakeMemcacheRing) SetMulti(serverKey string, values map[string]interface{}, timeout int) error <span class="cov0" title="0">{
        return nil
}</span>

type MockResponseWriter struct {
        SaveHeader *http.Header
        StatusMap  map[string]int
}

func (m MockResponseWriter) Header() (h http.Header) <span class="cov8" title="1">{
        if m.SaveHeader == nil </span><span class="cov0" title="0">{
                return http.Header{}
        }</span>
        <span class="cov8" title="1">return *m.SaveHeader</span>
}

func (m MockResponseWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        return len(p), nil
}</span>

func (m MockResponseWriter) WriteString(s string) (n int, err error) <span class="cov0" title="0">{
        return len(s), nil
}</span>

func (m MockResponseWriter) WriteHeader(s int) <span class="cov8" title="1">{
        if m.StatusMap != nil </span><span class="cov8" title="1">{
                m.StatusMap["S"] = s
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package common

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math/rand"
        "mime"
        "net/http"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/cactus/go-statsd-client/statsd"
)

const ONE_WEEK = 604800

type HttpRange struct {
        Start, End int64
}

var GMT = time.FixedZone("GMT", 0)

var urlSafeMap = [256]bool{'A': true, 'B': true, 'C': true, 'D': true, 'E': true, 'F': true,
        'G': true, 'H': true, 'I': true, 'J': true, 'K': true, 'L': true, 'M': true, 'N': true,
        'O': true, 'P': true, 'Q': true, 'R': true, 'S': true, 'T': true, 'U': true, 'V': true,
        'W': true, 'X': true, 'Y': true, 'Z': true, 'a': true, 'b': true, 'c': true, 'd': true,
        'e': true, 'f': true, 'g': true, 'h': true, 'i': true, 'j': true, 'k': true, 'l': true,
        'm': true, 'n': true, 'o': true, 'p': true, 'q': true, 'r': true, 's': true, 't': true,
        'u': true, 'v': true, 'w': true, 'x': true, 'y': true, 'z': true, '0': true, '1': true,
        '2': true, '3': true, '4': true, '5': true, '6': true, '7': true, '8': true, '9': true,
        '_': true, '.': true, '-': true, '/': true,
}

func Urlencode(str string) string <span class="cov8" title="1">{
        // output matches python's urllib.quote()

        finalSize := len(str)
        for i := 0; i &lt; len(str); i++ </span><span class="cov8" title="1">{
                if !urlSafeMap[str[i]] </span><span class="cov8" title="1">{
                        finalSize += 2
                }</span>
        }
        <span class="cov8" title="1">if finalSize == len(str) </span><span class="cov8" title="1">{
                return str
        }</span>
        <span class="cov8" title="1">buf := make([]byte, finalSize)
        j := 0
        for i := 0; i &lt; len(str); i++ </span><span class="cov8" title="1">{
                if urlSafeMap[str[i]] </span><span class="cov8" title="1">{
                        buf[j] = str[i]
                        j++
                }</span><span class="cov8" title="1"> else {
                        buf[j] = '%'
                        buf[j+1] = "0123456789ABCDEF"[str[i]&gt;&gt;4]
                        buf[j+2] = "0123456789ABCDEF"[str[i]&amp;15]
                        j += 3
                }</span>
        }
        <span class="cov8" title="1">return string(buf)</span>
}

func ParseDate(date string) (time.Time, error) <span class="cov8" title="1">{
        if date == "" </span><span class="cov8" title="1">{
                return time.Now(), errors.New("invalid time")
        }</span>
        <span class="cov8" title="1">if timestamp, err := strconv.ParseFloat(date, 64); err == nil </span><span class="cov8" title="1">{
                nans := int64((timestamp - float64(int64(timestamp))) * 1.0e9)
                return time.Unix(int64(timestamp), nans).In(GMT), nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC1123, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC1123Z, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.ANSIC, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC850, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC3339, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if strings.Contains(date, "_") </span><span class="cov0" title="0">{
                allDateParts := strings.Split(date, "_")
                return ParseDate(allDateParts[0])
        }</span>
        <span class="cov8" title="1">return time.Now(), errors.New("invalid time")</span>
}

func CanonicalTimestamp(t float64) string <span class="cov8" title="1">{
        ret := strconv.FormatFloat(t, 'f', 5, 64)
        for len(ret) &lt; 16 </span><span class="cov8" title="1">{
                ret = "0" + ret
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func LooksTrue(check string) bool <span class="cov8" title="1">{
        check = strings.TrimSpace(strings.ToLower(check))
        return check == "true" || check == "yes" || check == "1" || check == "on" || check == "t" || check == "y"
}</span>

func UUID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", rand.Int63n(0xffffffff), rand.Int63n(0xffff), rand.Int63n(0xffff), rand.Int63n(0xffff), rand.Int63n(0xffffffffffff))
}</span>

func GetTimestamp() string <span class="cov8" title="1">{
        return CanonicalTimestamp(float64(time.Now().UnixNano()) / 1000000000.0)
}</span>

func FormatLastModified(lastModified time.Time) string <span class="cov8" title="1">{
        if lastModified.Nanosecond() &gt; 0 </span><span class="cov8" title="1">{ // for some reason, Last-Modified is ceil(X-Timestamp)
                lastModified = lastModified.Truncate(time.Second).Add(time.Second)
        }</span>
        <span class="cov8" title="1">return lastModified.In(GMT).Format(time.RFC1123)</span>
}

func GetTransactionId() string <span class="cov0" title="0">{
        return fmt.Sprintf("%x", time.Now().UnixNano())
}</span>

func HeaderGetDefault(h http.Header, key string, dfl string) string <span class="cov0" title="0">{
        val := h.Get(key)
        if val == "" </span><span class="cov0" title="0">{
                return dfl
        }</span>
        <span class="cov0" title="0">return val</span>
}

func ParseRange(rangeHeader string, fileSize int64) (reqRanges []HttpRange, err error) <span class="cov8" title="1">{
        rangeHeader = strings.Replace(strings.ToLower(rangeHeader), " ", "", -1)
        if !strings.HasPrefix(rangeHeader, "bytes=") </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">rangeHeader = rangeHeader[6:]
        rangeStrings := strings.Split(rangeHeader, ",")
        if len(rangeStrings) &gt; 100 </span><span class="cov8" title="1">{
                return nil, errors.New("Too many ranges")
        }</span>
        <span class="cov8" title="1">if len(rangeStrings) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">for _, rng := range rangeStrings </span><span class="cov8" title="1">{
                var start, end int64
                var err error
                startend := strings.Split(rng, "-")
                if len(startend) != 2 || (startend[0] == "" &amp;&amp; startend[1] == "") </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">if start, err = strconv.ParseInt(startend[0], 0, 64); err != nil &amp;&amp; startend[0] != "" </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">if end, err = strconv.ParseInt(startend[1], 0, 64); err != nil &amp;&amp; startend[1] != "" </span><span class="cov8" title="1">{
                        return nil, nil
                }</span><span class="cov8" title="1"> else if startend[1] != "" &amp;&amp; end &lt; start </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">if startend[0] == "" </span><span class="cov8" title="1">{
                        if end == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }<span class="cov8" title="1"> else if end &gt; fileSize </span><span class="cov8" title="1">{
                                reqRanges = append(reqRanges, HttpRange{0, fileSize})
                        }</span><span class="cov8" title="1"> else {
                                reqRanges = append(reqRanges, HttpRange{fileSize - end, fileSize})
                        }</span>
                }<span class="cov8" title="1"> else if startend[1] == "" </span><span class="cov8" title="1">{
                        if start &lt; fileSize </span><span class="cov8" title="1">{
                                reqRanges = append(reqRanges, HttpRange{start, fileSize})
                        }</span><span class="cov8" title="1"> else {
                                continue</span>
                        }
                }<span class="cov8" title="1"> else if start &lt; fileSize </span><span class="cov8" title="1">{
                        if end+1 &lt; fileSize </span><span class="cov8" title="1">{
                                reqRanges = append(reqRanges, HttpRange{start, end + 1})
                        }</span><span class="cov8" title="1"> else {
                                reqRanges = append(reqRanges, HttpRange{start, fileSize})
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(reqRanges) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("Unsatisfiable range")
        }</span>
        <span class="cov8" title="1">return reqRanges, nil</span>
}

func GetEpochFromTimestamp(timestamp string) (string, error) <span class="cov8" title="1">{
        split_timestamp := strings.Split(timestamp, "_")
        floatTimestamp, err := strconv.ParseFloat(split_timestamp[0], 64)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New(fmt.Sprintf("Could not parse float from '%s'.", split_timestamp[0]))
        }</span>
        <span class="cov8" title="1">return CanonicalTimestamp(floatTimestamp), nil</span>
}

func StandardizeTimestamp(timestamp string) (string, error) <span class="cov8" title="1">{
        offset := strings.Contains(timestamp, "_")
        if offset </span><span class="cov8" title="1">{
                split_timestamp := strings.Split(timestamp, "_")
                floatTimestamp, err := strconv.ParseFloat(split_timestamp[0], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("Could not parse float from '%s'.", split_timestamp[0]))
                }</span>
                <span class="cov8" title="1">intOffset, err := strconv.ParseInt(split_timestamp[1], 16, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return "", errors.New(fmt.Sprintf("Could not parse int from '%s'.", split_timestamp[1]))
                }</span>

                <span class="cov8" title="1">split_timestamp[0] = CanonicalTimestamp(floatTimestamp)
                split_timestamp[1] = fmt.Sprintf("%016x", intOffset)
                timestamp = strings.Join(split_timestamp, "_")</span>
        }<span class="cov8" title="1"> else {
                floatTimestamp, err := strconv.ParseFloat(timestamp, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return "", errors.New(fmt.Sprintf("Could not parse float from '%s'.", timestamp))
                }</span>
                <span class="cov8" title="1">timestamp = CanonicalTimestamp(floatTimestamp)</span>
        }
        <span class="cov8" title="1">return timestamp, nil</span>
}

// will split out url path the proxy would receive and return map
// with keys: "vrs", "account", "container", "object"
func ParseProxyPath(path string) (pathMap map[string]string, err error) <span class="cov8" title="1">{
        pathParts := []string{"", "vrs", "account", "container", "object"}
        pathSplit := strings.SplitN(path, "/", 5)
        if pathSplit[0] != "" </span><span class="cov8" title="1">{
                return nil, errors.New(fmt.Sprintf("Invalid path: %s", path))
        }</span>
        <span class="cov8" title="1">pathMap = map[string]string{}
        for i := 1; i &lt; len(pathParts); i++ </span><span class="cov8" title="1">{
                if len(pathSplit) &lt;= i </span><span class="cov8" title="1">{
                        pathMap[pathParts[i]] = ""
                }</span><span class="cov8" title="1"> else {
                        if pathSplit[i] == "" &amp;&amp; len(pathSplit)-1 != i </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("Invalid path: %s", path))
                        }</span>
                        <span class="cov8" title="1">pathMap[pathParts[i]] = pathSplit[i]</span>
                }
        }
        <span class="cov8" title="1">return pathMap, err</span>
}

var buf64kpool = NewFreePool(128)

func Copy(src io.Reader, dsts ...io.Writer) (written int64, err error) <span class="cov8" title="1">{
        var buf []byte
        var ok bool
        if buf, ok = buf64kpool.Get().([]byte); !ok </span><span class="cov8" title="1">{
                buf = make([]byte, 64*1024)
        }</span>
        <span class="cov8" title="1">written, err = io.CopyBuffer(io.MultiWriter(dsts...), src, buf)
        buf64kpool.Put(buf)
        return</span>
}

func CopyN(src io.Reader, n int64, dsts ...io.Writer) (written int64, err error) <span class="cov8" title="1">{
        written, err = Copy(io.LimitReader(src, n), dsts...)
        if written == n </span><span class="cov8" title="1">{
                return n, nil
        }</span>
        <span class="cov0" title="0">if written &lt; n &amp;&amp; err == nil </span><span class="cov0" title="0">{
                err = io.EOF
        }</span>
        <span class="cov0" title="0">return</span>
}

func GetDefault(h http.Header, key string, dfl string) string <span class="cov8" title="1">{
        val := h.Get(key)
        if val == "" </span><span class="cov8" title="1">{
                return dfl
        }</span>
        <span class="cov8" title="1">return val</span>
}

// More like a map of semaphores.  I don't know what to call it.
type KeyedLimit struct {
        limitPerKey int64
        totalLimit  int64
        lock        sync.Mutex
        locked      map[string]bool
        inUse       map[string]int64
        totalUse    int64
}

func (k *KeyedLimit) Acquire(key string, force bool) int64 <span class="cov8" title="1">{
        // returns 0 if Acquire is successful, otherwise the number of requests inUse by disk or -1 if disk is locked
        k.lock.Lock()
        if k.locked[key] </span><span class="cov0" title="0">{
                k.lock.Unlock()
                return -1
        }</span><span class="cov8" title="1"> else if v := k.inUse[key]; !force &amp;&amp; ((k.limitPerKey &gt; 0 &amp;&amp; v &gt;= k.limitPerKey) || (k.totalLimit &gt; 0 &amp;&amp; k.totalUse &gt; k.totalLimit)) </span><span class="cov8" title="1">{
                k.lock.Unlock()
                return v
        }</span><span class="cov8" title="1"> else {
                k.inUse[key] += 1
                k.totalUse += 1
                k.lock.Unlock()
                return 0
        }</span>
}

func (k *KeyedLimit) Release(key string) <span class="cov8" title="1">{
        k.lock.Lock()
        k.inUse[key] -= 1
        k.totalUse -= 1
        k.lock.Unlock()
}</span>

func (k *KeyedLimit) Lock(key string) <span class="cov0" title="0">{
        k.lock.Lock()
        k.locked[key] = true
        k.lock.Unlock()
}</span>

func (k *KeyedLimit) Unlock(key string) <span class="cov0" title="0">{
        k.lock.Lock()
        k.locked[key] = false
        k.lock.Unlock()
}</span>

func (k *KeyedLimit) Keys() []string <span class="cov0" title="0">{
        k.lock.Lock()
        keys := make([]string, len(k.inUse))
        i := 0
        for key := range k.inUse </span><span class="cov0" title="0">{
                keys[i] = key
                i += 1
        }</span>
        <span class="cov0" title="0">k.lock.Unlock()
        return keys</span>
}

func (k *KeyedLimit) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        k.lock.Lock()
        data, err := json.Marshal(k.inUse)
        k.lock.Unlock()
        return data, err
}</span>

func NewKeyedLimit(limitPerKey int64, totalLimit int64) *KeyedLimit <span class="cov8" title="1">{
        return &amp;KeyedLimit{limitPerKey: limitPerKey, totalLimit: totalLimit, locked: make(map[string]bool), inUse: make(map[string]int64)}
}</span>

func CollectRuntimeMetrics(statsdHost string, statsdPort, statsdPause int64, prefix string) <span class="cov0" title="0">{
        address := fmt.Sprintf("%s:%d", statsdHost, statsdPort)
        client, err := statsd.NewClient(address, prefix)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Unable to connect to Statsd"))</span>
        }

        <span class="cov0" title="0">defer client.Close()

        for </span><span class="cov0" title="0">{

                err = client.Gauge("cpu.goroutines", int64(runtime.NumGoroutine()), 1.0)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("unable to send data"))</span>
                }
                // CGo calls
                <span class="cov0" title="0">client.Gauge("cpu.cgo_calls", int64(runtime.NumCgoCall()), 1.0)

                m := &amp;runtime.MemStats{}
                runtime.ReadMemStats(m)

                client.Gauge("mem.alloc", int64(m.Alloc), 1.0)
                client.Gauge("mem.total", int64(m.TotalAlloc), 1.0)
                client.Gauge("mem.sys", int64(m.Sys), 1.0)
                client.Gauge("mem.lookups", int64(m.Lookups), 1.0)
                client.Gauge("mem.malloc", int64(m.Mallocs), 1.0)
                client.Gauge("mem.frees", int64(m.Frees), 1.0)
                client.Gauge("mem.stack.inuse", int64(m.StackInuse), 1.0)
                client.Gauge("mem.stack.sys", int64(m.StackSys), 1.0)
                client.Gauge("mem.stack.mspan_inuse", int64(m.MSpanInuse), 1.0)
                client.Gauge("mem.stack.mspan_sys", int64(m.MSpanSys), 1.0)
                client.Gauge("mem.stack.mcache_inuse", int64(m.MCacheInuse), 1.0)
                client.Gauge("mem.stack.mcache_sys", int64(m.MCacheSys), 1.0)
                client.Gauge("mem.heap.alloc", int64(m.HeapAlloc), 1.0)
                client.Gauge("mem.heap.sys", int64(m.HeapSys), 1.0)
                client.Gauge("mem.heap.idle", int64(m.HeapIdle), 1.0)
                client.Gauge("mem.heap.inuse", int64(m.HeapInuse), 1.0)
                client.Gauge("mem.heap.released", int64(m.HeapReleased), 1.0)
                client.Gauge("mem.heap.objects", int64(m.HeapObjects), 1.0)
                client.Gauge("mem.othersys", int64(m.OtherSys), 1.0)
                client.Gauge("mem.gc.sys", int64(m.GCSys), 1.0)
                client.Gauge("mem.gc.next", int64(m.NextGC), 1.0)
                client.Gauge("mem.gc.last", int64(m.LastGC), 1.0)
                client.Gauge("mem.gc.pause_total", int64(m.PauseTotalNs), 1.0)
                client.Gauge("mem.gc.pause", int64(m.PauseNs[(m.NumGC+255)%256]), 1.0)
                client.Gauge("mem.gc.count", int64(m.NumGC), 1.0)

                time.Sleep(time.Duration(statsdPause) * time.Second)</span>
        }

}

func Map2Headers(m map[string]string) http.Header <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">headers := make(http.Header, len(m))
        for k, v := range m </span><span class="cov0" title="0">{
                headers.Set(k, v)
        }</span>
        <span class="cov0" title="0">return headers</span>
}

func Headers2Map(headers http.Header) map[string]string <span class="cov0" title="0">{
        if headers == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">m := make(map[string]string, len(headers))
        for k := range headers </span><span class="cov0" title="0">{
                m[k] = headers.Get(k)
        }</span>
        <span class="cov0" title="0">return m</span>
}

func CheckNameFormat(req *http.Request, name string, target string) (string, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return "", errors.New(fmt.Sprintf("%s name cannot be empty", target))
        }</span>
        <span class="cov8" title="1">if strings.Contains(name, "/") </span><span class="cov8" title="1">{
                return "", errors.New(fmt.Sprintf("%s name cannot contain slashes", target))
        }</span>
        <span class="cov8" title="1">return name, nil</span>
}

func ParseContentTypeForSlo(contentType string, listedSize int64) (string, int64, error) <span class="cov8" title="1">{
        // somewhat dirty check to see if we need to parse the content-type
        if strings.Contains(contentType, ";") &amp;&amp; strings.Contains(contentType, "swift_bytes") </span><span class="cov8" title="1">{
                contentTypeCleaned, params, err := mime.ParseMediaType(contentType)
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, err
                }</span>
                <span class="cov8" title="1">if v, ok := params["swift_bytes"]; ok </span><span class="cov8" title="1">{
                        sloSize, err := strconv.ParseInt(v, 0, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return "", 0, err
                        }</span>
                        <span class="cov8" title="1">delete(params, "swift_bytes")
                        return mime.FormatMediaType(contentTypeCleaned, params), sloSize, nil</span>
                }
        }
        <span class="cov8" title="1">return contentType, listedSize, nil</span>
}

func SliceFromCSV(csv string) []string <span class="cov8" title="1">{
        s := []string{}
        for _, val := range strings.Split(csv, ",") </span><span class="cov8" title="1">{
                if strings.TrimSpace(val) != "" </span><span class="cov8" title="1">{
                        s = append(s, strings.TrimSpace(val))
                }</span>
        }
        <span class="cov8" title="1">return s</span>
}

func StringInSlice(s string, slice []string) bool <span class="cov8" title="1">{
        for _, x := range slice </span><span class="cov8" title="1">{
                if x == s </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func IsOriginAllowed(allowedOriginHeader, requestOrigin string) bool <span class="cov8" title="1">{
        allowOrigins := strings.Split(allowedOriginHeader, " ")
        for _, o := range allowOrigins </span><span class="cov8" title="1">{
                if o == "*" || o == requestOrigin </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func ParseIfMatch(s string) map[string]bool <span class="cov8" title="1">{
        r := make(map[string]bool)
        if len(strings.Trim(s, " ")) &gt; 0 </span><span class="cov0" title="0">{
                for _, ss := range strings.Split(s, ",") </span><span class="cov0" title="0">{
                        if sst := strings.Trim(ss, " "); sst != "" </span><span class="cov0" title="0">{
                                if sst[0] == '"' &amp;&amp; sst[len(sst)-1] == '"' </span><span class="cov0" title="0">{
                                        r[sst[1:len(sst)-1]] = true
                                }</span><span class="cov0" title="0"> else {
                                        r[sst] = true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "container/list"
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common/fs"
)

var (
        // ErrorNoSuchContainer is returned when a requested container doesn't exist.
        ErrorNoSuchContainer = fmt.Errorf("No such container.")
        // ErrorInvalidMetadata is returned for errors that violate the API metadata constraints.
        ErrorInvalidMetadata = fmt.Errorf("Invalid metadata value")
        // ErrorPolicyConflict is returned when an operation conflicts with the container's existing policy.
        ErrorPolicyConflict = fmt.Errorf("Policy conflicts with existing value")
)

// ContainerInfo represents the container_info database record - basic information about the container.
type ContainerInfo struct {
        Account                 string              `json:"account"`
        Container               string              `json:"container"`
        CreatedAt               string              `json:"created_at"`
        PutTimestamp            string              `json:"put_timestamp"`
        DeleteTimestamp         string              `json:"delete_timestamp"`
        StatusChangedAt         string              `json:"status_changed_at"`
        ObjectCount             int64               `json:"count"`
        BytesUsed               int64               `json:"bytes_used"`
        ReportedPutTimestamp    string              `json:"-"`
        ReportedDeleteTimestamp string              `json:"-"`
        ReportedObjectCount     int64               `json:"-"`
        ReportedBytesUsed       int64               `json:"-"`
        Hash                    string              `json:"hash"`
        ID                      string              `json:"id"`
        XContainerSyncPoint1    string              `json:"-"`
        XContainerSyncPoint2    string              `json:"-"`
        StoragePolicyIndex      int                 `json:"storage_policy_index"`
        RawMetadata             string              `json:"metadata"`
        Metadata                map[string][]string `json:"-"`
        MaxRow                  int64               `json:"max_row"`
        invalid                 bool
        updated                 time.Time
        // This row isn't populated by GetInfo, it only exists for the times this is
        // serialized during replication.
        Point int64 `json:"point"`
}

// ObjectListingRecord is the struct used for serializing objects in json and xml container listings.
type ObjectListingRecord struct {
        XMLName      xml.Name `xml:"object" json:"-"`
        Name         string   `xml:"name" json:"name"`
        LastModified string   `xml:"last_modified" json:"last_modified"`
        Size         int64    `xml:"bytes" json:"bytes"`
        ContentType  string   `xml:"content_type" json:"content_type"`
        ETag         string   `xml:"hash" json:"hash"`
}

// SubdirListingRecord is the struct used for serializing subdirs in json and xml container listings.
type SubdirListingRecord struct {
        XMLName xml.Name `xml:"subdir" json:"-"`
        Name2   string   `xml:"name,attr" json:"-"`
        Name    string   `xml:"name" json:"subdir"`
}

// ObjectRecord represents the object's data in-databaee, it is used by replication.
type ObjectRecord struct {
        Rowid              int64  `json:"ROWID"`
        Name               string `json:"name"`
        CreatedAt          string `json:"created_at"`
        Size               int64  `json:"size"`
        ContentType        string `json:"content_type"`
        ETag               string `json:"etag"`
        Deleted            int    `json:"deleted"`
        StoragePolicyIndex int    `json:"storage_policy_index"`
}

// SyncRecord represents a row in the incoming_sync table.  It is used by replication.
type SyncRecord struct {
        SyncPoint int64  `json:"sync_point"`
        RemoteID  string `json:"remote_id"`
}

// Container is the interface implemented by a container.
type Container interface {
        // GetInfo returns the ContainerInfo struct for the container.
        GetInfo() (*ContainerInfo, error)
        // IsDeleted returns true if the container has been deleted.
        IsDeleted() (bool, error)
        // Delete deletes the container.
        Delete(timestamp string) error
        // ListObjects lists the container's object entries.
        ListObjects(limit int, marker string, endMarker string, prefix string, delimiter string, path *string, reverse bool, storagePolicyIndex int) ([]interface{}, error)
        // GetMetadata returns the container's current metadata.
        GetMetadata() (map[string]string, error)
        // UpdateMetadata applies updates to the container's metadata.
        UpdateMetadata(updates map[string][]string, timestamp string) error
        // PutObject adds a new object to the container.
        PutObject(name string, timestamp string, size int64, contentType string, etag string, storagePolicyIndex int) error
        // DeleteObject deletes an object from the container.
        DeleteObject(name string, timestamp string, storagePolicyIndex int) error
        // ID returns a unique identifier for the container.
        ID() string
        // Close frees any resources associated with the container.
        Close() error
}

// ReplicableContainer is a container that also implements the replication API.
type ReplicableContainer interface {
        Container
        // MergeItems merges object records into the container, with an optional remoteId.
        MergeItems(records []*ObjectRecord, remoteID string) error
        // ItemsSince returns count object records with a ROWID greater than start.
        ItemsSince(start int64, count int) ([]*ObjectRecord, error)
        // MergeSyncTable updates the container's incoming sync tables with new data.
        MergeSyncTable(records []*SyncRecord) error
        // SyncTable returns the container's current sync table.
        SyncTable() ([]*SyncRecord, error)
        // SyncRemoteData accepts a remote container's current status information and updates local records accordingly.
        SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*ContainerInfo, error)
        // NewID gives the database a new unique identifier, which is used for incoming_sync entries.
        NewID() error
        // OpenDatabaseFile returns a consistent reader for the underlying database file.
        OpenDatabaseFile() (*os.File, func(), error)
        // CleanupTombstones removes any metadata and object tombstones older than reclaimAge seconds.
        CleanupTombstones(reclaimAge int64) error
        // CheckSyncLinks makes sure container sync symlinks are correct for the database.
        CheckSyncLink() error
        // RingHash returns the container's ring hash.
        RingHash() string
}

// ContainerEngine is the interface of an object that creates and returns containers.
type ContainerEngine interface {
        // GET returns a container, given a vars mapping.
        Get(vars map[string]string) (c Container, err error)
        // Return returns a Container to the engine, where it can close or retain them as it sees fit.
        Return(c Container)
        // Create creates a new container.  Returns true if the container was created and a pointer to the container.
        Create(vars map[string]string, putTimestamp string, metadata map[string][]string, policyIndex, defaultPolicyIndex int) (bool, Container, error)
        // Close releases all cached containers and any other retained resources.
        Close()

        // GetByHash returns a replicable database given its hash.  This will probably move from this interface once we
        // have replicator-&gt;replicator communication.
        GetByHash(device, hash, partition string) (c ReplicableContainer, err error)
        // Invalidate removes a container from the cache entirely.  This will probably also move, since it's only used by replication.
        Invalidate(c Container)

        // Number of containers that have been Get()ted but not Return()ed
        OpenCount() (count int)
}

// My attempts at making this lruEngine reusable have not been successful, so for now it's sqlite-specific and not exported.
type lruEngine struct {
        deviceRoot     string
        hashPathPrefix string
        hashPathSuffix string
        maxSize        int
        cache          map[string]*lruEntry
        used           *list.List
        m              sync.Mutex
}

type lruEntry struct {
        c     Container
        inUse int
        elem  *list.Element
}

func (l *lruEngine) add(c Container) <span class="cov8" title="1">{
        if len(l.cache) &gt;= l.maxSize </span><span class="cov8" title="1">{
                for elem := l.used.Front(); elem != nil; elem = elem.Next() </span><span class="cov8" title="1">{
                        if entry, ok := elem.Value.(*lruEntry); ok &amp;&amp; entry.inUse == 0 </span><span class="cov8" title="1">{
                                l.used.Remove(elem)
                                delete(l.cache, entry.c.ID())
                                entry.c.Close()
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">holder := &amp;lruEntry{c: c, inUse: 1}
        holder.elem = l.used.PushBack(holder)
        l.cache[c.ID()] = holder</span>
}

func (l *lruEngine) OpenCount() int <span class="cov8" title="1">{
        count := 0
        l.m.Lock()
        for elem := l.used.Front(); elem != nil; elem = elem.Next() </span><span class="cov8" title="1">{
                if entry, ok := elem.Value.(*lruEntry); ok &amp;&amp; entry.inUse == 1 </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">defer l.m.Unlock()
        return count</span>
}

func (l *lruEngine) containerLocation(vars map[string]string) string <span class="cov8" title="1">{
        h := md5.New()
        fmt.Fprintf(h, "%s/%s/%s%s", l.hashPathPrefix, vars["account"], vars["container"], l.hashPathSuffix)
        hexHash := fmt.Sprintf("%032x", h.Sum(nil))
        suffix := hexHash[29:32]
        return filepath.Join(l.deviceRoot, vars["device"], "containers", vars["partition"], suffix, hexHash, hexHash+".db")
}</span>

func (l *lruEngine) getbypath(containerFile string) (c Container, err error) <span class="cov8" title="1">{
        if !fs.Exists(containerFile) </span><span class="cov8" title="1">{
                return nil, ErrorNoSuchContainer
        }</span>
        <span class="cov8" title="1">ringHash := filepath.Base(filepath.Dir(containerFile))
        l.m.Lock()
        defer l.m.Unlock()
        if e := l.cache[ringHash]; e != nil </span><span class="cov8" title="1">{
                e.inUse++
                l.used.MoveToBack(e.elem)
                return e.c, nil
        }</span>
        <span class="cov8" title="1">if c, err = sqliteOpenContainer(containerFile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">l.add(c)
        return c, nil</span>
}

// Get returns a database given the incoming vars.
func (l *lruEngine) Get(vars map[string]string) (c Container, err error) <span class="cov8" title="1">{
        return l.getbypath(l.containerLocation(vars))
}</span>

// Create creates a new container.
func (l *lruEngine) Create(vars map[string]string, putTimestamp string, metadata map[string][]string, policyIndex, defaultPolicyIndex int) (bool, Container, error) <span class="cov8" title="1">{
        containerFile := l.containerLocation(vars)
        created := false
        c, err := l.Get(vars)
        if err != nil </span><span class="cov8" title="1">{
                created = true
                if policyIndex &lt; 0 </span><span class="cov8" title="1">{
                        policyIndex = defaultPolicyIndex
                }</span>
                <span class="cov8" title="1">err = sqliteCreateContainer(containerFile, vars["account"], vars["container"], putTimestamp, metadata, policyIndex)
                if err == nil </span><span class="cov8" title="1">{
                        c, err = l.Get(vars)
                }</span>
        }<span class="cov8" title="1"> else {
                created, err = sqliteCreateExistingContainer(c, putTimestamp, metadata, policyIndex, defaultPolicyIndex)
                if err != nil </span><span class="cov8" title="1">{
                        l.Return(c)
                        c = nil
                }</span>
        }
        <span class="cov8" title="1">return created, c, err</span>
}

// Return returns a database object to the engine.
func (l *lruEngine) Return(c Container) <span class="cov8" title="1">{
        l.m.Lock()
        if e := l.cache[c.ID()]; e != nil &amp;&amp; e.c == c </span><span class="cov8" title="1">{
                e.inUse--
        }</span><span class="cov8" title="1"> else {
                l.add(c)
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// GetByHash returns a database given its device and ring hash.
func (l *lruEngine) GetByHash(device, hash, partition string) (ReplicableContainer, error) <span class="cov8" title="1">{
        containerFile := filepath.Join(l.deviceRoot, device, "containers", partition, hash[29:32], hash, hash+".db")
        c, err := l.getbypath(containerFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rc, ok := c.(ReplicableContainer)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Container does not support replication.")
        }</span>
        <span class="cov8" title="1">return rc, nil</span>
}

// Invalidate removes any cached backend connections to the database.
func (l *lruEngine) Invalidate(c Container) <span class="cov8" title="1">{
        defer c.Close()
        l.m.Lock()
        if e := l.cache[c.ID()]; e != nil &amp;&amp; e.c == c </span><span class="cov8" title="1">{
                l.used.Remove(e.elem)
                delete(l.cache, c.ID())
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// Close shuts down any backend container database connections and clears the caches.
func (l *lruEngine) Close() <span class="cov8" title="1">{
        for k, v := range l.cache </span><span class="cov8" title="1">{
                v.c.Close()
                delete(l.cache, k)
        }</span>
        <span class="cov8" title="1">l.used = l.used.Init()</span>
}

func newLRUEngine(deviceRoot, hashPathPrefix, hashPathSuffix string, containerCount int) *lruEngine <span class="cov8" title="1">{
        return &amp;lruEngine{
                deviceRoot:     deviceRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                maxSize:        containerCount,
                cache:          make(map[string]*lruEntry),
                used:           list.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "os"
        "path/filepath"

        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

func isOkayFilename(s string) bool <span class="cov8" title="1">{
        if len(s) &lt; 5 || len(s) &gt; 100 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, c := range s </span><span class="cov8" title="1">{
                if !((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') ||
                        (c == '-') || (c == '_') || (c == '.')) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// ContainerTmpUploadHandler handles uploading container files to the tmp directory for various replication strategies.
// This replaces the swift replicator's use of rsync.
func (server *ContainerServer) ContainerTmpUploadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if !isOkayFilename(vars["filename"]) </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">filename := filepath.Join(server.driveRoot, vars["device"], "tmp", vars["filename"])
        if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">fp, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create file.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        if _, err := io.Copy(fp, request.Body); err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(filename)
                srv.GetLogger(request).Error("Error saving file contents.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span><span class="cov8" title="1"> else {
                srv.StandardResponse(writer, http.StatusCreated)
        }</span>
}

// ContainerReplicateHandler handles the REPLICATE call for containers.
func (server *ContainerServer) ContainerReplicateHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        // make sure there's a tmp dir to rsync to
        if err := os.MkdirAll(filepath.Join(server.driveRoot, vars["device"], "tmp"), 0777); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">message := []json.RawMessage{}
        decoder := json.NewDecoder(request.Body)
        if err := decoder.Decode(&amp;message); err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var op string
        if err := json.Unmarshal(message[0], &amp;op); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">extractArgs := func(args ...interface{}) error </span><span class="cov8" title="1">{
                if len(message)-1 &lt; len(args) </span><span class="cov8" title="1">{
                        return errors.New("Not enough arguments in payload.")
                }</span>
                <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(message[i+1], arg); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">switch op </span>{
        case "rsync_then_merge":<span class="cov8" title="1">
                var tmpFileName string
                if err := extractArgs(&amp;tmpFileName); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateRsyncThenMerge(request, vars, tmpFileName)
                        srv.StandardResponse(writer, status)
                }</span>
        case "complete_rsync":<span class="cov8" title="1">
                var tmpFileName string
                if err := extractArgs(&amp;tmpFileName); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateCompleteRsync(request, vars, tmpFileName)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_items":<span class="cov8" title="1">
                var records []*ObjectRecord
                var remoteID string
                if err := extractArgs(&amp;records, &amp;remoteID); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateMergeItems(request, vars, records, remoteID)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_syncs":<span class="cov8" title="1">
                var records []*SyncRecord
                if err := extractArgs(&amp;records); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else {
                        status := server.replicateMergeSyncs(request, vars, records)
                        srv.StandardResponse(writer, status)
                }</span>
        case "sync":<span class="cov8" title="1">
                var maxRow int64
                var hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string
                if err := extractArgs(&amp;maxRow, &amp;hash, &amp;id, &amp;createdAt, &amp;putTimestamp, &amp;deleteTimestamp, &amp;metadata); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span><span class="cov8" title="1"> else if status, data := server.replicateSync(request, vars, maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata); status == http.StatusOK </span><span class="cov8" title="1">{
                        writer.WriteHeader(http.StatusOK)
                        writer.Write(data)
                }</span><span class="cov8" title="1"> else {
                        srv.StandardResponse(writer, status)
                }</span>
        default:<span class="cov8" title="1">
                srv.GetLogger(request).Error("Unknown replication op.", zap.String("op", op))
                srv.StandardResponse(writer, http.StatusBadRequest)</span>
        }
}

func (server *ContainerServer) replicateRsyncThenMerge(request *http.Request, vars map[string]string, tmpFileName string) int <span class="cov8" title="1">{
        containerFile := filepath.Join(server.driveRoot, vars["device"], "containers", vars["partition"], vars["hash"][29:32], vars["hash"], vars["hash"]+".db")
        tmpContainerFile := filepath.Join(server.driveRoot, vars["device"], "tmp", tmpFileName)
        tmpDb, err := sqliteOpenContainer(tmpContainerFile)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer tmpDb.Close()
        localDb, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer localDb.Close()
        point := int64(-1)
        for </span><span class="cov8" title="1">{
                records, err := localDb.ItemsSince(point, 10000)
                if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error fetching items.",
                                zap.String("containerFile", containerFile),
                                zap.Error(err))
                        return http.StatusInternalServerError
                }</span>
                <span class="cov8" title="1">if len(records) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">point = records[len(records)-1].Rowid
                if err := tmpDb.MergeItems(records, ""); err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error merging items.",
                                zap.String("tmpContainerFile", tmpContainerFile),
                                zap.Error(err))
                        return http.StatusInternalServerError
                }</span>
        }
        <span class="cov8" title="1">if tmpDb.NewID() != nil || os.MkdirAll(filepath.Dir(containerFile), 0777) != nil || os.Rename(tmpContainerFile, containerFile) != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">server.containerEngine.Invalidate(localDb)
        return http.StatusNoContent</span>
}

func (server *ContainerServer) replicateCompleteRsync(request *http.Request, vars map[string]string, tmpFileName string) int <span class="cov8" title="1">{
        containerFile := filepath.Join(server.driveRoot, vars["device"], "containers", vars["partition"], vars["hash"][29:32], vars["hash"], vars["hash"]+".db")
        tmpContainerFile := filepath.Join(server.driveRoot, vars["device"], "tmp", tmpFileName)
        if !fs.Exists(tmpContainerFile) || fs.Exists(containerFile) </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">tmpDb, err := sqliteOpenContainer(tmpContainerFile)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer tmpDb.Close()
        if tmpDb.NewID() != nil || os.MkdirAll(filepath.Dir(containerFile), 0777) != nil || os.Rename(tmpContainerFile, containerFile) != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusNoContent</span>
}

func (server *ContainerServer) replicateMergeItems(request *http.Request, vars map[string]string, records []*ObjectRecord, remoteID string) int <span class="cov8" title="1">{
        db, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if err := db.MergeItems(records, remoteID); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging records",
                        zap.String("RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *ContainerServer) replicateMergeSyncs(request *http.Request, vars map[string]string, records []*SyncRecord) int <span class="cov8" title="1">{
        db, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if err := db.MergeSyncTable(records); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging sync table.",
                        zap.String("RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *ContainerServer) replicateSync(request *http.Request, vars map[string]string, maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (int, []byte) <span class="cov8" title="1">{
        db, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound, nil
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        info, err := db.SyncRemoteData(maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error syncing remote data.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">response, err := json.Marshal(info)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error marshaling info.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">return http.StatusOK, response</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "bytes"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

var (
        errDeviceNotMounted = errors.New("Remove drive was unmounted")
        deviceLockupTimeout = time.Hour
        // GetRing is a local pointer to the hummingbird function, for overriding in tests.
        GetRing = ring.GetRing
)

// Replicator is the container replicator daemon object
type Replicator struct {
        checkMounts    bool
        deviceRoot     string
        reconCachePath string
        logger         srv.LowLevelLogger
        serverPort     int
        Ring           ring.Ring
        perUsync       int64
        maxUsyncs      int
        concurrencySem chan struct{}
        sendStat       chan statUpdate
        checkin        chan string
        startRun       chan string
        client         *http.Client
        runningDevices map[string]*replicationDevice
        reclaimAge     int64
}

type statUpdate struct {
        device string
        stat   string
        value  int64
}

type replicationDevice struct {
        i interface {
                sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error)
                sync(dev *ring.Device, part uint64, ringHash string, info *ContainerInfo) (*ContainerInfo, error)
                rsync(dev *ring.Device, c ReplicableContainer, part uint64, op string) error
                usync(dev *ring.Device, c ReplicableContainer, part uint64, localID string, point int64) error
                chooseReplicationStrategy(localInfo, remoteInfo *ContainerInfo, usyncThreshold int64) string
                replicateDatabaseToDevice(dev *ring.Device, c ReplicableContainer, part uint64) error
                replicateDatabase(dbFile string) error
                findContainerDbs(devicePath string, results chan string)
                incrementStat(stat string)
        }
        r             *Replicator
        cancel        chan struct{}
        dev           *ring.Device
        stats         map[string]int64
        lastCheckin   time.Time
        runStarted    time.Time
        deviceStarted time.Time
}

func (rd *replicationDevice) sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error) <span class="cov8" title="1">{
        body, err := json.Marshal(args)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest("REPLICATE", fmt.Sprintf("http://%s:%d/%s/%d/%s",
                dev.ReplicationIp, dev.ReplicationPort, dev.Device, part, ringHash), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">return resp.StatusCode, respBody, nil</span>
}

func (rd *replicationDevice) sync(dev *ring.Device, part uint64, ringHash string, info *ContainerInfo) (*ContainerInfo, error) <span class="cov8" title="1">{
        var remoteInfo ContainerInfo
        status, body, err := rd.i.sendReplicationMessage(dev, part, ringHash, "sync", info.MaxRow, info.Hash,
                info.ID, info.CreatedAt, info.PutTimestamp, info.DeleteTimestamp, info.RawMetadata)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sending sync request to %s/%s: %v", dev.ReplicationIp, dev.Device, err)
        }</span><span class="cov8" title="1"> else if status == http.StatusNotFound </span><span class="cov8" title="1">{
                return nil, nil
        }</span><span class="cov8" title="1"> else if status == http.StatusInsufficientStorage </span><span class="cov8" title="1">{
                return nil, errDeviceNotMounted
        }</span><span class="cov8" title="1"> else if status/100 != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("bad status code %d", status)
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(body, &amp;remoteInfo); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unmarshalling sync response: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;remoteInfo, nil</span>
}

func (rd *replicationDevice) rsync(dev *ring.Device, c ReplicableContainer, part uint64, op string) error <span class="cov8" title="1">{
        tmpFilename := common.UUID()
        fp, release, err := c.OpenDatabaseFile()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error opening databae: %v", err)
        }</span>
        <span class="cov8" title="1">defer release()
        req, err := http.NewRequest("PUT", fmt.Sprintf("http://%s:%d/%s/tmp/%s", dev.ReplicationIp, dev.ReplicationPort, dev.Device, tmpFilename), fp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating request: %v", err)
        }</span>
        <span class="cov8" title="1">req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("putting database to %s/%s: %v", dev.ReplicationIp, dev.Device, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("bad status code %d rsyncing file with %s/%s", resp.StatusCode, dev.ReplicationIp, dev.Device)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), op, tmpFilename)
        if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("sending %s message to %s/%s: %v", op, dev.ReplicationIp, dev.Device, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) usync(dev *ring.Device, c ReplicableContainer, part uint64, localID string, point int64) error <span class="cov8" title="1">{
        objects, err := c.ItemsSince(point, int(rd.r.perUsync))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("getting object records from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">usyncs := 0
        syncTable, err := c.SyncTable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting sync table: %v", err)
        }</span>
        <span class="cov8" title="1">for len(objects) != 0 &amp;&amp; usyncs &lt; rd.r.maxUsyncs </span><span class="cov8" title="1">{
                status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_items", objects, localID)
                if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Bad response to merge_items with %s/%s: %v, %v", dev.ReplicationIp, dev.Device, status, err)
                }</span>
                <span class="cov8" title="1">point = objects[len(objects)-1].Rowid
                usyncs++
                if objects, err = c.ItemsSince(point, int(rd.r.perUsync)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("getting object records from database: %s, %v", c.RingHash(), err)
                }</span>
        }
        <span class="cov8" title="1">if usyncs &gt;= rd.r.maxUsyncs </span><span class="cov0" title="0">{
                rd.i.incrementStat("diff_capped")
                return fmt.Errorf("capping usync at %d requests", usyncs)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_syncs", syncTable)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid status code from merge_syncs: %d", status)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) chooseReplicationStrategy(localInfo, remoteInfo *ContainerInfo, usyncThreshold int64) string <span class="cov8" title="1">{
        switch </span>{
        case remoteInfo == nil:<span class="cov8" title="1">
                return "complete_rsync"</span>
        case localInfo.MaxRow == -1:<span class="cov8" title="1">
                return "empty"</span>
        case localInfo.MaxRow == remoteInfo.Point:<span class="cov8" title="1">
                return "no_change"</span>
        case localInfo.Hash == remoteInfo.Hash:<span class="cov8" title="1">
                return "hashmatch"</span>
        case remoteInfo.MaxRow &lt; localInfo.MaxRow*2 &amp;&amp; localInfo.MaxRow-remoteInfo.MaxRow &gt; usyncThreshold:<span class="cov8" title="1">
                return "rsync_then_merge"</span>
        default:<span class="cov8" title="1">
                return "diff"</span>
        }
}

func (rd *replicationDevice) replicateDatabaseToDevice(dev *ring.Device, c ReplicableContainer, part uint64) error <span class="cov8" title="1">{
        rd.i.incrementStat("attempted")
        info, err := c.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("getting local info from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">remoteInfo, err := rd.i.sync(dev, part, c.RingHash(), info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">strategy := rd.i.chooseReplicationStrategy(info, remoteInfo, rd.r.perUsync*3)
        rd.i.incrementStat(strategy)
        switch strategy </span>{
        case "empty", "hashmatch", "no_change":<span class="cov8" title="1">
                rd.r.logger.Debug("Not replicating anything.",
                        zap.String("strategy", strategy),
                        zap.String("RingHash", c.RingHash()))</span>
        case "complete_rsync", "rsync_then_merge":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("ReplicationIp", dev.ReplicationIp),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.rsync(dev, c, part, strategy)</span>
        case "diff":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("ReplicationIp", dev.ReplicationIp),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.usync(dev, c, part, info.ID, remoteInfo.Point)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) replicateDatabase(dbFile string) error <span class="cov8" title="1">{
        rd.r.logger.Debug("Replicating database.", zap.String("dbFile", filepath.Base(dbFile)))
        parts := filepath.Base(filepath.Dir(filepath.Dir(filepath.Dir(dbFile))))
        part, err := strconv.ParseUint(parts, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Bad partition: %s", parts)
        }</span>
        <span class="cov8" title="1">devices, handoff := rd.r.Ring.GetJobNodes(part, rd.dev.Id)
        moreNodes := rd.r.Ring.GetMoreNodes(part)
        c, err := sqliteOpenContainer(dbFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer c.Close()
        if err := c.CleanupTombstones(rd.r.reclaimAge); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.CheckSyncLink(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">successes := 0
        for i := 0; i &lt; len(devices); i++ </span><span class="cov8" title="1">{
                if err := rd.i.replicateDatabaseToDevice(devices[i], c, part); err == nil </span><span class="cov8" title="1">{
                        rd.i.incrementStat("success")
                        rd.r.logger.Debug("Succeeded replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("ReplicationIp", devices[i].ReplicationIp),
                                zap.String("Device", devices[i].Device))
                        successes++
                }</span><span class="cov8" title="1"> else {
                        rd.i.incrementStat("failure")
                        rd.r.logger.Error("Error replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("ReplicationIp", devices[i].ReplicationIp),
                                zap.String("Device", devices[i].Device),
                                zap.Error(err))
                        if err == errDeviceNotMounted &amp;&amp; !handoff </span><span class="cov0" title="0">{
                                next := moreNodes.Next()
                                if next == nil </span><span class="cov0" title="0">{
                                        rd.r.logger.Error("Ran out of handoffs to talk to.",
                                                zap.String("dbFile", dbFile))
                                }</span><span class="cov0" title="0"> else {
                                        devices = append(devices, moreNodes.Next())
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if handoff &amp;&amp; successes == len(devices) </span><span class="cov8" title="1">{
                rd.i.incrementStat("remove")
                return os.RemoveAll(filepath.Dir(dbFile))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) findContainerDbs(devicePath string, results chan string) <span class="cov8" title="1">{
        defer close(results)
        containersDir := filepath.Join(devicePath, "containers")
        partitions, err := filepath.Glob(filepath.Join(containersDir, "[0-9]*"))
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("Error getting partitions.",
                        zap.String("containersDir", containersDir),
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, part := range partitions </span><span class="cov8" title="1">{
                suffixes, err := filepath.Glob(filepath.Join(part, "[a-f0-9][a-f0-9][a-f0-9]"))
                if err != nil </span><span class="cov0" title="0">{
                        rd.r.logger.Error("Error getting suffixes.",
                                zap.String("part", part),
                                zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">for _, suff := range suffixes </span><span class="cov8" title="1">{
                        hashes, err := filepath.Glob(filepath.Join(suff, "????????????????????????????????"))
                        if err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error getting hashes",
                                        zap.String("suff", suff),
                                        zap.Error(err))
                                return
                        }</span>
                        <span class="cov8" title="1">for _, hash := range hashes </span><span class="cov8" title="1">{
                                dbFile := filepath.Join(hash, filepath.Base(hash)+".db")
                                if fs.Exists(dbFile) </span><span class="cov8" title="1">{
                                        select </span>{
                                        case results &lt;- dbFile:</span><span class="cov8" title="1">
                                        case &lt;-rd.cancel:<span class="cov8" title="1">
                                                return</span>
                                        }
                                }
                        }
                }
        }
}

func (rd *replicationDevice) replicate() <span class="cov8" title="1">{
        rd.r.logger.Info("Beginning replication for device.",
                zap.String("device", rd.dev.Device))
        rd.r.startRun &lt;- rd.dev.Device
        devicePath := filepath.Join(rd.r.deviceRoot, rd.dev.Device)
        stat, err := os.Stat(devicePath)
        if err != nil || !stat.IsDir() </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device doesn't exist.",
                        zap.String("devicePath", devicePath))
                return
        }</span>
        <span class="cov8" title="1">if mount, err := fs.IsMount(devicePath); rd.r.checkMounts &amp;&amp; (err != nil || !mount) </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device not mounted.",
                        zap.String("devicePath", devicePath))
                return
        }</span>
        <span class="cov8" title="1">results := make(chan string, 100)
        go rd.i.findContainerDbs(devicePath, results)
        for dbFile := range results </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                case rd.r.concurrencySem &lt;- struct{}{}:<span class="cov8" title="1">
                        rd.r.checkin &lt;- rd.dev.Device
                        if err := rd.i.replicateDatabase(dbFile); err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error replicating database file.",
                                        zap.String("dbFile", dbFile),
                                        zap.Error(err))
                        }</span>
                        <span class="cov8" title="1">&lt;-rd.r.concurrencySem</span>
                }
        }
}

func (rd *replicationDevice) replicateLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        rd.replicate()</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Second * 30)</span>
        }
}

func (rd *replicationDevice) incrementStat(stat string) <span class="cov8" title="1">{
        rd.r.sendStat &lt;- statUpdate{rd.dev.Device, stat, 1}
}</span>

func newReplicationDevice(dev *ring.Device, r *Replicator) *replicationDevice <span class="cov8" title="1">{
        rd := &amp;replicationDevice{
                r:             r,
                cancel:        make(chan struct{}),
                lastCheckin:   time.Now(),
                deviceStarted: time.Now(),
                dev:           dev,
                stats: map[string]int64{
                        "attempted":             0,
                        "success":               0,
                        "failure":               0,
                        "no_change":             0,
                        "hashmatch":             0,
                        "rsync":                 0,
                        "diff":                  0,
                        "remove":                0,
                        "empty":                 0,
                        "remote_merge":          0,
                        "diff_capped":           0,
                        "lifetime_attempted":    0,
                        "lifetime_success":      0,
                        "lifetime_failure":      0,
                        "lifetime_no_change":    0,
                        "lifetime_hashmatch":    0,
                        "lifetime_rsync":        0,
                        "lifetime_diff":         0,
                        "lifetime_remove":       0,
                        "lifetime_empty":        0,
                        "lifetime_remote_merge": 0,
                        "lifetime_diff_capped":  0,
                        "lifetime_passes":       0,
                },
        }
        rd.i = rd
        return rd
}</span>

func (r *Replicator) verifyDevices() <span class="cov8" title="1">{
        // kill devices that haven't checked in for a while
        for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                if time.Since(rd.lastCheckin) &gt; deviceLockupTimeout </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
        <span class="cov8" title="1">ringDevices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        // look for devices that aren't running but should be
        <span class="cov8" title="1">for _, dev := range ringDevices </span><span class="cov8" title="1">{
                if _, ok := r.runningDevices[dev.Device]; !ok </span><span class="cov8" title="1">{
                        r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                        go r.runningDevices[dev.Device].replicateLoop()
                }</span>
        }
        // look for devices that are running but shouldn't be
        <span class="cov8" title="1">for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                found := false
                for _, dev := range ringDevices </span><span class="cov8" title="1">{
                        if dev.Device == key </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
}

func (r *Replicator) reportStats() <span class="cov8" title="1">{
        var totalTime time.Duration
        aggStats := map[string]int64{"attempted": 0, "success": 0, "failure": 0, "remove": 0}
        for _, device := range r.runningDevices </span><span class="cov8" title="1">{
                totalTime += time.Since(device.runStarted)
                aggStats["attempted"] += device.stats["attempted"]
                aggStats["success"] += device.stats["success"]
                aggStats["failure"] += device.stats["failure"]
                aggStats["remove"] += device.stats["remove"]
        }</span>
        // there's no longer the concept of a single pass, so we report the average running time.
        <span class="cov8" title="1">if len(r.runningDevices) &gt; 0 </span><span class="cov8" title="1">{
                rate := 0.0
                runningTime := (totalTime / time.Duration(len(r.runningDevices))).Seconds()
                if runningTime &gt; 0 </span><span class="cov8" title="1">{
                        rate = float64(aggStats["attempted"]) / runningTime
                }</span>
                <span class="cov8" title="1">r.logger.Info("Attempted to replicate dbs",
                        zap.Int64("aggStats['attempted']", aggStats["attempted"]),
                        zap.Float64("runningTime", runningTime),
                        zap.Float64("rate", rate))

                r.logger.Info("Removed dbs",
                        zap.Int64("aggStats['remove']", aggStats["remove"]))
                r.logger.Info("Sucess &amp; Failure",
                        zap.Int64("success", aggStats["success"]),
                        zap.Int64("failure", aggStats["failure"]))</span>
        }<span class="cov0" title="0"> else {
                r.logger.Info("No devices replicating.")
        }</span>
}

func (r *Replicator) runLoopCheck(reportTimer &lt;-chan time.Time) <span class="cov8" title="1">{
        select </span>{
        case device := &lt;-r.checkin:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.lastCheckin = time.Now()
                }</span>
        case device := &lt;-r.startRun:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.runStarted = time.Now()
                        rd.lastCheckin = time.Now()
                        for k, v := range rd.stats </span><span class="cov8" title="1">{
                                rd.stats[k] = 0
                                rd.stats["lifetime_"+k] += v
                        }</span>
                        <span class="cov8" title="1">rd.stats["lifetime_passes"]++</span>
                }
        case update := &lt;-r.sendStat:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[update.device]; ok </span><span class="cov8" title="1">{
                        rd.stats[update.stat] += update.value
                }</span>
        case &lt;-reportTimer:<span class="cov8" title="1">
                r.reportStats()
                r.verifyDevices()</span>
        }
}

// RunForever runs the replicator in a forever-loop.
func (r *Replicator) RunForever() <span class="cov0" title="0">{
        reportTimer := time.NewTimer(time.Minute * 15)
        r.verifyDevices()
        for </span><span class="cov0" title="0">{
                r.runLoopCheck(reportTimer.C)
        }</span>
}

// Run runs a pass of the replicator once.
func (r *Replicator) Run() <span class="cov8" title="1">{
        done := make(chan struct{})
        devices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                go func(rd *replicationDevice) </span><span class="cov8" title="1">{
                        rd.replicate()
                        done &lt;- struct{}{}
                }</span>(r.runningDevices[dev.Device])
        }
        <span class="cov8" title="1">waitingFor := len(devices)
        for waitingFor &gt; 0 </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-r.checkin:</span><span class="cov0" title="0">
                case &lt;-r.startRun:</span><span class="cov8" title="1">
                case update := &lt;-r.sendStat:<span class="cov0" title="0">
                        if ctx, ok := r.runningDevices[update.device]; ok </span><span class="cov0" title="0">{
                                ctx.stats[update.stat] += update.value
                        }</span>
                case &lt;-done:<span class="cov8" title="1">
                        waitingFor--</span>
                }
        }
        <span class="cov8" title="1">r.reportStats()</span>
}

// GetReplicator uses the config settings and command-line flags to configure and return a replicator daemon struct.
func GetReplicator(serverconf conf.Config, flags *flag.FlagSet) (srv.Daemon, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        if !serverconf.HasSection("container-replicator") </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("Unable to find container-replicator config section")
        }</span>
        <span class="cov8" title="1">hashPathPrefix, hashPathSuffix, err := GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("Unable to get hash prefix and suffix")
        }</span>
        <span class="cov8" title="1">ring, err := GetRing("container", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error loading container ring")
        }</span>
        <span class="cov8" title="1">concurrency := int(serverconf.GetInt("container-replicator", "concurrency", 4))

        logLevelString := serverconf.GetDefault("container-replicator", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))

        var logger srv.LowLevelLogger
        if logger, err = srv.SetupLogger("container-replicator", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;Replicator{
                runningDevices: make(map[string]*replicationDevice),
                perUsync:       3000,
                maxUsyncs:      25,
                sendStat:       make(chan statUpdate),
                checkin:        make(chan string),
                startRun:       make(chan string),
                reconCachePath: serverconf.GetDefault("container-replicator", "recon_cache_path", "/var/cache/swift"),
                checkMounts:    serverconf.GetBool("container-replicator", "mount_check", true),
                deviceRoot:     serverconf.GetDefault("container-replicator", "devices", "/srv/node"),
                serverPort:     int(serverconf.GetInt("container-replicator", "bind_port", 6000)),
                reclaimAge:     serverconf.GetInt("container-replicator", "reclaim_age", 604800),
                logger:         logger,
                concurrencySem: make(chan struct{}, concurrency),
                Ring:           ring,
                client: &amp;http.Client{
                        Timeout:   time.Minute * 15,
                        Transport: &amp;http.Transport{Dial: (&amp;net.Dialer{Timeout: time.Second}).Dial},
                },
        }, logger, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "database/sql"
        "fmt"
        "strings"
)

const (
        policyStatTableScript = `
                CREATE TABLE policy_stat (
                        storage_policy_index INTEGER PRIMARY KEY,
                        object_count INTEGER DEFAULT 0,
                        bytes_used INTEGER DEFAULT 0
                );`

        policyStatTriggerScript = `
                CREATE TRIGGER object_insert_policy_stat AFTER INSERT ON object
                BEGIN
                        UPDATE policy_stat
                        SET object_count = object_count + (1 - new.deleted),
                                bytes_used = bytes_used + new.size
                        WHERE storage_policy_index = new.storage_policy_index;
                        INSERT INTO policy_stat (
                                storage_policy_index, object_count, bytes_used)
                        SELECT new.storage_policy_index,
                                   (1 - new.deleted),
                                   new.size
                        WHERE NOT EXISTS(
                                SELECT changes() as change
                                FROM policy_stat
                                WHERE change &lt;&gt; 0
                        );
                        UPDATE container_info
                        SET hash = chexor(hash, new.name, new.created_at);
                END;
                CREATE TRIGGER object_delete_policy_stat AFTER DELETE ON object
                BEGIN
                        UPDATE policy_stat
                        SET object_count = object_count - (1 - old.deleted),
                                bytes_used = bytes_used - old.size
                        WHERE storage_policy_index = old.storage_policy_index;
                        UPDATE container_info
                        SET hash = chexor(hash, old.name, old.created_at);
                END;`

        containerInfoTableScript = `
                CREATE TABLE container_info (
                        account TEXT,
                        container TEXT,
                        created_at TEXT,
                        put_timestamp TEXT DEFAULT '0',
                        delete_timestamp TEXT DEFAULT '0',
                        reported_put_timestamp TEXT DEFAULT '0',
                        reported_delete_timestamp TEXT DEFAULT '0',
                        reported_object_count INTEGER DEFAULT 0,
                        reported_bytes_used INTEGER DEFAULT 0,
                        hash TEXT default '00000000000000000000000000000000',
                        id TEXT,
                        status TEXT DEFAULT '',
                        status_changed_at TEXT DEFAULT '0',
                        metadata TEXT DEFAULT '{}',
                        x_container_sync_point1 INTEGER DEFAULT -1,
                        x_container_sync_point2 INTEGER DEFAULT -1,
                        storage_policy_index INTEGER DEFAULT 0,
                        reconciler_sync_point INTEGER DEFAULT -1
                );`

        containerStatViewScript = `
                CREATE VIEW container_stat
                AS SELECT ci.account, ci.container, ci.created_at,
                        ci.put_timestamp, ci.delete_timestamp,
                        ci.reported_put_timestamp, ci.reported_delete_timestamp,
                        ci.reported_object_count, ci.reported_bytes_used, ci.hash,
                        ci.id, ci.status, ci.status_changed_at, ci.metadata,
                        ci.x_container_sync_point1, ci.x_container_sync_point2,
                        ci.reconciler_sync_point,
                        ci.storage_policy_index,
                        coalesce(ps.object_count, 0) AS object_count,
                        coalesce(ps.bytes_used, 0) AS bytes_used
                FROM container_info ci LEFT JOIN policy_stat ps
                ON ci.storage_policy_index = ps.storage_policy_index;
                CREATE TRIGGER container_stat_update
                INSTEAD OF UPDATE ON container_stat
                BEGIN
                        UPDATE container_info
                        SET account = NEW.account,
                                container = NEW.container,
                                created_at = NEW.created_at,
                                put_timestamp = NEW.put_timestamp,
                                delete_timestamp = NEW.delete_timestamp,
                                reported_put_timestamp = NEW.reported_put_timestamp,
                                reported_delete_timestamp = NEW.reported_delete_timestamp,
                                reported_object_count = NEW.reported_object_count,
                                reported_bytes_used = NEW.reported_bytes_used,
                                hash = NEW.hash,
                                id = NEW.id,
                                status = NEW.status,
                                status_changed_at = NEW.status_changed_at,
                                metadata = NEW.metadata,
                                x_container_sync_point1 = NEW.x_container_sync_point1,
                                x_container_sync_point2 = NEW.x_container_sync_point2,
                                storage_policy_index = NEW.storage_policy_index,
                                reconciler_sync_point = NEW.reconciler_sync_point;
                END;`

        objectTableScript = `
                CREATE TABLE object (
                                ROWID INTEGER PRIMARY KEY AUTOINCREMENT,
                                name TEXT,
                                created_at TEXT,
                                size INTEGER,
                                content_type TEXT,
                                etag TEXT,
                                deleted INTEGER DEFAULT 0,
                                storage_policy_index INTEGER DEFAULT 0
                        );
                CREATE INDEX ix_object_deleted_name ON object (deleted, name);
                CREATE TRIGGER object_update BEFORE UPDATE ON object
                        BEGIN
                                SELECT RAISE(FAIL, 'UPDATE not allowed; DELETE and INSERT');
                        END;`

        syncTableScript = `        
                CREATE TABLE outgoing_sync (
                                remote_id TEXT UNIQUE,
                                sync_point INTEGER,
                                updated_at TEXT DEFAULT 0
                        );
                CREATE TABLE incoming_sync (
                                remote_id TEXT UNIQUE,
                                sync_point INTEGER,
                                updated_at TEXT DEFAULT 0
                        );
                CREATE TRIGGER outgoing_sync_insert AFTER INSERT ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER outgoing_sync_update AFTER UPDATE ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER incoming_sync_insert AFTER INSERT ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER incoming_sync_update AFTER UPDATE ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;`

        policyMigrateColumns = `account, container, created_at, put_timestamp, delete_timestamp, reported_put_timestamp,
                reported_object_count, reported_bytes_used, hash, id, status, status_changed_at, metadata,
                x_container_sync_point1, x_container_sync_point2`

        policyMigrateScript = policyStatTableScript +
                "INSERT INTO policy_stat (storage_policy_index, object_count, bytes_used) SELECT 0, object_count, bytes_used FROM container_stat;" +
                "ALTER TABLE object ADD COLUMN storage_policy_index INTEGER DEFAULT 0;" +
                "DROP TRIGGER object_insert;" +
                "DROP TRIGGER object_delete;" +
                policyStatTriggerScript +
                containerInfoTableScript +
                "INSERT INTO container_info (" + policyMigrateColumns + ") SELECT " + policyMigrateColumns + " FROM container_stat;" +
                "DROP TABLE IF EXISTS container_stat;" +
                containerStatViewScript

        syncPointMigrateScript = `
                ALTER TABLE container_stat ADD COLUMN x_container_sync_point1 INTEGER DEFAULT -1;
                ALTER TABLE container_stat ADD COLUMN x_container_sync_point2 INTEGER DEFAULT -1;`

        metadataMigrateScript = "ALTER TABLE container_stat ADD COLUMN metadata DEFAULT '{}';"

        pragmaScript = `
                PRAGMA synchronous = NORMAL;
                PRAGMA cache_size = -4096;
                PRAGMA temp_store = MEMORY;
                PRAGMA journal_mode = WAL;
                PRAGMA busy_timeout = 25000;`
)

func schemaMigrate(db *sql.DB) (bool, error) <span class="cov8" title="1">{
        hasDeletedNameIndex := false
        hasSyncPoints := false
        hasMetadata := false
        hasPolicyStat := false

        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // We just pull the schema out of sqlite_master and look at it to get the current state of the database.
        rows, err := tx.Query("SELECT name, sql FROM sqlite_master WHERE name in ('policy_stat', 'ix_object_deleted_name', 'container_stat')")
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var name, sql string
                if err := rows.Scan(&amp;name, &amp;sql); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if name == "policy_stat" </span><span class="cov8" title="1">{
                        hasPolicyStat = true
                }</span><span class="cov8" title="1"> else if name == "ix_object_deleted_name" </span><span class="cov8" title="1">{
                        hasDeletedNameIndex = true
                }</span><span class="cov8" title="1"> else if name == "container_stat" </span><span class="cov8" title="1">{
                        hasSyncPoints = strings.Contains(sql, "x_container_sync_point1")
                        hasMetadata = strings.Contains(sql, "metadata")
                }</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return hasDeletedNameIndex, err
        }</span>
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return hasDeletedNameIndex, err
        }</span>

        <span class="cov8" title="1">if hasSyncPoints &amp;&amp; hasMetadata &amp;&amp; hasPolicyStat </span><span class="cov8" title="1">{
                return hasDeletedNameIndex, nil
        }</span>

        <span class="cov8" title="1">if !hasSyncPoints </span><span class="cov8" title="1">{
                if _, err := tx.Exec(syncPointMigrateScript); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Adding sync_point columns: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if !hasMetadata </span><span class="cov8" title="1">{
                if _, err := tx.Exec(metadataMigrateScript); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Adding metadata column: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if !hasPolicyStat </span><span class="cov8" title="1">{
                if _, err = tx.Exec(policyMigrateScript); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Performing policy migration: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return hasDeletedNameIndex, tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "encoding/json"
        "encoding/xml"
        "flag"
        "fmt"
        "net"
        "net/http"
        _ "net/http/pprof" // install pprof http handlers
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/justinas/alice"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

// GetHashPrefixAndSuffix is a pointer to hummingbird's function of the same name, for overriding in tests.
var GetHashPrefixAndSuffix = conf.GetHashPrefixAndSuffix

// GetSyncRealms is a pointer to hummingbird's function of the same name, for overriding in tests.
var GetSyncRealms = conf.GetSyncRealms

// LoadPolicies is a pointer to hummingbird's function of the same name, for overriding in tests.
var LoadPolicies = conf.LoadPolicies

// ContainerServer contains all of the information for a running container server.
type ContainerServer struct {
        driveRoot        string
        hashPathPrefix   string
        hashPathSuffix   string
        logger           srv.LowLevelLogger
        logLevel         zap.AtomicLevel
        diskInUse        *common.KeyedLimit
        checkMounts      bool
        containerEngine  ContainerEngine
        updateClient     *http.Client
        autoCreatePrefix string
        syncRealms       conf.SyncRealmList
        defaultPolicy    int
        policyList       conf.PolicyList
}

var saveHeaders = map[string]bool{
        "X-Container-Read":     true,
        "X-Container-Write":    true,
        "X-Container-Sync-Key": true,
        "X-Container-Sync-To":  true,
        "X-Versions-Location":  true,
        "X-History-Location":   true,
}

func formatTimestamp(ts string) string <span class="cov8" title="1">{
        if len(ts) == 16 &amp;&amp; ts[10] == '.' </span><span class="cov8" title="1">{
                return ts
        }</span>
        <span class="cov8" title="1">t, err := strconv.ParseFloat(ts, 64)
        if err != nil </span><span class="cov8" title="1">{
                return "0000000000.00000"
        }</span>
        <span class="cov8" title="1">ret := strconv.FormatFloat(t, 'f', 5, 64)
        if len(ret) &lt; 16 </span><span class="cov8" title="1">{
                return strings.Repeat("0", 16-len(ret)) + ret
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (server *ContainerServer) Finalize() <span class="cov0" title="0">{
}</span>

// ContainerGetHandler handles GET and HEAD requests for a container.
func (server *ContainerServer) ContainerGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if err := request.ParseForm(); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container info.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers := writer.Header()
        if lastModified, err := common.ParseDate(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("Last-Modified", common.FormatLastModified(lastModified))
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Put-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.DeleteTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Delete-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.StatusChangedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Status-Changed-At", ts)
        }</span>
        <span class="cov8" title="1">headers.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(info.StoragePolicyIndex))
        if policy := server.policyList[info.StoragePolicyIndex]; policy != nil </span><span class="cov0" title="0">{
                headers.Set("X-Storage-Policy", policy.Name)
        }</span>
        <span class="cov8" title="1">metadata, err := db.GetMetadata()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get metadata.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                headers.Set(key, value)
        }</span>
        <span class="cov8" title="1">if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span><span class="cov8" title="1"> else if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else {
                headers.Set("X-Container-Object-Count", strconv.FormatInt(info.ObjectCount, 10))
                headers.Set("X-Container-Bytes-Used", strconv.FormatInt(info.BytesUsed, 10))
                if ts, err := common.GetEpochFromTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Timestamp", ts)
                }</span>
                <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Put-Timestamp", ts)
                }</span>
        }
        <span class="cov8" title="1">if request.Method == "HEAD" </span><span class="cov8" title="1">{
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
                return
        }</span>
        <span class="cov8" title="1">limit, _ := strconv.ParseInt(request.FormValue("limit"), 10, 64)
        if limit &lt;= 0 || limit &gt; 10000 </span><span class="cov8" title="1">{
                limit = 10000
        }</span>
        <span class="cov8" title="1">marker := request.Form.Get("marker")
        delimiter := request.Form.Get("delimiter")
        endMarker := request.Form.Get("end_marker")
        prefix := request.Form.Get("prefix")
        var path *string
        if v, ok := request.Form["path"]; ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                path = &amp;v[0]
        }</span>
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = info.StoragePolicyIndex
        }</span>
        <span class="cov8" title="1">reverse := common.LooksTrue(request.Form.Get("reverse"))
        objects, err := db.ListObjects(int(limit), marker, endMarker, prefix, delimiter, path, reverse, policyIndex)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to list objects.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">format := request.Form.Get("format")
        if format == "" </span><span class="cov8" title="1">{ /* TODO: real accept parsing */
                accept := request.Header.Get("Accept")
                if strings.Contains(accept, "application/json") </span><span class="cov8" title="1">{
                        format = "json"
                }</span><span class="cov8" title="1"> else if strings.Contains(accept, "application/xml") || strings.Contains(accept, "text/xml") </span><span class="cov0" title="0">{
                        format = "xml"
                }</span><span class="cov8" title="1"> else {
                        format = "text"
                }</span>
        }
        <span class="cov8" title="1">if format == "text" </span><span class="cov8" title="1">{
                response := ""
                for _, obj := range objects </span><span class="cov8" title="1">{
                        if or, ok := obj.(*ObjectListingRecord); ok </span><span class="cov8" title="1">{
                                response += or.Name + "\n"
                        }</span><span class="cov0" title="0"> else if sr, ok := obj.(*SubdirListingRecord); ok </span><span class="cov0" title="0">{
                                response += sr.Name + "\n"
                        }</span>
                }
                <span class="cov8" title="1">if len(response) &gt; 0 </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", strconv.Itoa(len(response)))
                        writer.WriteHeader(200)
                        writer.Write([]byte(response))
                }</span><span class="cov8" title="1"> else {
                        headers.Set("Content-Length", "0")
                        writer.WriteHeader(204)
                        writer.Write([]byte(""))
                }</span>
        }<span class="cov8" title="1"> else if format == "json" </span><span class="cov8" title="1">{
                output, err := json.Marshal(objects)
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">headers.Set("Content-Type", "application/json; charset=utf-8")
                headers.Set("Content-Length", strconv.Itoa(len(output)))
                writer.WriteHeader(200)
                writer.Write(output)</span>
        }<span class="cov8" title="1"> else if format == "xml" </span><span class="cov8" title="1">{
                type Container struct {
                        XMLName xml.Name `xml:"container"`
                        Name    string   `xml:"name,attr"`
                        Objects []interface{}
                }
                container := &amp;Container{Name: vars["container"], Objects: objects}
                writer.Header().Set("Content-Type", "application/xml; charset=utf-8")
                output, _ := xml.Marshal(container)
                headers.Set("Content-Length", strconv.Itoa(len(output)+39))
                writer.WriteHeader(200)
                writer.Write([]byte("&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"))
                writer.Write(output)
        }</span>
}

// ContainerPutHandler handles PUT requests for a container.
func (server *ContainerServer) ContainerPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if syncTo := request.Header.Get("X-Container-Sync-To"); syncTo != "" </span><span class="cov8" title="1">{
                if !server.syncRealms.ValidateSyncTo(syncTo) </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                        return
                }</span>
        }
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = -1
        }</span>
        <span class="cov8" title="1">defaultPolicyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Default"))
        if err != nil </span><span class="cov8" title="1">{
                defaultPolicyIndex = server.defaultPolicy
        }</span>
        <span class="cov8" title="1">metadata := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Container-Meta-") || strings.HasPrefix(key, "X-Container-Sysmeta-") || saveHeaders[key] </span><span class="cov8" title="1">{
                        metadata[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">created, db, err := server.containerEngine.Create(vars, timestamp, metadata, policyIndex, defaultPolicyIndex)
        if err == ErrorPolicyConflict </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusConflict)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create database.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if info, err := db.GetInfo(); err == nil </span><span class="cov8" title="1">{
                server.accountUpdate(writer, request, vars, info, srv.GetLogger(request))
        }</span>
        <span class="cov8" title="1">if created </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusCreated)
        }</span><span class="cov8" title="1"> else {
                srv.StandardResponse(writer, http.StatusAccepted)
        }</span>
}

// ContainerDeleteHandler handles DELETE requests for the container.
func (server *ContainerServer) ContainerDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container info.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if info.ObjectCount &gt; 0 </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusConflict)
                return
        }</span>
        <span class="cov8" title="1">if err = db.Delete(timestamp); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to delete database.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">info, err = db.GetInfo()
        if err == nil </span><span class="cov8" title="1">{
                server.accountUpdate(writer, request, vars, info, srv.GetLogger(request))
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(http.StatusNoContent)
        writer.Write([]byte(""))</span>
}

// ContainerPostHandler handles POST requests for a container.
func (server *ContainerServer) ContainerPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if syncTo := request.Header.Get("X-Container-Sync-To"); syncTo != "" </span><span class="cov8" title="1">{
                if !server.syncRealms.ValidateSyncTo(syncTo) </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                        return
                }</span>
        }
        <span class="cov8" title="1">updates := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Container-Meta-") || strings.HasPrefix(key, "X-Container-Sysmeta") || saveHeaders[key] </span><span class="cov8" title="1">{
                        updates[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span><span class="cov8" title="1"> else if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err := db.UpdateMetadata(updates, timestamp); err == ErrorInvalidMetadata </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span><span class="cov8" title="1"> else {
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
        }</span>
}

// ObjPutHandler handles the PUT of object records to a container.
func (server *ContainerServer) ObjPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">contentType := request.Header.Get("X-Content-Type")
        etag := request.Header.Get("X-Etag")
        size, err := strconv.ParseInt(request.Header.Get("X-Size"), 10, 64)
        if err != nil || contentType == "" || etag == "" </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = 0
        }</span>
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                if strings.HasPrefix(vars["account"], server.autoCreatePrefix) </span><span class="cov8" title="1">{
                        if _, db, err = server.containerEngine.Create(vars, timestamp, map[string][]string{}, policyIndex, 0); err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Unable to auto-create container.", zap.Error(err))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return
                        }</span>
                }<span class="cov8" title="1"> else {
                        srv.StandardResponse(writer, http.StatusNotFound)
                        return
                }</span>
        }<span class="cov8" title="1"> else if err != nil </span><span class="cov8" title="1">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if err := db.PutObject(vars["obj"], timestamp, size, contentType, etag, policyIndex); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error adding object to container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, http.StatusCreated)</span>
}

// ObjDeleteHandler handles the DELETE of object records in a container.
func (server *ContainerServer) ObjDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = 0
        }</span>
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                if strings.HasPrefix(vars["account"], server.autoCreatePrefix) </span><span class="cov8" title="1">{
                        if _, db, err = server.containerEngine.Create(vars, timestamp, map[string][]string{}, policyIndex, 0); err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Unable to auto-create container.", zap.Error(err))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return
                        }</span>
                }<span class="cov8" title="1"> else {
                        srv.StandardResponse(writer, http.StatusNotFound)
                        return
                }</span>
        }<span class="cov8" title="1"> else if err != nil </span><span class="cov8" title="1">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if err := db.DeleteObject(vars["obj"], timestamp, policyIndex); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error adding object to container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(http.StatusNoContent)
        writer.Write([]byte(""))</span>
}

// HealthcheckHandler implements a basic health check, that just returns "OK".
func (server *ContainerServer) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

// ReconHandler delegates incoming /recon calls to the common recon handler.
func (server *ContainerServer) ReconHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.ReconHandler(server.driveRoot, writer, request)
}</span>

//OptionsHandler delegates incoming OPTIONS calls to the common options handler.
func (server *ContainerServer) OptionsHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.OptionsHandler("container-server", writer, request)
        return
}</span>

// DiskUsageHandler returns information on the current outstanding HTTP requests per-disk.
func (server *ContainerServer) DiskUsageHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if data, err := server.diskInUse.MarshalJSON(); err == nil </span><span class="cov8" title="1">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
        }</span><span class="cov0" title="0"> else {
                writer.WriteHeader(http.StatusInternalServerError)
                writer.Write([]byte(err.Error()))
        }</span>
}

// LogRequest is a middleware that logs requests and also sets up a logger in the request context.
func (server *ContainerServer) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                newWriter := &amp;srv.WebWriter{ResponseWriter: writer, Status: 500, ResponseStarted: false}
                start := time.Now()
                logr := server.logger.With(zap.String("txn", request.Header.Get("X-Trans-Id")))
                request = srv.SetLogger(request, logr)
                next.ServeHTTP(newWriter, request)
                forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                lvl, _ := server.logLevel.MarshalText()
                if (request.Method != "REPLICATE" &amp;&amp; request.Method != "REPCONN") || strings.ToUpper(string(lvl)) == "DEBUG" </span><span class="cov8" title="1">{
                        extraInfo := "-"
                        if forceAcquire </span><span class="cov0" title="0">{
                                extraInfo = "FA"
                        }</span>
                        <span class="cov8" title="1">logr.Info("Request log",
                                zap.String("remoteAddr", request.RemoteAddr),
                                zap.String("eventTime", time.Now().Format("02/Jan/2006:15:04:05 -0700")),
                                zap.String("method", request.Method),
                                zap.String("urlPath", common.Urlencode(request.URL.Path)),
                                zap.Int("status", newWriter.Status),
                                zap.String("contentLength", common.GetDefault(newWriter.Header(), "Content-Length", "-")),
                                zap.String("referer", common.GetDefault(request.Header, "Referer", "-")),
                                zap.String("userAgent", common.GetDefault(request.Header, "User-Agent", "-")),
                                zap.Float64("requestTimeSeconds", time.Since(start).Seconds()),
                                zap.String("extraInfo", extraInfo))</span>
                }
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

// AcquireDevice is a middleware that makes sure the device is available - mounted and not beyond its max concurrency.
func (server *ContainerServer) AcquireDevice(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                vars := srv.GetVars(request)
                if device, ok := vars["device"]; ok &amp;&amp; device != "" </span><span class="cov8" title="1">{
                        devicePath := filepath.Join(server.driveRoot, device)
                        if server.checkMounts </span><span class="cov0" title="0">{
                                if mounted, err := fs.IsMount(devicePath); err != nil || !mounted </span><span class="cov0" title="0">{
                                        vars["Method"] = request.Method
                                        srv.CustomErrorResponse(writer, 507, vars)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                        if concRequests := server.diskInUse.Acquire(device, forceAcquire); concRequests != 0 </span><span class="cov0" title="0">{
                                writer.Header().Set("X-Disk-Usage", strconv.FormatInt(concRequests, 10))
                                srv.StandardResponse(writer, 503)
                                return
                        }</span>
                        <span class="cov8" title="1">defer server.diskInUse.Release(device)</span>
                }
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (server *ContainerServer) updateDeviceLocks(seconds int64) <span class="cov0" title="0">{
        reloadTime := time.Duration(seconds) * time.Second
        for </span><span class="cov0" title="0">{
                time.Sleep(reloadTime)
                for _, key := range server.diskInUse.Keys() </span><span class="cov0" title="0">{
                        lockPath := filepath.Join(server.driveRoot, key, "lock_device")
                        if fs.Exists(lockPath) </span><span class="cov0" title="0">{
                                server.diskInUse.Lock(key)
                        }</span><span class="cov0" title="0"> else {
                                server.diskInUse.Unlock(key)
                        }</span>
                }
        }
}

// GetHandler returns the server's http handler - it sets up routes and instantiates middleware.
func (server *ContainerServer) GetHandler(config conf.Config) http.Handler <span class="cov8" title="1">{
        commonHandlers := alice.New(server.LogRequest, middleware.RecoverHandler, middleware.ValidateRequest, server.AcquireDevice)
        router := srv.NewRouter()
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/diskusage", commonHandlers.ThenFunc(server.DiskUsageHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        router.Get("/recon/:method/:recon_type", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/recon/:method", commonHandlers.ThenFunc(server.ReconHandler))
        router.Put("/:device/tmp/:filename", commonHandlers.ThenFunc(server.ContainerTmpUploadHandler))
        router.Put("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjPutHandler))
        router.Delete("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjDeleteHandler))
        router.Put("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerPutHandler))
        router.Get("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerGetHandler))
        router.Head("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerGetHandler))
        router.Delete("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerDeleteHandler))
        router.Post("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerPostHandler))
        router.Replicate("/:device/:partition/:hash", commonHandlers.ThenFunc(server.ContainerReplicateHandler))
        router.Options("/", commonHandlers.ThenFunc(server.OptionsHandler))
        router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Invalid path: %s", r.URL.Path), http.StatusBadRequest)
        }</span>)
        <span class="cov8" title="1">return alice.New(middleware.GrepObject).Then(router)</span>
}

// GetServer parses configs and command-line flags, returning a configured server object and the ip and port it should bind on.
func GetServer(serverconf conf.Config, flags *flag.FlagSet) (bindIP string, bindPort int, serv srv.Server, logger srv.LowLevelLogger, err error) <span class="cov8" title="1">{
        server := &amp;ContainerServer{driveRoot: "/srv/node", hashPathPrefix: "", hashPathSuffix: "", policyList: conf.LoadPolicies()}
        server.syncRealms = GetSyncRealms()
        server.hashPathPrefix, server.hashPathSuffix, err = GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, err
        }</span>
        <span class="cov8" title="1">policies := LoadPolicies()
        server.defaultPolicy = policies.Default()
        server.autoCreatePrefix = serverconf.GetDefault("app:container-server", "auto_create_account_prefix", ".")
        server.driveRoot = serverconf.GetDefault("app:container-server", "devices", "/srv/node")
        server.checkMounts = serverconf.GetBool("app:container-server", "mount_check", true)

        logLevelString := serverconf.GetDefault("app:container-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))

        if server.logger, err = srv.SetupLogger("container-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>

        <span class="cov8" title="1">server.diskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:container-server", "disk_limit", 25, 10000))
        bindIP = serverconf.GetDefault("app:container-server", "bind_ip", "0.0.0.0")
        bindPort = int(serverconf.GetInt("app:container-server", "bind_port", 6000))

        server.containerEngine = newLRUEngine(server.driveRoot, server.hashPathPrefix, server.hashPathSuffix, 32)
        connTimeout := time.Duration(serverconf.GetFloat("app:container-server", "conn_timeout", 1.0) * float64(time.Second))
        nodeTimeout := time.Duration(serverconf.GetFloat("app:container-server", "node_timeout", 10.0) * float64(time.Second))
        server.updateClient = &amp;http.Client{
                Timeout:   nodeTimeout,
                Transport: &amp;http.Transport{Dial: (&amp;net.Dialer{Timeout: connTimeout}).Dial},
        }
        return bindIP, bindPort, server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "crypto/md5"
        "database/sql"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/mattn/go-sqlite3"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
)

const (
        maxQueryArgs       = 990
        maxOpenConns       = 2
        maxIdleConns       = 2
        pendingCap         = 131072
        maxMetaCount       = 90
        maxMetaOverallSize = 4096
)

var infoCacheTimeout = time.Second * 10

func chexor(old, name, timestamp string) string <span class="cov8" title="1">{
        oldDigest, err := hex.DecodeString(old)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error decoding hex: %v", err))</span>
        }
        <span class="cov8" title="1">h := md5.New()
        if _, err := io.WriteString(h, name+"-"+timestamp); err != nil </span><span class="cov0" title="0">{
                panic("THIS SHOULD NEVER HAPPEN")</span>
        }
        <span class="cov8" title="1">digest := h.Sum(nil)
        for i := range digest </span><span class="cov8" title="1">{
                digest[i] ^= oldDigest[i]
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(digest)</span>
}

func init() <span class="cov8" title="1">{
        // register our sql driver with user-defined chexor function
        sql.Register("sqlite3_hummingbird",
                &amp;sqlite3.SQLiteDriver{
                        ConnectHook: func(conn *sqlite3.SQLiteConn) error </span><span class="cov8" title="1">{
                                if err := conn.RegisterFunc("chexor", chexor, true); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(pragmaScript, nil); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(`CREATE TEMPORARY VIEW IF NOT EXISTS maxrowid (max) AS
                                                                                  SELECT IFNULL(MAX(seq), -1) FROM sqlite_sequence WHERE name='object'`, nil); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
        )
}

// SqliteContainer wraps a connection to the underlying database and provides all of the operations on that database.
type sqliteContainer struct {
        connectLock sync.Mutex
        *sql.DB
        containerFile       string
        hasDeletedNameIndex bool
        infoCache           atomic.Value
        ringhash            string
}

var _ Container = &amp;sqliteContainer{}

func (db *sqliteContainer) connect() error <span class="cov8" title="1">{
        db.connectLock.Lock()
        defer db.connectLock.Unlock()
        if db.DB != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">dbConn, err := sql.Open("sqlite3_hummingbird", "file:"+db.containerFile+"?psow=1&amp;_txlock=immediate&amp;mode=rw")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to open: %v", err)
        }</span>
        <span class="cov8" title="1">dbConn.SetMaxOpenConns(maxOpenConns)
        dbConn.SetMaxIdleConns(maxIdleConns)
        hasDeletedNameIndex, err := schemaMigrate(dbConn)
        if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return fmt.Errorf("Error migrating database: %v", err)
        }</span>
        <span class="cov8" title="1">db.hasDeletedNameIndex = hasDeletedNameIndex
        db.DB = dbConn
        return nil</span>
}

// GetInfo returns the container's information as a ContainerInfo struct.
func (db *sqliteContainer) GetInfo() (*ContainerInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := db.flush(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if info, ok := db.infoCache.Load().(*ContainerInfo); ok &amp;&amp; !info.invalid &amp;&amp; time.Since(info.updated) &lt; infoCacheTimeout </span><span class="cov8" title="1">{
                return info, nil
        }</span>
        <span class="cov8" title="1">info := &amp;ContainerInfo{updated: time.Now()}
        row := db.QueryRow(`SELECT cs.account, cs.container, cs.created_at, cs.put_timestamp,
                                                        cs.delete_timestamp, cs.status_changed_at,
                                                        cs.object_count, cs.bytes_used,
                                                        cs.reported_put_timestamp, cs.reported_delete_timestamp,
                                                        cs.reported_object_count, cs.reported_bytes_used, cs.hash,
                                                        cs.id, cs.x_container_sync_point1, cs.x_container_sync_point2,
                                                        cs.storage_policy_index, cs.metadata, maxrowid.max
                                                FROM container_stat cs, maxrowid`)
        if err := row.Scan(&amp;info.Account, &amp;info.Container, &amp;info.CreatedAt, &amp;info.PutTimestamp,
                &amp;info.DeleteTimestamp, &amp;info.StatusChangedAt, &amp;info.ObjectCount,
                &amp;info.BytesUsed, &amp;info.ReportedPutTimestamp, &amp;info.ReportedDeleteTimestamp,
                &amp;info.ReportedObjectCount, &amp;info.ReportedBytesUsed, &amp;info.Hash,
                &amp;info.ID, &amp;info.XContainerSyncPoint1, &amp;info.XContainerSyncPoint2,
                &amp;info.StoragePolicyIndex, &amp;info.RawMetadata, &amp;info.MaxRow); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if info.RawMetadata == "" </span><span class="cov0" title="0">{
                info.Metadata = make(map[string][]string)
        }</span><span class="cov8" title="1"> else if err := json.Unmarshal([]byte(info.RawMetadata), &amp;info.Metadata); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db.infoCache.Store(info)
        return info, nil</span>
}

func (db *sqliteContainer) invalidateCache() <span class="cov8" title="1">{
        db.infoCache.Store(&amp;ContainerInfo{invalid: true})
}</span>

// IsDeleted returns true if the container is deleted - if its delete timestamp is later than its put timestamp.
func (db *sqliteContainer) IsDeleted() (bool, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return info.DeleteTimestamp &gt; info.PutTimestamp, nil</span>
}

// Delete sets the container's deleted timestamp and tombstones any metadata older than that timestamp.
// This may or may not make the container "deleted".
func (db *sqliteContainer) Delete(timestamp string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var metastr string
        var metadata map[string][]string
        if err := tx.QueryRow("SELECT metadata FROM container_info").Scan(&amp;metastr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                if value[1] &lt; timestamp </span><span class="cov8" title="1">{
                        metadata[key] = []string{"", timestamp}
                }</span>
        }
        <span class="cov8" title="1">serializedMetadata, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE container_info SET delete_timestamp = ?, metadata = ?", timestamp, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// MergeItems merges ObjectRecords into the container.  If a remote id is provided (incoming replication), the incoming_sync table is updated.
func (db *sqliteContainer) MergeItems(records []*ObjectRecord, remoteID string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">type recordID struct {
                policy int
                name   string
        }
        names := make([]interface{}, len(records))
        existing := make(map[recordID]*ObjectRecord)
        toAdd := make(map[recordID]*ObjectRecord)
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for i, record := range records </span><span class="cov8" title="1">{
                names[i] = record.Name
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(records); i += maxQueryArgs </span><span class="cov8" title="1">{
                j := i + maxQueryArgs
                if j &gt; len(records) </span><span class="cov8" title="1">{
                        j = len(records)
                }</span>
                <span class="cov8" title="1">batch := names[i:j]
                query := ""
                if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                        query = fmt.Sprintf("SELECT name, storage_policy_index, created_at, ROWID FROM object WHERE deleted IN (0, 1) AND name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span><span class="cov0" title="0"> else {
                        query = fmt.Sprintf("SELECT name, storage_policy_index, created_at, ROWID FROM object WHERE name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span>
                <span class="cov8" title="1">rows, err := tx.Query(query, batch...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                        var name, timestamp string
                        var rowid int64
                        var policy int
                        if err := rows.Scan(&amp;name, &amp;policy, &amp;timestamp, &amp;rowid); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">existing[recordID{policy, name}] = &amp;ObjectRecord{CreatedAt: timestamp, Rowid: rowid}</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">dst, err := tx.Prepare("DELETE FROM object WHERE ROWID=?")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dst.Close()

        ast, err := tx.Prepare("INSERT INTO object (name, created_at, size, content_type, etag, deleted, storage_policy_index) VALUES (?, ?, ?, ?, ?, ?, ?)")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer ast.Close()

        var maxRowid int64 = -1
        for _, record := range records </span><span class="cov8" title="1">{
                if record.Rowid &gt; maxRowid </span><span class="cov8" title="1">{
                        maxRowid = record.Rowid
                }</span>
                <span class="cov8" title="1">rid := recordID{record.StoragePolicyIndex, record.Name}
                if alreadyIn, ok := toAdd[rid]; !ok || record.CreatedAt &gt; alreadyIn.CreatedAt </span><span class="cov8" title="1">{
                        current, inExisting := existing[rid]
                        if inExisting &amp;&amp; current.CreatedAt &lt; record.CreatedAt </span><span class="cov8" title="1">{
                                if _, err := dst.Exec(current.Rowid); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">delete(existing, rid)
                                toAdd[rid] = record</span>
                        }<span class="cov8" title="1"> else if !inExisting </span><span class="cov8" title="1">{
                                toAdd[rid] = record
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, record := range toAdd </span><span class="cov8" title="1">{
                if _, err := ast.Exec(record.Name, record.CreatedAt, record.Size, record.ContentType, record.ETag, record.Deleted, record.StoragePolicyIndex); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if remoteID != "" &amp;&amp; maxRowid &gt; -1 </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        maxRowid, remoteID, remoteID, maxRowid); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

func indexAfter(s, sep string, after int) int <span class="cov8" title="1">{
        index := strings.Index(s[after:], sep)
        if index == -1 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return index + after</span>
}

func updateRecord(rec *ObjectListingRecord) error <span class="cov8" title="1">{
        f, err := strconv.ParseFloat(rec.LastModified, 64)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">whole, nans := math.Modf(f)
        rec.LastModified = time.Unix(int64(whole), int64(nans*1.0e9)).In(common.GMT).Format("2006-01-02T15:04:05.000000")

        rec.ContentType, rec.Size, err = common.ParseContentTypeForSlo(
                rec.ContentType, rec.Size)
        return err</span>
}

// ListObjects implements object listings.  Path is a string pointer because behavior is different for empty and missing path query parameters.
func (db *sqliteContainer) ListObjects(limit int, marker string, endMarker string, prefix string, delimiter string,
        path *string, reverse bool, storagePolicyIndex int) ([]interface{}, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var point, pointDirection, queryTail, queryStart string

        if path != nil </span><span class="cov8" title="1">{
                if *path != "" </span><span class="cov8" title="1">{
                        p := strings.TrimRight(*path, "/") + "/"
                        path = &amp;p
                }</span>
                <span class="cov8" title="1">delimiter = "/"
                prefix = *path</span>
        }
        <span class="cov8" title="1">if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                queryStart = "SELECT name, created_at, size, content_type, etag FROM object WHERE deleted = 0 AND"
        }</span><span class="cov0" title="0"> else {
                queryStart = "SELECT name, created_at, size, content_type, etag FROM object WHERE +deleted = 0 AND"
        }</span>
        <span class="cov8" title="1">if reverse </span><span class="cov8" title="1">{
                marker, endMarker = endMarker, marker
                queryTail = "ORDER BY name DESC LIMIT ?"
                pointDirection = "name &lt; ?"
        }</span><span class="cov8" title="1"> else {
                queryTail = "ORDER BY name LIMIT ?"
                pointDirection = "name &gt; ?"
        }</span>

        <span class="cov8" title="1">results := []interface{}{}
        queryArgs := make([]interface{}, 8)
        wheres := make([]string, 8)
        gotResults := true

        for len(results) &lt; limit &amp;&amp; gotResults </span><span class="cov8" title="1">{
                wheres := append(wheres[:0], "storage_policy_index == ?")
                queryArgs := append(queryArgs[:0], storagePolicyIndex)
                if prefix != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name BETWEEN ? AND ?")
                        queryArgs = append(queryArgs, prefix, prefix+"\xFF")
                }</span>
                <span class="cov8" title="1">if marker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &gt; ?")
                        queryArgs = append(queryArgs, marker)
                }</span>
                <span class="cov8" title="1">if endMarker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &lt; ?")
                        queryArgs = append(queryArgs, endMarker)
                }</span>
                <span class="cov8" title="1">if point != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, pointDirection)
                        queryArgs = append(queryArgs, point)
                }</span>
                <span class="cov8" title="1">rows, err := db.Query(queryStart+" "+strings.Join(wheres, " AND ")+" "+queryTail,
                        append(queryArgs, limit-len(results))...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">gotResults = false
                for rows.Next() &amp;&amp; len(results) &lt; limit </span><span class="cov8" title="1">{
                        gotResults = true
                        record := &amp;ObjectListingRecord{}
                        if err := rows.Scan(&amp;record.Name, &amp;record.LastModified, &amp;record.Size, &amp;record.ContentType, &amp;record.ETag); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">point = record.Name
                        if delimiter != "" </span><span class="cov8" title="1">{
                                if path != nil &amp;&amp; record.Name == *path </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">end := indexAfter(record.Name, delimiter, len(prefix))
                                if end &gt;= 0 &amp;&amp; (path == nil || len(record.Name) &gt; end+1) </span><span class="cov8" title="1">{
                                        dirName := record.Name[:end] + delimiter
                                        if reverse </span><span class="cov8" title="1">{
                                                point = record.Name[:end+len(delimiter)]
                                        }</span><span class="cov8" title="1"> else {
                                                point = dirName + "\xFF"
                                        }</span>
                                        <span class="cov8" title="1">if path == nil &amp;&amp; dirName != marker </span><span class="cov8" title="1">{
                                                results = append(results, &amp;SubdirListingRecord{Name2: dirName, Name: dirName})
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">if err := updateRecord(record); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">results = append(results, record)</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">rows.Close()
                if delimiter == "" &amp;&amp; path == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return results, nil</span>
}

// NewID sets the container's ID to a new, random string.
func (db *sqliteContainer) NewID() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        _, err = tx.Exec(`INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point)
                                          SELECT container_info.id, maxrowid.max FROM container_info, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE container_info SET id = ?", common.UUID()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// ItemsSince returns (count) object records with a rowid greater than (start).
func (db *sqliteContainer) ItemsSince(start int64, count int) ([]*ObjectRecord, error) <span class="cov8" title="1">{
        db.flush()
        records := []*ObjectRecord{}
        rows, err := db.Query(`SELECT ROWID, name, created_at, size, content_type, etag, deleted, storage_policy_index
                                                   FROM object WHERE ROWID &gt; ? ORDER BY ROWID ASC LIMIT ?`, start, count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                r := &amp;ObjectRecord{}
                if err := rows.Scan(&amp;r.Rowid, &amp;r.Name, &amp;r.CreatedAt, &amp;r.Size, &amp;r.ContentType, &amp;r.ETag, &amp;r.Deleted, &amp;r.StoragePolicyIndex); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">records = append(records, r)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rows.Close()
        return records, nil</span>
}

// GetMetadata returns the current container metadata as a simple map[string]string, i.e. it leaves out tombstones and timestamps.
func (db *sqliteContainer) GetMetadata() (map[string]string, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">metadata := make(map[string]string)
        for key, value := range info.Metadata </span><span class="cov8" title="1">{
                if value[0] != "" </span><span class="cov8" title="1">{
                        metadata[key] = value[0]
                }</span>
        }
        <span class="cov8" title="1">return metadata, nil</span>
}

func (db *sqliteContainer) mergeMetas(a map[string][]string, b map[string][]string, deleteTimestamp string) (string, error) <span class="cov8" title="1">{
        newMeta := map[string][]string{}
        for k, v := range a </span><span class="cov8" title="1">{
                newMeta[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if existing, ok := a[k]; ok </span><span class="cov8" title="1">{
                        if existing[1] &lt; v[1] </span><span class="cov8" title="1">{
                                newMeta[k] = v
                        }</span>
                }<span class="cov8" title="1"> else {
                        newMeta[k] = v
                }</span>
        }
        <span class="cov8" title="1">metaSize := 0
        metaCount := 0
        for k, v := range newMeta </span><span class="cov8" title="1">{
                if deleteTimestamp != "" &amp;&amp; v[1] &lt; deleteTimestamp </span><span class="cov8" title="1">{
                        newMeta[k] = []string{"", deleteTimestamp}
                }</span><span class="cov8" title="1"> else if v[0] != "" &amp;&amp; strings.HasPrefix(strings.ToLower(k), "x-container-meta-") </span><span class="cov8" title="1">{
                        metaSize += len(k) - 17
                        metaSize += len(v[0])
                        metaCount++
                }</span>
        }
        <span class="cov8" title="1">if metaCount &gt; maxMetaCount || metaSize &gt; maxMetaOverallSize </span><span class="cov0" title="0">{
                return "", ErrorInvalidMetadata
        }</span>
        <span class="cov8" title="1">serMeta, err := json.Marshal(newMeta)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(serMeta), nil</span>
}

// UpdateMetadata merges the current container metadata with new incoming metadata.
func (db *sqliteContainer) UpdateMetadata(newMetadata map[string][]string, timestamp string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(newMetadata) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var metadataValue, deleteTimestamp string
        if err := tx.QueryRow("SELECT metadata, delete_timestamp FROM container_info").Scan(&amp;metadataValue, &amp;deleteTimestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if metadataValue == "" </span><span class="cov0" title="0">{
                existingMetadata = map[string][]string{}
        }</span><span class="cov8" title="1"> else if err := json.Unmarshal([]byte(metadataValue), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(existingMetadata, newMetadata, deleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE container_info SET metadata=?, put_timestamp=MAX(put_timestamp, ?)", metastr, timestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// MergeSyncTable updates the container's current incoming_sync table records.
func (db *sqliteContainer) MergeSyncTable(records []*SyncRecord) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for _, record := range records </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        record.SyncPoint, record.RemoteID, record.RemoteID, record.SyncPoint); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return tx.Commit()</span>
}

// CleanupTombstones removes any expired tombstoned objects or metadata.
func (db *sqliteContainer) CleanupTombstones(reclaimAge int64) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">now := float64(time.Now().UnixNano()) / 1000000000.0
        reclaimTimestamp := common.CanonicalTimestamp(now - float64(reclaimAge))

        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err = tx.Exec("DELETE FROM object WHERE deleted=1 AND created_at &lt; ?", reclaimTimestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var metastr string
        if err := tx.QueryRow("SELECT metadata FROM container_info").Scan(&amp;metastr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var metadata map[string][]string
        updated := false
        if metastr == "" </span><span class="cov0" title="0">{
                metadata = map[string][]string{}
                updated = true
        }</span><span class="cov8" title="1"> else {
                if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for k, v := range metadata </span><span class="cov8" title="1">{
                        if v[0] == "" </span><span class="cov8" title="1">{
                                if ts, err := common.GetEpochFromTimestamp(v[1]); err != nil || ts &lt; reclaimTimestamp </span><span class="cov8" title="1">{
                                        delete(metadata, k)
                                        updated = true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                if mb, err := json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span><span class="cov8" title="1"> else if _, err = tx.Exec("UPDATE container_info SET metadata = ?", string(mb)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// SyncTable returns the container's current incoming_sync table, and also includes the current container's id and max row as an entry.
func (db *sqliteContainer) SyncTable() ([]*SyncRecord, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">records := []*SyncRecord{}
        rows, err := db.Query(`SELECT sync_point, remote_id FROM incoming_sync
                                                   WHERE remote_id NOT IN (SELECT id FROM container_info)
                                                   UNION
                                                   SELECT maxrowid.max AS sync_point, container_info.id AS remote_id
                                                   FROM container_info, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                rec := &amp;SyncRecord{}
                if err := rows.Scan(&amp;rec.SyncPoint, &amp;rec.RemoteID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">records = append(records, rec)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rows.Close()
        return records, nil</span>
}

// SyncRemoteData compares a remote container's info to the local info and updates any necessary replication bookkeeping, returning the current container's info.
func (db *sqliteContainer) SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*ContainerInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var localMeta, localHash, localDeleteTimestamp string
        var localPoint int64
        if err := tx.QueryRow("SELECT hash, metadata, delete_timestamp FROM container_info").Scan(&amp;localHash, &amp;localMeta, &amp;localDeleteTimestamp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var lm, rm map[string][]string
        if err := json.Unmarshal([]byte(metadata), &amp;rm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(localMeta), &amp;lm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if deleteTimestamp &gt; localDeleteTimestamp </span><span class="cov8" title="1">{
                localDeleteTimestamp = deleteTimestamp
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(lm, rm, localDeleteTimestamp)
        if _, err = tx.Exec(`UPDATE container_info SET created_at=MIN(?, created_at), put_timestamp=MAX(?, put_timestamp),
                                                   delete_timestamp=MAX(?, delete_timestamp), metadata=?`,
                createdAt, putTimestamp, deleteTimestamp, metastr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := tx.QueryRow("SELECT IFNULL(MAX(sync_point), -1) FROM incoming_sync WHERE remote_id = ?", id).Scan(&amp;localPoint); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if localHash == hash &amp;&amp; maxRow &gt; localPoint </span><span class="cov8" title="1">{
                localPoint = maxRow
                if _, err = tx.Exec("INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point) VALUES (?, ?)", id, localPoint); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db.invalidateCache()
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">info.Point = localPoint
        return info, nil</span>
}

// CheckSyncLink makes sure the database's container sync symlink exists or doesn't exist, as in accordance with the existence of the X-Container-Sync-To header.
func (db *sqliteContainer) CheckSyncLink() error <span class="cov8" title="1">{
        metadata, err := db.GetMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">containersDir := filepath.Dir(filepath.Dir(filepath.Dir(filepath.Dir(db.containerFile))))
        deviceDir := filepath.Dir(containersDir)
        pathFromDataDir, err := filepath.Rel(containersDir, db.containerFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">symLoc := filepath.Join(deviceDir, "sync_containers", pathFromDataDir)
        if metadata["X-Container-Sync-To"] != "" </span><span class="cov8" title="1">{
                if fs.Exists(symLoc) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(symLoc), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return os.Symlink(db.containerFile, symLoc)</span>
        }<span class="cov8" title="1"> else if fs.Exists(symLoc) </span><span class="cov8" title="1">{
                for err := error(nil); err == nil; symLoc = filepath.Dir(symLoc) </span><span class="cov8" title="1">{
                        err = os.Remove(symLoc)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// OpenDatabaseFile blocks updates and opens the underlying database file for reading, so it can be uploaded to a remote server.
func (db *sqliteContainer) OpenDatabaseFile() (*os.File, func(), error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">var fp *os.File
        if _, err := db.Exec(`
                PRAGMA locking_mode = EXCLUSIVE;      -- grab and hold a shared lock
                SELECT 1 FROM container_info LIMIT 1; -- it doesn't actually lock until you hit the database
                PRAGMA wal_checkpoint(TRUNCATE);      -- truncate the wal file, if it exists`,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error locking database%s: %v", db.containerFile, err)
        }</span>
        <span class="cov8" title="1">cleanup := func() </span><span class="cov8" title="1">{
                db.Exec(`
                        PRAGMA locking_mode = NORMAL;         -- release shared lock
                        SELECT 1 FROM container_info LIMIT 1; -- actually release shared lock
                `)
                if fp != nil </span><span class="cov8" title="1">{
                        fp.Close()
                }</span>
        }
        // make sure there aren't any journals lying around
        <span class="cov8" title="1">if stat, err := os.Stat(db.containerFile + "-wal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn wal file still exists: %s", db.containerFile)
        }</span>
        <span class="cov8" title="1">if stat, err := os.Stat(db.containerFile + "-journal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn journal file still exists: %s", db.containerFile)
        }</span>
        <span class="cov8" title="1">fp, err := os.Open(db.containerFile)
        if err != nil </span><span class="cov0" title="0">{
                fp = nil
                cleanup()
                return nil, nil, fmt.Errorf("Error opening %s: %v", db.containerFile, err)
        }</span>
        <span class="cov8" title="1">return fp, cleanup, nil</span>
}

// ID returns the container's ring hash as a unique identifier for it.
func (db *sqliteContainer) ID() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

// RingHash returns the container's ring hash as a string.
func (db *sqliteContainer) RingHash() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

func (db *sqliteContainer) flushAlreadyLocked() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if stat, err := os.Stat(db.containerFile + ".pending"); err != nil || stat.Size() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">contents, err := ioutil.ReadFile(db.containerFile + ".pending")
        if err != nil || len(contents) == 0 </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var records []*ObjectRecord
        for _, base64ed := range strings.Split(string(contents), ":") </span><span class="cov8" title="1">{
                if len(base64ed) &lt; 1 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">pickled, err := base64.StdEncoding.DecodeString(base64ed)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">r, err := pickle.PickleLoads(pickled)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">record, ok := r.([]interface{})
                if !ok || len(record) &lt; 7 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Invalid commit pending record")
                }</span>
                <span class="cov8" title="1">casts := make([]bool, 7)
                var deleted, policy int64
                rec := &amp;ObjectRecord{}
                rec.Name, casts[0] = record[0].(string)
                rec.CreatedAt, casts[1] = record[1].(string)
                rec.Size, casts[2] = record[2].(int64)
                rec.ContentType, casts[3] = record[3].(string)
                rec.ETag, casts[4] = record[4].(string)
                deleted, casts[5] = record[5].(int64)
                policy, casts[6] = record[6].(int64)
                rec.Deleted = int(deleted)
                rec.StoragePolicyIndex = int(policy)
                for i := 0; i &lt; 7; i++ </span><span class="cov8" title="1">{
                        if !casts[i] </span><span class="cov0" title="0">{
                                return fmt.Errorf("Invalid commit pending record")
                        }</span>
                }
                <span class="cov8" title="1">records = append(records, rec)</span>
        }
        <span class="cov8" title="1">err = db.MergeItems(records, "")
        if err == nil </span><span class="cov8" title="1">{
                err = os.Truncate(db.containerFile+".pending", 0)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (db *sqliteContainer) flush() error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.containerFile), 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        return db.flushAlreadyLocked()</span>
}

func (db *sqliteContainer) addObject(name string, timestamp string, size int64, contentType string, etag string, deleted int, storagePolicyIndex int) error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.containerFile), 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        tuple := []interface{}{name, timestamp, size, contentType, etag, deleted, storagePolicyIndex}
        file, err := os.OpenFile(db.containerFile+".pending", os.O_RDWR|os.O_APPEND|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        if _, err := file.WriteString(":" + base64.StdEncoding.EncodeToString(pickle.PickleDumps(tuple))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if info, err := file.Stat(); err == nil &amp;&amp; info.Size() &gt; pendingCap </span><span class="cov0" title="0">{
                db.flushAlreadyLocked()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PutObject adds an object to the container, by way of pending file.
func (db *sqliteContainer) PutObject(name string, timestamp string, size int64, contentType string, etag string, storagePolicyIndex int) error <span class="cov8" title="1">{
        return db.addObject(name, timestamp, size, contentType, etag, 0, storagePolicyIndex)
}</span>

// DeleteObject removes an object from the container, by way of pending file.
func (db *sqliteContainer) DeleteObject(name string, timestamp string, storagePolicyIndex int) error <span class="cov8" title="1">{
        return db.addObject(name, timestamp, 0, "", "", 1, storagePolicyIndex)
}</span>

// Close closes the underlying sqlite database connection.
func (db *sqliteContainer) Close() error <span class="cov8" title="1">{
        db.connectLock.Lock()
        defer func() </span><span class="cov8" title="1">{
                db.DB = nil
                db.connectLock.Unlock()
        }</span>()
        <span class="cov8" title="1">if db.DB != nil </span><span class="cov8" title="1">{
                return db.DB.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sqliteCreateExistingContainer(db Container, putTimestamp string, newMetadata map[string][]string, policyIndex, defaultPolicyIndex int) (bool, error) <span class="cov8" title="1">{
        cdb, ok := db.(*sqliteContainer)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("Unable to work with non-sqliteContainer")
        }</span>
        <span class="cov8" title="1">if err := cdb.connect(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">tx, err := cdb.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var cDeleteTimestamp, cPutTimestamp, cMetadata string
        var cPolicyIndex int
        row := tx.QueryRow("SELECT put_timestamp, delete_timestamp, storage_policy_index, metadata FROM container_info")
        if err := row.Scan(&amp;cPutTimestamp, &amp;cDeleteTimestamp, &amp;cPolicyIndex, &amp;cMetadata); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if cDeleteTimestamp &lt;= cPutTimestamp </span><span class="cov8" title="1">{ // not deleted
                if policyIndex &lt; 0 </span><span class="cov8" title="1">{
                        policyIndex = cPolicyIndex
                }</span><span class="cov8" title="1"> else if cPolicyIndex != policyIndex </span><span class="cov8" title="1">{
                        return false, ErrorPolicyConflict
                }</span>
        }<span class="cov0" title="0"> else { // deleted
                if policyIndex &lt; 0 </span><span class="cov0" title="0">{
                        policyIndex = defaultPolicyIndex
                }</span>
        }
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if cMetadata == "" </span><span class="cov0" title="0">{
                existingMetadata = make(map[string][]string)
        }</span><span class="cov8" title="1"> else if err := json.Unmarshal([]byte(cMetadata), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">metastr, err := cdb.mergeMetas(existingMetadata, newMetadata, cDeleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec("UPDATE container_info SET put_timestamp = ?, storage_policy_index = ?, metadata = ?",
                putTimestamp, policyIndex, metastr); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer cdb.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return (cDeleteTimestamp &gt; cPutTimestamp &amp;&amp; putTimestamp &gt; cDeleteTimestamp), nil</span>
}

func sqliteCreateContainer(containerFile string, account string, container string, putTimestamp string,
        metadata map[string][]string, policyIndex int) error <span class="cov8" title="1">{
        var serializedMetadata []byte
        var err error

        if fs.Exists(containerFile) </span><span class="cov0" title="0">{
                return errors.New("Container exists!")
        }</span>
        <span class="cov8" title="1">if metadata == nil </span><span class="cov8" title="1">{
                serializedMetadata = []byte("{}")
        }</span><span class="cov8" title="1"> else if serializedMetadata, err = json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">hashDir := filepath.Dir(containerFile)
        if err := os.MkdirAll(hashDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tfp, err := ioutil.TempFile(hashDir, ".newdb")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tfp.Chmod(0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tfp.Close()
        tempFile := tfp.Name()
        dbConn, err := sql.Open("sqlite3_hummingbird", "file:"+tempFile+"?psow=1&amp;_txlock=immediate&amp;mode=rwc")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dbConn.Close()
        tx, err := dbConn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err := tx.Exec(objectTableScript + policyStatTableScript + policyStatTriggerScript +
                containerInfoTableScript + containerStatViewScript + syncTableScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(`INSERT INTO container_info (account, container, created_at, id, put_timestamp,
                                                  status_changed_at, storage_policy_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
                account, container, common.GetTimestamp(), common.UUID(), putTimestamp,
                putTimestamp, policyIndex, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec("INSERT INTO policy_stat (storage_policy_index) VALUES (?)", policyIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.Rename(tempFile, containerFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sqliteOpenContainer(containerFile string) (ReplicableContainer, error) <span class="cov8" title="1">{
        if !fs.Exists(containerFile) </span><span class="cov0" title="0">{
                return nil, ErrorNoSuchContainer
        }</span>
        <span class="cov8" title="1">db := &amp;sqliteContainer{
                containerFile:       containerFile,
                hasDeletedNameIndex: false,
                ringhash:            filepath.Base(filepath.Dir(containerFile)),
        }
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

var waitForAccountUpdate = time.Second * 5

func (server *ContainerServer) accountUpdate(writer http.ResponseWriter, request *http.Request, vars map[string]string, info *ContainerInfo, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        firstDone := make(chan struct{}, 1)
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{ firstDone &lt;- struct{}{} }</span>()
                <span class="cov8" title="1">defer middleware.Recover(writer, request, "PANIC WHILE UPDATING ACCOUNT")
                accpartition := request.Header.Get("X-Account-Partition")
                if accpartition == "" </span><span class="cov8" title="1">{
                        logger.Error("Account update failed: bad partition")
                        return
                }</span>
                <span class="cov8" title="1">hosts := strings.Split(request.Header.Get("X-Account-Host"), ",")
                devices := strings.Split(request.Header.Get("X-Account-Device"), ",")
                if len(hosts) != len(devices) </span><span class="cov8" title="1">{
                        logger.Error("Account update failed: different numbers of hosts and devices in request")
                        return
                }</span>
                <span class="cov8" title="1">for index, host := range hosts </span><span class="cov8" title="1">{
                        url := fmt.Sprintf("http://%s/%s/%s/%s/%s", host, devices[index], accpartition,
                                common.Urlencode(vars["account"]), common.Urlencode(vars["container"]))
                        req, err := http.NewRequest("PUT", url, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Account update failed: error creating request object")
                                continue</span>
                        }
                        <span class="cov8" title="1">req.Header.Add("X-Put-Timestamp", info.PutTimestamp)
                        req.Header.Add("X-Delete-Timestamp", info.DeleteTimestamp)
                        req.Header.Add("X-Object-Count", strconv.FormatInt(info.ObjectCount, 10))
                        req.Header.Add("X-Bytes-Used", strconv.FormatInt(info.BytesUsed, 10))
                        req.Header.Add("X-Trans-Id", request.Header.Get("X-Trans-Id"))
                        req.Header.Add("X-Backend-Storage-Policy-Index", strconv.Itoa(info.StoragePolicyIndex))
                        if request.Header.Get("X-Account-Override-Deleted") == "yes" </span><span class="cov0" title="0">{
                                req.Header.Add("X-Account-Override-Deleted", "yes")
                        }</span>
                        <span class="cov8" title="1">resp, err := server.updateClient.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Account update failed: bad response",
                                        zap.String("hosts[index]", hosts[index]),
                                        zap.String("devices[index]", devices[index]))
                                continue</span>
                        }
                        <span class="cov8" title="1">defer resp.Body.Close()
                        if (resp.StatusCode / 100) != 2 </span><span class="cov0" title="0">{
                                logger.Error("Account update failed: bad response",
                                        zap.String("hosts[index]", hosts[index]),
                                        zap.String("devices[index]", devices[index]))
                        }</span>
                }
        }()
        <span class="cov8" title="1">select </span>{
        case &lt;-time.After(waitForAccountUpdate):</span><span class="cov8" title="1">
        case &lt;-firstDone:</span><span class="cov8" title="1">
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bufio"
        "compress/bzip2"
        "compress/gzip"
        "io"
        "net/http"
        "regexp"
)

type grepWriter struct {
        w      io.Writer
        h      http.Header
        status int
}

func (g *grepWriter) Header() http.Header <span class="cov8" title="1">{
        return g.h
}</span>

func (g *grepWriter) Write(buf []byte) (int, error) <span class="cov8" title="1">{
        return g.w.Write(buf)
}</span>

func (g *grepWriter) WriteHeader(status int) <span class="cov8" title="1">{
        g.status = status
}</span>

// GrepObject is an http middleware that searches objects line-by-line on the object server, similar to grep(1).
func GrepObject(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                if request.Method != "GREP" </span><span class="cov8" title="1">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">pr, pw := io.Pipe()
                defer pr.Close()
                defer pw.Close()
                newWriter := &amp;grepWriter{w: pw, h: make(http.Header), status: 200}
                newRequest, _ := http.NewRequest("GET", request.URL.String(), nil)
                newRequest.Header = request.Header
                go func() </span><span class="cov8" title="1">{
                        defer pw.Close()
                        next.ServeHTTP(newWriter, newRequest)
                }</span>()
                <span class="cov8" title="1">q := request.URL.Query().Get("e")
                if q == "" </span><span class="cov8" title="1">{
                        writer.WriteHeader(400)
                        return
                }</span>
                <span class="cov8" title="1">re, err := regexp.Compile(q)
                if err != nil </span><span class="cov8" title="1">{
                        writer.WriteHeader(400)
                        return
                }</span>
                // peek at response data first to make sure the downstream handler has set a status code
                <span class="cov8" title="1">br := bufio.NewReader(pr)
                magic, err := br.Peek(4)
                if newWriter.status == 200 </span><span class="cov8" title="1">{
                        var scanner *bufio.Scanner
                        if err == nil &amp;&amp; magic[0] == 0x1f &amp;&amp; magic[1] == 0x8b </span><span class="cov8" title="1">{
                                if gzr, err := gzip.NewReader(br); err != nil </span><span class="cov8" title="1">{
                                        writer.WriteHeader(500)
                                        return
                                }</span><span class="cov8" title="1"> else {
                                        scanner = bufio.NewScanner(gzr)
                                }</span>
                        }<span class="cov8" title="1"> else if err == nil &amp;&amp; magic[0] == 'B' &amp;&amp; magic[1] == 'Z' &amp;&amp; magic[2] == 'h' &amp;&amp; magic[3] &gt;= '1' &amp;&amp; magic[3] &lt;= '9' </span><span class="cov8" title="1">{
                                scanner = bufio.NewScanner(bzip2.NewReader(br))
                        }</span><span class="cov8" title="1"> else {
                                scanner = bufio.NewScanner(br)
                        }</span>
                        <span class="cov8" title="1">writer.WriteHeader(200)
                        for scanner.Scan() </span><span class="cov8" title="1">{
                                if line := scanner.Bytes(); re.Match(line) </span><span class="cov8" title="1">{
                                        writer.Write(line)
                                        writer.Write([]byte{'\n'})
                                }</span>
                        }
                }<span class="cov8" title="1"> else {
                        writer.WriteHeader(newWriter.status)
                        io.Copy(writer, br)
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file40" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"

        "github.com/troubling/hummingbird/common"
)

func OptionsHandler(serverType string, writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        server := fmt.Sprintf("%s/%s", serverType, common.Version)
        //We could use introspection in future to figure out the Allow Header.
        writer.Header().Set("Allow", "HEAD,GET,PUT,POST,DELETE,OPTIONS")
        writer.Header().Set("Server", server)
        writer.WriteHeader(http.StatusOK)
        return
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bufio"
        "crypto/md5"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/shirou/gopsutil/disk"
        "github.com/shirou/gopsutil/load"
        "github.com/shirou/gopsutil/mem"
        "github.com/shirou/gopsutil/process"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
)

func DumpReconCache(reconCachePath string, source string, cacheData map[string]interface{}) error <span class="cov8" title="1">{
        reconFile := filepath.Join(reconCachePath, source+".recon")

        if lock, err := fs.LockPath(filepath.Dir(reconFile), 5*time.Second); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else {
                defer lock.Close()
        }</span>

        <span class="cov8" title="1">filedata, _ := ioutil.ReadFile(reconFile)
        var reconData = make(map[string]interface{})
        if filedata != nil &amp;&amp; len(filedata) &gt; 0 </span><span class="cov8" title="1">{
                var data interface{}
                if json.Unmarshal(filedata, &amp;data) == nil </span><span class="cov8" title="1">{
                        if _, ok := data.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                reconData = data.(map[string]interface{})
                        }</span>
                }
        }
        <span class="cov8" title="1">for key, item := range cacheData </span><span class="cov8" title="1">{
                switch item := item.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        if len(item) == 0 </span><span class="cov8" title="1">{
                                delete(reconData, key)
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, ok := reconData[key].(map[string]interface{}); !ok </span><span class="cov8" title="1">{
                                reconData[key] = make(map[string]interface{})
                        }</span>
                        <span class="cov8" title="1">for itemk, itemv := range item </span><span class="cov8" title="1">{
                                if itemvmap, ok := itemv.(map[string]interface{}); ok &amp;&amp; len(itemvmap) == 0 </span><span class="cov8" title="1">{
                                        delete(reconData[key].(map[string]interface{}), itemk)
                                }</span><span class="cov8" title="1"> else if itemv == nil </span><span class="cov8" title="1">{
                                        delete(reconData[key].(map[string]interface{}), itemk)
                                }</span><span class="cov8" title="1"> else {
                                        reconData[key].(map[string]interface{})[itemk] = itemv
                                }</span>
                        }
                case nil:<span class="cov8" title="1">
                        delete(reconData, key)</span>
                default:<span class="cov8" title="1">
                        reconData[key] = item</span>
                }
        }
        <span class="cov8" title="1">newdata, err := json.Marshal(reconData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">f, err := fs.NewAtomicFileWriter(reconCachePath, reconCachePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Abandon()
        f.Write(newdata)
        return f.Save(reconFile)</span>
}

// getMem dumps the contents of /proc/meminfo if it's available, otherwise it pulls what it can from gopsutil/mem
func getMem() interface{} <span class="cov8" title="1">{
        if fp, err := os.Open("/proc/meminfo"); err == nil </span><span class="cov8" title="1">{
                defer fp.Close()
                results := make(map[string]string)
                scanner := bufio.NewScanner(fp)
                for scanner.Scan() </span><span class="cov8" title="1">{
                        vals := strings.Split(scanner.Text(), ":")
                        results[strings.TrimSpace(vals[0])] = strings.TrimSpace(vals[1])
                }</span>
                <span class="cov8" title="1">return results</span>
        }<span class="cov0" title="0"> else {
                vmem, err := mem.VirtualMemory()
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">swap, err := mem.SwapMemory()
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return map[string]string{
                        "MemTotal":  strconv.FormatUint(vmem.Total, 10),
                        "MemFree":   strconv.FormatUint(vmem.Available, 10),
                        "Buffers":   strconv.FormatUint(vmem.Buffers, 10),
                        "Cached":    strconv.FormatUint(vmem.Cached, 10),
                        "SwapTotal": strconv.FormatUint(swap.Total, 10),
                        "SwapFree":  strconv.FormatUint(swap.Free, 10),
                }</span>
        }
}

func getSockstats() interface{} <span class="cov0" title="0">{
        results := make(map[string]int64)

        fp, err := os.Open("/proc/net/sockstat")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer fp.Close()
        scanner := bufio.NewScanner(fp)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "TCP: inuse") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, " ")
                        results["tcp_in_use"], _ = strconv.ParseInt(parts[2], 10, 64)
                        results["orphan"], _ = strconv.ParseInt(parts[4], 10, 64)
                        results["time_wait"], _ = strconv.ParseInt(parts[6], 10, 64)
                        results["tcp_mem_allocated_bytes"], _ = strconv.ParseInt(parts[10], 10, 64)
                        results["tcp_mem_allocated_bytes"] *= int64(os.Getpagesize())
                }</span>
        }

        <span class="cov0" title="0">fp, err = os.Open("/proc/net/sockstat6")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer fp.Close()
        scanner = bufio.NewScanner(fp)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "TCP6: inuse") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, " ")
                        results["tcp6_in_use"], _ = strconv.ParseInt(parts[2], 10, 64)
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}

func getLoad() interface{} <span class="cov8" title="1">{
        results := make(map[string]interface{})
        avg, err := load.Avg()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">misc, err := load.Misc()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">pids, err := process.Pids()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">results["1m"] = avg.Load1
        results["5m"] = avg.Load5
        results["15m"] = avg.Load15
        results["tasks"] = fmt.Sprintf("%d/%d", misc.ProcsRunning, len(pids))
        // swift's recon puts the pid of the last created process in this field, which seems kind of useless.
        // I'm making it the number of processes, which seems like what it was meant to be.
        results["processes"] = len(pids)
        // also adding these two fields, since they might be useful.
        results["running"] = misc.ProcsRunning
        results["blocked"] = misc.ProcsBlocked
        return results</span>
}

func getMounts() interface{} <span class="cov8" title="1">{
        results := make([]map[string]string, 0)
        partitions, err := disk.Partitions(true)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, part := range partitions </span><span class="cov8" title="1">{
                results = append(results, map[string]string{"device": part.Device, "path": part.Mountpoint})
        }</span>
        <span class="cov8" title="1">return results</span>
}

func fromReconCache(source string, keys ...string) (interface{}, error) <span class="cov0" title="0">{
        results := make(map[string]interface{})
        for _, key := range keys </span><span class="cov0" title="0">{
                results[key] = nil
        }</span>
        <span class="cov0" title="0">filedata, err := ioutil.ReadFile(fmt.Sprintf("/var/cache/swift/%s.recon", source))
        if err != nil </span><span class="cov0" title="0">{
                results["recon_error"] = fmt.Sprintf("Error: %s", err)
                return results, nil
        }</span>
        <span class="cov0" title="0">var data interface{}
        json.Unmarshal(filedata, &amp;data)
        switch data := data.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                for _, key := range keys </span><span class="cov0" title="0">{
                        results[key] = data[key]
                }</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(fmt.Sprintf("Unexpected data type %T in recon file.", data))</span>
        }
        <span class="cov0" title="0">return results, nil</span>
}

func getUnmounted(driveRoot string) (interface{}, error) <span class="cov0" title="0">{
        unmounted := make([]map[string]interface{}, 0)
        dirInfo, err := os.Stat(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileInfo, _ := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, info := range fileInfo </span><span class="cov0" title="0">{
                if info.Sys().(*syscall.Stat_t).Dev == dirInfo.Sys().(*syscall.Stat_t).Dev </span><span class="cov0" title="0">{
                        unmounted = append(unmounted, map[string]interface{}{"device": info.Name(), "mounted": false})
                }</span>
        }
        <span class="cov0" title="0">return unmounted, nil</span>
}

func fileMD5(files ...string) (map[string]string, error) <span class="cov0" title="0">{
        response := make(map[string]string)
        for _, file := range files </span><span class="cov0" title="0">{
                fp, err := os.Open(file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fp.Close()
                hash := md5.New()
                io.Copy(hash, fp)
                response[file] = fmt.Sprintf("%x", hash.Sum(nil))</span>
        }
        <span class="cov0" title="0">return response, nil</span>
}

func ListDevices(driveRoot string) (map[string][]string, error) <span class="cov0" title="0">{
        fileInfo, err := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileList := make([]string, 0)
        for _, info := range fileInfo </span><span class="cov0" title="0">{
                fileList = append(fileList, info.Name())
        }</span>
        <span class="cov0" title="0">return map[string][]string{driveRoot: fileList}, nil</span>
}

func quarantineCounts(driveRoot string) (map[string]interface{}, error) <span class="cov0" title="0">{
        qcounts := map[string]interface{}{"objects": 0, "containers": 0, "accounts": 0}
        deviceList, err := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, info := range deviceList </span><span class="cov0" title="0">{
                for key := range qcounts </span><span class="cov0" title="0">{
                        stat, err := os.Stat(filepath.Join(driveRoot, info.Name(), "quarantined", key))
                        if err == nil </span><span class="cov0" title="0">{
                                qcounts[key] = stat.Sys().(*syscall.Stat_t).Nlink
                        }</span>
                }
        }
        <span class="cov0" title="0">return qcounts, nil</span>
}

func diskUsage(driveRoot string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        devices := make([]map[string]interface{}, 0)
        dirInfo, err := os.Stat(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileInfo, _ := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, info := range fileInfo </span><span class="cov0" title="0">{
                if info.Sys().(*syscall.Stat_t).Dev == dirInfo.Sys().(*syscall.Stat_t).Dev </span><span class="cov0" title="0">{
                        devices = append(devices, map[string]interface{}{"device": info.Name(), "mounted": false,
                                "size": "", "used": "", "avail": ""})
                }</span><span class="cov0" title="0"> else {
                        var fsinfo syscall.Statfs_t
                        err := syscall.Statfs(filepath.Join(driveRoot, info.Name()), &amp;fsinfo)
                        if err == nil </span><span class="cov0" title="0">{
                                capacity := int64(fsinfo.Bsize) * int64(fsinfo.Blocks)
                                used := int64(fsinfo.Bsize) * (int64(fsinfo.Blocks) - int64(fsinfo.Bavail))
                                available := int64(fsinfo.Bsize) * int64(fsinfo.Bavail)
                                devices = append(devices, map[string]interface{}{"device": info.Name(), "mounted": true,
                                        "size": capacity, "used": used, "avail": available})
                        }</span>
                }
        }
        <span class="cov0" title="0">return devices, nil</span>
}

func ReconHandler(driveRoot string, writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        var content interface{} = nil

        vars := srv.GetVars(request)

        switch vars["method"] </span>{
        case "mem":<span class="cov8" title="1">
                content = getMem()</span>
        case "load":<span class="cov8" title="1">
                content = getLoad()</span>
        case "async":<span class="cov0" title="0">
                var err error
                content, err = fromReconCache("object", "async_pending")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "replication":<span class="cov0" title="0">
                var err error
                if vars["recon_type"] == "account" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("account", "replication_time", "replication_stats", "replication_last")
                }</span><span class="cov0" title="0"> else if vars["recon_type"] == "container" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("container", "replication_time", "replication_stats", "replication_last")
                }</span><span class="cov0" title="0"> else if vars["recon_type"] == "object" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("object", "object_replication_time", "object_replication_last")
                }</span><span class="cov0" title="0"> else if vars["recon_type"] == "" </span><span class="cov0" title="0">{
                        // handle old style object replication requests
                        content, err = fromReconCache("object", "object_replication_time", "object_replication_last")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "devices":<span class="cov0" title="0">
                var err error
                content, err = ListDevices(driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "updater":<span class="cov0" title="0">
                var err error
                if vars["recon_type"] == "container" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("container", "container_updater_sweep")
                }</span><span class="cov0" title="0"> else if vars["recon_type"] == "object" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("object", "object_updater_sweep")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "auditor":<span class="cov0" title="0">
                var err error
                if vars["recon_type"] == "account" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("account", "account_audits_passed", "account_auditor_pass_completed", "account_audits_since", "account_audits_failed")
                }</span><span class="cov0" title="0"> else if vars["recon_type"] == "container" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("container", "container_audits_passed", "container_auditor_pass_completed", "container_audits_since", "container_audits_failed")
                }</span><span class="cov0" title="0"> else if vars["recon_type"] == "object" </span><span class="cov0" title="0">{
                        content, err = fromReconCache("object", "object_auditor_stats_ALL", "object_auditor_stats_ZBF")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "expirer":<span class="cov0" title="0">
                var err error
                content, err = fromReconCache("object", "object_expiration_pass", "expired_last_pass")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "mounted":<span class="cov0" title="0">
                content = getMounts()</span>
        case "unmounted":<span class="cov0" title="0">
                var err error
                content, err = getUnmounted(driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "ringmd5":<span class="cov0" title="0">
                var err error
                content, err = fileMD5("/etc/hummingbird/object.ring.gz", "/etc/hummingbird/container.ring.gz", "/etc/hummingbird/account.ring.gz")
                if err != nil </span><span class="cov0" title="0">{
                        content, err = fileMD5("/etc/swift/object.ring.gz", "/etc/swift/container.ring.gz", "/etc/swift/account.ring.gz")
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                                return
                        }</span>
                }
        case "swiftconfmd5":<span class="cov0" title="0">
                var err error
                content, err = fileMD5("/etc/hummingbird/hummingbird.conf")
                if err != nil </span><span class="cov0" title="0">{
                        content, err = fileMD5("/etc/swift/swift.conf")
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                                return
                        }</span>
                }
        case "quarantined":<span class="cov0" title="0">
                var err error
                content, err = quarantineCounts(driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "sockstat":<span class="cov0" title="0">
                content = getSockstats()</span>
        case "version":<span class="cov0" title="0">
                content = map[string]string{"version": "idunno"}</span>
        case "diskusage":<span class="cov0" title="0">
                var err error
                content, err = diskUsage(driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "time":<span class="cov0" title="0">
                //Similar to python time.time()
                content = float64(time.Now().UnixNano()) / float64(time.Second)</span>
        case "driveaudit":<span class="cov0" title="0">
                var err error
                content, err = fromReconCache("drive", "drive_audit_errors")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        default:<span class="cov0" title="0">
                http.Error(writer, http.StatusText(http.StatusNotFound), http.StatusNotFound)
                return</span>
        }
        <span class="cov8" title="1">if content == nil </span><span class="cov0" title="0">{
                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(200)
        serialized, _ := json.MarshalIndent(content, "", "  ")
        writer.Write(serialized)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common/srv"
)

func Recover(w http.ResponseWriter, r *http.Request, msg string) <span class="cov8" title="1">{
        if err := recover(); err != nil </span><span class="cov0" title="0">{
                transactionId := r.Header.Get("X-Trans-Id")
                srv.GetLogger(r).Error(msg, zap.Any("err", err), zap.String("txn", transactionId))
                // if we haven't set a status code yet, we can send a 500 response.
                if started, _ := w.(srv.WebWriterInterface).Response(); !started </span><span class="cov0" title="0">{
                        srv.StandardResponse(w, http.StatusInternalServerError)
                }</span>
        }
}

func RecoverHandler(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                defer Recover(w, r, "PANIC")
                next.ServeHTTP(w, r)
        }</span>

        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "github.com/troubling/hummingbird/common/srv"
)

func ValidateRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                if !srv.ValidateRequest(writer, request) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "crypto/md5"
        "encoding/hex"
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

// AuditForeverInterval represents how often a auditor check should be performed.
var AuditForeverInterval = 30 * time.Second

// AuditorDaemon keeps track of object specific audit data.
type AuditorDaemon struct {
        checkMounts       bool
        driveRoot         string
        policies          conf.PolicyList
        logger            srv.LowLevelLogger
        bytesPerSecond    int64
        logTime           int64
        regFilesPerSecond int64
        zbFilesPerSecond  int64
        reconCachePath    string
}

// Auditor keeps track of general audit data.
type Auditor struct {
        *AuditorDaemon
        auditorType                   string
        mode                          string
        filesPerSecond                int64
        passStart, lastLog            time.Time
        passes, totalPasses           int64
        bytesProcessed, totalBytes    int64
        quarantines, totalQuarantines int64
        errors, totalErrors           int64
}

// OneTimeChan returns a channel that will yield the current time once, then is closed.
func OneTimeChan() chan time.Time <span class="cov8" title="1">{
        c := make(chan time.Time, 1)
        c &lt;- time.Now()
        close(c)
        return c
}</span>

// rateLimitSleep long enough to achieve the target rate limit.
func rateLimitSleep(startTime time.Time, done int64, rate int64) <span class="cov8" title="1">{
        shouldHaveDone := int64(time.Since(startTime)/time.Second) * rate
        if done &gt; shouldHaveDone </span><span class="cov8" title="1">{
                time.Sleep(time.Second * time.Duration((done-shouldHaveDone)/rate))
        }</span>
}

// auditHash of object hash dir.
func auditHash(hashPath string, skipMd5 bool) (bytesProcessed int64, err error) <span class="cov8" title="1">{
        objFiles, err := fs.ReadDirNames(hashPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error reading hash dir")
        }</span>
        <span class="cov8" title="1">for _, file := range objFiles </span><span class="cov8" title="1">{
                filePath := filepath.Join(hashPath, file)

                ext := filepath.Ext(filePath)
                if ext != ".data" &amp;&amp; ext != ".ts" &amp;&amp; ext != ".meta" </span><span class="cov8" title="1">{
                        return bytesProcessed, fmt.Errorf("Object file has invalid extension %s", ext)
                }</span>

                <span class="cov8" title="1">finfo, err := os.Stat(filePath)
                if err != nil || !finfo.Mode().IsRegular() </span><span class="cov8" title="1">{
                        return bytesProcessed, fmt.Errorf("Object file isn't a normal file")
                }</span>

                <span class="cov8" title="1">metadata, err := ReadMetadata(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        return bytesProcessed, fmt.Errorf("Error getting file metadata: %v", err)
                }</span>

                <span class="cov8" title="1">if ext == ".data" </span><span class="cov8" title="1">{
                        for _, reqEntry := range []string{"Content-Length", "Content-Type", "name", "ETag", "X-Timestamp"} </span><span class="cov8" title="1">{
                                if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                        return bytesProcessed, fmt.Errorf("Required metadata entry %s not found", reqEntry)
                                }</span>
                        }
                        <span class="cov8" title="1">contentLength, err := strconv.ParseInt(metadata["Content-Length"], 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return bytesProcessed, fmt.Errorf("Error parsing content-length from metadata: %v", err)
                        }</span>
                        <span class="cov8" title="1">if contentLength != finfo.Size() </span><span class="cov8" title="1">{
                                return bytesProcessed, fmt.Errorf("File size (%d) doesn't match metadata (%d)", finfo.Size(), contentLength)
                        }</span>
                        <span class="cov8" title="1">if !skipMd5 </span><span class="cov8" title="1">{
                                file, err := os.Open(filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return bytesProcessed, fmt.Errorf("Error opening file")
                                }</span>
                                <span class="cov8" title="1">h := md5.New()
                                bytes, err := common.Copy(file, h)
                                if err != nil </span><span class="cov0" title="0">{
                                        return bytesProcessed, fmt.Errorf("Error reading file")
                                }</span>
                                <span class="cov8" title="1">bytesProcessed += bytes
                                if hex.EncodeToString(h.Sum(nil)) != metadata["ETag"] </span><span class="cov8" title="1">{
                                        return bytesProcessed, fmt.Errorf("File contents don't match etag")
                                }</span>
                        }
                }<span class="cov8" title="1"> else if ext == ".ts" </span><span class="cov8" title="1">{
                        for _, reqEntry := range []string{"name", "X-Timestamp"} </span><span class="cov8" title="1">{
                                if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                        return bytesProcessed, fmt.Errorf("Required metadata entry %s not found", reqEntry)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return bytesProcessed, nil</span>
}

// auditSuffix directory.  Lists hash dirs, calls auditHash() for each, and quarantines any with errors.
func (a *Auditor) auditSuffix(suffixDir string) <span class="cov8" title="1">{
        hashes, err := fs.ReadDirNames(suffixDir)
        if err != nil </span><span class="cov8" title="1">{
                a.errors++
                a.totalErrors++
                a.logger.Error("Error reading suffix dir", zap.String("suffixDir", suffixDir))
                return
        }</span>
        <span class="cov8" title="1">for _, hash := range hashes </span><span class="cov8" title="1">{
                _, hexErr := hex.DecodeString(hash)
                hashDir := filepath.Join(suffixDir, hash)
                if finfo, err := os.Stat(hashDir); err != nil || len(hash) != 32 || hexErr != nil || !finfo.Mode().IsDir() </span><span class="cov8" title="1">{
                        a.logger.Error("Skipping invalid file in suffix", zap.String("hashDir", hashDir))
                        continue</span>
                }
                <span class="cov8" title="1">a.passes++
                a.totalPasses++
                bytesProcessed, err := auditHash(hashDir, a.auditorType == "ZBF")
                a.bytesProcessed += bytesProcessed
                a.totalBytes += bytesProcessed
                rateLimitSleep(a.passStart, a.totalPasses, a.filesPerSecond)
                rateLimitSleep(a.passStart, a.totalBytes, a.bytesPerSecond)
                if err != nil </span><span class="cov8" title="1">{
                        a.logger.Error("Failed audit and is being quarantined",
                                zap.String("hashDir", hashDir),
                                zap.Error(err))
                        QuarantineHash(hashDir)
                        InvalidateHash(hashDir)
                        a.quarantines++
                        a.totalQuarantines++
                }</span>
        }
}

// auditPartition directory.  Lists suffixes in the partition and calls auditSuffix() for each.
func (a *Auditor) auditPartition(partitionDir string) <span class="cov8" title="1">{
        suffixes, err := fs.ReadDirNames(partitionDir)
        if err != nil </span><span class="cov8" title="1">{
                a.errors++
                a.totalErrors++
                a.logger.Error("Error reading partition dir ", zap.String("partitionDir", partitionDir))
                return
        }</span>
        <span class="cov8" title="1">for _, suffix := range suffixes </span><span class="cov8" title="1">{
                suffixDir := filepath.Join(partitionDir, suffix)
                if suffix == ".lock" || suffix == "hashes.pkl" || suffix == "hashes.invalid" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">_, hexErr := strconv.ParseInt(suffix, 16, 64)
                if finfo, err := os.Stat(suffixDir); err != nil || len(suffix) != 3 || hexErr != nil || !finfo.Mode().IsDir() </span><span class="cov8" title="1">{
                        a.logger.Error("Skipping invalid file in partition.", zap.String("suffixDir", suffixDir))
                        continue</span>
                }
                <span class="cov8" title="1">a.auditSuffix(suffixDir)
                if time.Since(a.lastLog) &gt; (time.Duration(a.logTime) * time.Second) </span><span class="cov8" title="1">{
                        a.statsReport()
                }</span>
        }
}

// auditDevice, checking for mount, list partitions, then call auditPartition() for each.
func (a *Auditor) auditDevice(devPath string) <span class="cov8" title="1">{
        defer srv.LogPanics(a.logger, "PANIC WHILE AUDITING DEVICE")

        if mounted, err := fs.IsMount(devPath); a.checkMounts &amp;&amp; (err != nil || mounted != true) </span><span class="cov8" title="1">{
                a.logger.Error("Skipping unmounted device", zap.String("devPath", devPath))
                return
        }</span>

        <span class="cov8" title="1">for _, policy := range a.policies </span><span class="cov8" title="1">{
                if policy.Type != "replication" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">objPath := filepath.Join(devPath, PolicyDir(policy.Index))
                partitions, err := fs.ReadDirNames(objPath)
                if err != nil </span><span class="cov8" title="1">{
                        a.errors++
                        a.totalErrors++
                        a.logger.Error("Error reading objects dir", zap.String("objPath", objPath))
                        continue</span>
                }
                <span class="cov8" title="1">for _, partition := range partitions </span><span class="cov8" title="1">{
                        _, intErr := strconv.ParseInt(partition, 10, 64)
                        partitionDir := filepath.Join(objPath, partition)
                        if finfo, err := os.Stat(partitionDir); err != nil || intErr != nil || !finfo.Mode().IsDir() </span><span class="cov8" title="1">{
                                a.logger.Error("Skipping invalid file in objects directory", zap.String("partitionDir", partitionDir))
                                continue</span>
                        }
                        <span class="cov8" title="1">a.auditPartition(partitionDir)</span>
                }
        }
}

// statsReport logs auditing stats and dump recon cache.  Called periodically by auditPartition().
func (a *Auditor) statsReport() <span class="cov8" title="1">{
        now := time.Now()
        total := float64(now.Sub(a.passStart)) / float64(time.Second)
        sinceLast := float64(now.Sub(a.lastLog)) / float64(time.Second)
        frate := float64(a.passes) / sinceLast
        brate := float64(a.bytesProcessed) / sinceLast
        audit := 0.0      // TODO maybe
        audit_rate := 0.0 // TODO maybe
        a.logger.Info("statsReport",
                zap.String("Object audit", a.auditorType),
                zap.String("Since", a.lastLog.Format(time.ANSIC)),
                zap.Int64("Locally passed", a.passes),
                zap.Int64("Locally quarantied", a.quarantines),
                zap.Int64("Locally errored", a.errors),
                zap.Float64("files/sec", frate),
                zap.Float64("bytes/sec", brate),
                zap.Float64("Total time", total),
                zap.Float64("Auditing Time", audit),
                zap.Float64("Auditing Rate", audit_rate))

        middleware.DumpReconCache(a.reconCachePath, "object",
                map[string]interface{}{"object_auditor_stats_" + a.auditorType: map[string]interface{}{
                        "errors":          a.errors,
                        "passes":          a.passes,
                        "quarantined":     a.quarantines,
                        "bytes_processed": a.bytesProcessed,
                        "start_time":      float64(a.passStart.UnixNano()) / float64(time.Second), //???
                        "audit_time":      audit,
                }})
        a.passes = 0
        a.quarantines = 0
        a.errors = 0
        a.bytesProcessed = 0
        a.lastLog = now
}</span>

// finalLog final stats summary for the audit pass.
func (a *Auditor) finalLog() <span class="cov8" title="1">{
        elapsed := float64(time.Since(a.passStart)) / float64(time.Second)
        frate := float64(a.totalPasses) / elapsed
        brate := float64(a.totalBytes) / elapsed
        audit := 0.0      // TODO maybe
        audit_rate := 0.0 // TODO maybe
        a.logger.Info("Object Audit",
                zap.String("Auditor type", a.auditorType),
                zap.String("Mode", a.mode),
                zap.Float64("completed", elapsed),
                zap.Int64("Total quarantined", a.totalQuarantines),
                zap.Int64("Total errors", a.totalErrors),
                zap.Float64("Total files/sec", frate),
                zap.Float64("Total bytes/sec", brate),
                zap.Float64("Auditing time", audit),
                zap.Float64("Auditing rate", audit_rate))
}</span>

// run audit passes of the whole server until c is closed.
func (a *Auditor) run(c &lt;-chan time.Time) <span class="cov8" title="1">{
        for a.passStart = range c </span><span class="cov8" title="1">{
                middleware.DumpReconCache(a.reconCachePath, "object",
                        map[string]interface{}{"object_auditor_stats_" + a.auditorType: nil})
                a.passes = 0
                a.bytesProcessed = 0
                a.quarantines = 0
                a.errors = 0
                a.totalPasses = 0
                a.totalBytes = 0
                a.totalQuarantines = 0
                a.totalErrors = 0
                a.logger.Info("Begin object audit",
                        zap.String("mode", a.mode),
                        zap.String("auditorType", a.auditorType),
                        zap.String("driveRoot", a.driveRoot))
                devices, err := fs.ReadDirNames(a.driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Unable to list devices", zap.String("driveRoot", a.driveRoot))
                        continue</span>
                }
                <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                        a.auditDevice(filepath.Join(a.driveRoot, dev))
                }</span>
                <span class="cov8" title="1">a.finalLog()</span>
        }
}

// Run a single audit pass.
func (d *AuditorDaemon) Run() <span class="cov8" title="1">{
        wg := sync.WaitGroup{}
        if d.zbFilesPerSecond &gt; 0 </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        zba := Auditor{AuditorDaemon: d, auditorType: "ZBF", mode: "once", filesPerSecond: d.zbFilesPerSecond}
                        zba.run(OneTimeChan())
                        wg.Done()
                }</span>()
        }
        <span class="cov8" title="1">reg := Auditor{AuditorDaemon: d, auditorType: "ALL", mode: "once", filesPerSecond: d.regFilesPerSecond}
        reg.run(OneTimeChan())
        wg.Wait()</span>
}

// RunForever triggering audit passes every time AuditForeverInterval has passed.
func (d *AuditorDaemon) RunForever() <span class="cov0" title="0">{
        if d.zbFilesPerSecond &gt; 0 </span><span class="cov0" title="0">{
                zba := Auditor{AuditorDaemon: d, auditorType: "ZBF", mode: "forever", filesPerSecond: d.zbFilesPerSecond}
                go zba.run(time.Tick(AuditForeverInterval))
        }</span>
        <span class="cov0" title="0">reg := Auditor{AuditorDaemon: d, auditorType: "ALL", mode: "forever", filesPerSecond: d.regFilesPerSecond}
        reg.run(time.Tick(AuditForeverInterval))</span>
}

// NewAuditor returns a new AuditorDaemon with the given conf.
func NewAuditor(serverconf conf.Config, flags *flag.FlagSet) (srv.Daemon, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        var err error
        if !serverconf.HasSection("object-auditor") </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("Unable to find object-auditor config section")
        }</span>
        <span class="cov8" title="1">d := &amp;AuditorDaemon{}
        d.policies = conf.LoadPolicies()
        d.driveRoot = serverconf.GetDefault("object-auditor", "devices", "/srv/node")
        d.checkMounts = serverconf.GetBool("object-auditor", "mount_check", true)

        logLevelString := serverconf.GetDefault("object-auditor", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        if d.logger, err = srv.SetupLogger("object-auditor", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">d.bytesPerSecond = serverconf.GetInt("object-auditor", "bytes_per_second", 10000000)
        d.regFilesPerSecond = serverconf.GetInt("object-auditor", "files_per_second", 20)
        d.zbFilesPerSecond = serverconf.GetInt("object-auditor", "zero_byte_files_per_second", 50)
        d.reconCachePath = serverconf.GetDefault("object-auditor", "recon_cache_path", "/var/cache/swift")
        d.logTime = serverconf.GetInt("object-auditor", "log_time", 3600)
        return d, d.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bufio"
        "crypto/md5"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math/rand"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

const METADATA_CHUNK_SIZE = 65536

var LockPathError = errors.New("Error locking path")
var PathNotDirError = errors.New("Path is not a directory")

func PolicyDir(policy int) string <span class="cov8" title="1">{
        if policy == 0 </span><span class="cov8" title="1">{
                return "objects"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("objects-%d", policy)</span>
}

func UnPolicyDir(dir string) (int, error) <span class="cov8" title="1">{
        if dir == "objects" </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">var policy int
        if n, err := fmt.Sscanf(dir, "objects-%d", &amp;policy); n == 1 &amp;&amp; err == nil </span><span class="cov8" title="1">{
                return policy, nil
        }</span>
        <span class="cov0" title="0">return 0, fmt.Errorf("Unable to parse policy from dir")</span>
}

func RawReadMetadata(fileNameOrFd interface{}) ([]byte, error) <span class="cov8" title="1">{
        var pickledMetadata []byte
        offset := 0
        for index := 0; ; index += 1 </span><span class="cov8" title="1">{
                var metadataName string
                // get name of next xattr
                if index == 0 </span><span class="cov8" title="1">{
                        metadataName = "user.swift.metadata"
                }</span><span class="cov8" title="1"> else {
                        metadataName = "user.swift.metadata" + strconv.Itoa(index)
                }</span>
                // get size of xattr
                <span class="cov8" title="1">length, err := fs.Getxattr(fileNameOrFd, metadataName, nil)
                if err != nil || length &lt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                // grow buffer to hold xattr
                <span class="cov8" title="1">for cap(pickledMetadata) &lt; offset+length </span><span class="cov8" title="1">{
                        pickledMetadata = append(pickledMetadata, 0)
                }</span>
                <span class="cov8" title="1">pickledMetadata = pickledMetadata[0 : offset+length]
                if _, err := fs.Getxattr(fileNameOrFd, metadataName, pickledMetadata[offset:]); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">offset += length</span>
        }
        <span class="cov8" title="1">return pickledMetadata, nil</span>
}

func ReadMetadata(fileNameOrFd interface{}) (map[string]string, error) <span class="cov8" title="1">{
        pickledMetadata, err := RawReadMetadata(fileNameOrFd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">v, err := pickle.PickleLoads(pickledMetadata)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if v, ok := v.(map[interface{}]interface{}); ok </span><span class="cov8" title="1">{
                metadata := make(map[string]string, len(v))
                for mk, mv := range v </span><span class="cov8" title="1">{
                        var mks, mvs string
                        if mks, ok = mk.(string); !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("Metadata key not string: %v", mk)
                        }</span><span class="cov8" title="1"> else if mvs, ok = mv.(string); !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("Metadata value not string: %v", mv)
                        }</span>
                        <span class="cov8" title="1">metadata[mks] = mvs</span>
                }
                <span class="cov8" title="1">return metadata, nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("Unpickled metadata not correct type")</span>
}

func RawWriteMetadata(fd uintptr, buf []byte) error <span class="cov8" title="1">{
        for index := 0; len(buf) &gt; 0; index++ </span><span class="cov8" title="1">{
                var metadataName string
                if index == 0 </span><span class="cov8" title="1">{
                        metadataName = "user.swift.metadata"
                }</span><span class="cov0" title="0"> else {
                        metadataName = "user.swift.metadata" + strconv.Itoa(index)
                }</span>
                <span class="cov8" title="1">writelen := METADATA_CHUNK_SIZE
                if len(buf) &lt; writelen </span><span class="cov8" title="1">{
                        writelen = len(buf)
                }</span>
                <span class="cov8" title="1">if _, err := fs.Setxattr(fd, metadataName, buf[0:writelen]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">buf = buf[writelen:]</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func WriteMetadata(fd uintptr, v map[string]string) error <span class="cov8" title="1">{
        return RawWriteMetadata(fd, pickle.PickleDumps(v))
}</span>

func QuarantineHash(hashDir string) error <span class="cov8" title="1">{
        // FYI- this does not invalidate the hash like swift's version. Please
        // do that yourself
        //          objects      partition    suffix       hash
        objsDir := filepath.Dir(filepath.Dir(filepath.Dir(hashDir)))
        driveDir := filepath.Dir(objsDir)
        quarantineDir := filepath.Join(driveDir, "quarantined", filepath.Base(objsDir))
        if err := os.MkdirAll(quarantineDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">hash := filepath.Base(hashDir)
        destDir := filepath.Join(quarantineDir, hash+"-"+common.UUID())
        if err := os.Rename(hashDir, destDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// InvalidateHash invalidates the hashdir's suffix hash, indicating it needs to be recalculated.
func InvalidateHash(hashDir string) error <span class="cov8" title="1">{
        suffDir := filepath.Dir(hashDir)
        partitionDir := filepath.Dir(suffDir)

        if partitionLock, err := fs.LockPath(partitionDir, 10*time.Second); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else {
                defer partitionLock.Close()
        }</span>
        <span class="cov8" title="1">fp, err := os.OpenFile(filepath.Join(partitionDir, "hashes.invalid"), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0660)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        _, err = fmt.Fprintf(fp, "%s\n", filepath.Base(suffDir))
        return err</span>
}

func HashCleanupListDir(hashDir string, reclaimAge int64) ([]string, error) <span class="cov8" title="1">{
        fileList, err := fs.ReadDirNames(hashDir)
        returnList := []string{}
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return returnList, nil
                }</span>
                <span class="cov0" title="0">if fs.IsNotDir(err) </span><span class="cov0" title="0">{
                        return returnList, PathNotDirError
                }</span>
                <span class="cov0" title="0">return returnList, err</span>
        }
        <span class="cov8" title="1">deleteRest := false
        deleteRestMeta := false
        if len(fileList) == 1 </span><span class="cov8" title="1">{
                filename := fileList[0]
                if strings.HasSuffix(filename, ".ts") </span><span class="cov0" title="0">{
                        withoutSuffix := strings.Split(filename, ".")[0]
                        if strings.Contains(withoutSuffix, "_") </span><span class="cov0" title="0">{
                                withoutSuffix = strings.Split(withoutSuffix, "_")[0]
                        }</span>
                        <span class="cov0" title="0">timestamp, _ := strconv.ParseFloat(withoutSuffix, 64)
                        if time.Now().Unix()-int64(timestamp) &gt; reclaimAge </span><span class="cov0" title="0">{
                                os.RemoveAll(hashDir + "/" + filename)
                                return returnList, nil
                        }</span>
                }
                <span class="cov8" title="1">returnList = append(returnList, filename)</span>
        }<span class="cov8" title="1"> else {
                for index := len(fileList) - 1; index &gt;= 0; index-- </span><span class="cov8" title="1">{
                        filename := fileList[index]
                        if deleteRest </span><span class="cov8" title="1">{
                                os.RemoveAll(hashDir + "/" + filename)
                        }</span><span class="cov8" title="1"> else {
                                if strings.HasSuffix(filename, ".meta") </span><span class="cov8" title="1">{
                                        if deleteRestMeta </span><span class="cov0" title="0">{
                                                os.RemoveAll(hashDir + "/" + filename)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">deleteRestMeta = true</span>
                                }
                                <span class="cov8" title="1">if strings.HasSuffix(filename, ".ts") || strings.HasSuffix(filename, ".data") </span><span class="cov8" title="1">{
                                        // TODO: check .ts time for expiration
                                        deleteRest = true
                                }</span>
                                <span class="cov8" title="1">returnList = append(returnList, filename)</span>
                        }
                }
        }
        <span class="cov8" title="1">return returnList, nil</span>
}

func RecalculateSuffixHash(suffixDir string, reclaimAge int64) (string, error) <span class="cov8" title="1">{
        // the is hash_suffix in swift
        h := md5.New()

        hashList, err := fs.ReadDirNames(suffixDir)
        if err != nil </span><span class="cov0" title="0">{
                if fs.IsNotDir(err) </span><span class="cov0" title="0">{
                        return "", PathNotDirError
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov8" title="1">for _, fullHash := range hashList </span><span class="cov8" title="1">{
                hashPath := suffixDir + "/" + fullHash
                fileList, err := HashCleanupListDir(hashPath, reclaimAge)
                if err != nil </span><span class="cov0" title="0">{
                        if err == PathNotDirError </span><span class="cov0" title="0">{
                                if QuarantineHash(hashPath) == nil </span><span class="cov0" title="0">{
                                        InvalidateHash(hashPath)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov8" title="1">if len(fileList) &gt; 0 </span><span class="cov8" title="1">{
                        for _, fileName := range fileList </span><span class="cov8" title="1">{
                                io.WriteString(h, fileName)
                        }</span>
                }<span class="cov0" title="0"> else {
                        os.Remove(hashPath) // leaves the suffix (swift removes it but who cares)
                }</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

func GetHashes(driveRoot string, device string, partition string, recalculate []string, reclaimAge int64, policy int, logger srv.LowLevelLogger) (map[string]string, error) <span class="cov8" title="1">{
        partitionDir := filepath.Join(driveRoot, device, PolicyDir(policy), partition)
        pklFile := filepath.Join(partitionDir, "hashes.pkl")
        invalidFile := filepath.Join(partitionDir, "hashes.invalid")

        modified := false
        hashes := make(map[string]string, 4096)
        lsForSuffixes := true
        if data, err := ioutil.ReadFile(pklFile); err == nil </span><span class="cov8" title="1">{
                if v, err := pickle.PickleLoads(data); err == nil </span><span class="cov8" title="1">{
                        if pickledHashes, ok := v.(map[interface{}]interface{}); ok </span><span class="cov8" title="1">{
                                lsForSuffixes = false
                                for suff, hash := range pickledHashes </span><span class="cov8" title="1">{
                                        if hashes[suff.(string)], ok = hash.(string); !ok </span><span class="cov0" title="0">{
                                                hashes[suff.(string)] = ""
                                        }</span>
                                }
                        }
                }
        }
        // check occasionally to see if there are any suffixes not in the hashes.pkl
        <span class="cov8" title="1">if !lsForSuffixes &amp;&amp; len(hashes) &lt; 4096 </span><span class="cov8" title="1">{
                lsForSuffixes = rand.Int31n(10) == 0
        }</span>
        <span class="cov8" title="1">if lsForSuffixes </span><span class="cov8" title="1">{
                // couldn't load hashes pickle, start building new one
                suffs, _ := fs.ReadDirNames(partitionDir)

                for _, suffName := range suffs </span><span class="cov8" title="1">{
                        if len(suffName) == 3 &amp;&amp; hashes[suffName] == "" </span><span class="cov8" title="1">{
                                hashes[suffName] = ""
                        }</span>
                }
        }
        <span class="cov8" title="1">for _, suffix := range recalculate </span><span class="cov8" title="1">{
                if len(suffix) == 3 </span><span class="cov8" title="1">{
                        hashes[suffix] = ""
                }</span>
        }
        <span class="cov8" title="1">mtime := int64(-1)
        if ivf, err := os.OpenFile(invalidFile, os.O_RDWR, 0660); err == nil </span><span class="cov8" title="1">{
                defer ivf.Close()
                if fileInfo, err := ivf.Stat(); err == nil </span><span class="cov8" title="1">{
                        mtime = fileInfo.ModTime().Unix()
                        scanner := bufio.NewScanner(ivf)
                        for scanner.Scan() </span><span class="cov8" title="1">{
                                if suff := scanner.Text(); len(suff) == 3 &amp;&amp; strings.Trim(suff, "0123456789abcdef") == "" </span><span class="cov8" title="1">{
                                        hashes[suff] = ""
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for suffix, hash := range hashes </span><span class="cov8" title="1">{
                if hash == "" </span><span class="cov8" title="1">{
                        modified = true
                        suffixDir := filepath.Join(partitionDir, suffix)
                        recalc_hash, err := RecalculateSuffixHash(suffixDir, reclaimAge)
                        switch err </span>{
                        case nil:<span class="cov8" title="1">
                                hashes[suffix] = recalc_hash</span>
                        case PathNotDirError:<span class="cov0" title="0">
                                delete(hashes, suffix)</span>
                        default:<span class="cov0" title="0">
                                logger.Error("Error hashing suffix",
                                        zap.String("partitionDir", partitionDir),
                                        zap.String("zapsuffix", suffix),
                                        zap.Error(err))</span>
                        }
                }
        }
        <span class="cov8" title="1">if modified </span><span class="cov8" title="1">{
                partitionLock, err := fs.LockPath(partitionDir, 10*time.Second)
                defer partitionLock.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, LockPathError
                }</span><span class="cov8" title="1"> else {
                        fileInfo, err := os.Stat(invalidFile)
                        if lsForSuffixes || os.IsNotExist(err) || mtime == fileInfo.ModTime().Unix() </span><span class="cov8" title="1">{
                                tempDir := TempDirPath(driveRoot, device)
                                if tempFile, err := fs.NewAtomicFileWriter(tempDir, partitionDir); err == nil </span><span class="cov8" title="1">{
                                        defer tempFile.Abandon()
                                        tempFile.Write(pickle.PickleDumps(hashes))
                                        tempFile.Save(pklFile)
                                }</span>
                                <span class="cov8" title="1">os.Truncate(invalidFile, 0)
                                return hashes, nil</span>
                        }
                        <span class="cov0" title="0">logger.Error("Made recursive call to GetHashes.", zap.String("partitionDir", partitionDir))
                        partitionLock.Close()
                        return GetHashes(driveRoot, device, partition, recalculate, reclaimAge, policy, logger)</span>
                }
        }
        <span class="cov8" title="1">return hashes, nil</span>
}

func ObjHashDir(vars map[string]string, driveRoot string, hashPathPrefix string, hashPathSuffix string, policy int) string <span class="cov8" title="1">{
        h := md5.New()
        io.WriteString(h, hashPathPrefix+"/"+vars["account"]+"/"+vars["container"]+"/"+vars["obj"]+hashPathSuffix)
        hexHash := hex.EncodeToString(h.Sum(nil))
        suffix := hexHash[29:32]
        return filepath.Join(driveRoot, vars["device"], PolicyDir(policy), vars["partition"], suffix, hexHash)
}</span>

func ObjectFiles(directory string) (string, string) <span class="cov8" title="1">{
        fileList, err := fs.ReadDirNames(directory)
        metaFile := ""
        if err != nil </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov8" title="1">for index := len(fileList) - 1; index &gt;= 0; index-- </span><span class="cov8" title="1">{
                filename := fileList[index]
                if strings.HasSuffix(filename, ".meta") </span><span class="cov8" title="1">{
                        metaFile = filename
                }</span>
                <span class="cov8" title="1">if strings.HasSuffix(filename, ".ts") || strings.HasSuffix(filename, ".data") </span><span class="cov8" title="1">{
                        if metaFile != "" </span><span class="cov8" title="1">{
                                return filepath.Join(directory, filename), filepath.Join(directory, metaFile)
                        }</span><span class="cov8" title="1"> else {
                                return filepath.Join(directory, filename), ""
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", ""</span>
}

func applyMetaFile(metaFile string, datafileMetadata map[string]string) (map[string]string, error) <span class="cov8" title="1">{
        if metadata, err := ReadMetadata(metaFile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span><span class="cov8" title="1"> else {
                for k, v := range datafileMetadata </span><span class="cov8" title="1">{
                        if k == "Content-Length" || k == "Content-Type" || k == "deleted" || k == "ETag" || strings.HasPrefix(k, "X-Object-Sysmeta-") </span><span class="cov8" title="1">{
                                metadata[k] = v
                        }</span>
                }
                <span class="cov8" title="1">return metadata, nil</span>
        }
}

func OpenObjectMetadata(fd uintptr, metaFile string) (map[string]string, error) <span class="cov8" title="1">{
        datafileMetadata, err := ReadMetadata(fd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if metaFile != "" </span><span class="cov8" title="1">{
                return applyMetaFile(metaFile, datafileMetadata)
        }</span>
        <span class="cov8" title="1">return datafileMetadata, nil</span>
}

func ObjectMetadata(dataFile string, metaFile string) (map[string]string, error) <span class="cov8" title="1">{
        datafileMetadata, err := ReadMetadata(dataFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if metaFile != "" </span><span class="cov8" title="1">{
                return applyMetaFile(metaFile, datafileMetadata)
        }</span>
        <span class="cov8" title="1">return datafileMetadata, nil</span>
}

func TempDirPath(driveRoot string, device string) string <span class="cov8" title="1">{
        return filepath.Join(driveRoot, device, "tmp")
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "crypto/md5"
        "encoding/hex"
        "flag"
        "fmt"
        "io"
        "net"
        "net/http"
        _ "net/http/pprof"
        "net/textproto"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/justinas/alice"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

type ObjectServer struct {
        driveRoot        string
        hashPathPrefix   string
        hashPathSuffix   string
        checkEtags       bool
        checkMounts      bool
        allowedHeaders   map[string]bool
        logger           srv.LowLevelLogger
        logLevel         zap.AtomicLevel
        diskInUse        *common.KeyedLimit
        accountDiskInUse *common.KeyedLimit
        expiringDivisor  int64
        updateClient     *http.Client
        objEngines       map[int]ObjectEngine
        updateTimeout    time.Duration
        asyncWG          sync.WaitGroup // Used to wait on async goroutines
}

func (server *ObjectServer) Finalize() <span class="cov0" title="0">{
        server.asyncWG.Wait()
}</span>

func (server *ObjectServer) newObject(req *http.Request, vars map[string]string, needData bool) (Object, error) <span class="cov8" title="1">{
        policy, err := strconv.Atoi(req.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policy = 0
        }</span>
        <span class="cov8" title="1">engine, ok := server.objEngines[policy]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Engine for policy index %d not found.", policy)
        }</span>
        <span class="cov8" title="1">return engine.New(vars, needData, &amp;server.asyncWG)</span>
}

func resolveEtag(req *http.Request, metadata map[string]string) string <span class="cov8" title="1">{
        etag := metadata["ETag"]
        for _, ph := range strings.Split(req.Header.Get("X-Backend-Etag-Is-At"), ",") </span><span class="cov8" title="1">{
                ph = strings.Trim(ph, " ")
                if altEtag, exists := metadata[http.CanonicalHeaderKey(ph)]; exists &amp;&amp; ph != "" </span><span class="cov0" title="0">{
                        etag = altEtag
                }</span>
        }
        <span class="cov8" title="1">return etag</span>
}

func (server *ObjectServer) ObjGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        headers := writer.Header()
        obj, err := server.newObject(request, vars, request.Method == "GET")
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to open object.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()

        ifMatches := common.ParseIfMatch(request.Header.Get("If-Match"))
        ifNoneMatches := common.ParseIfMatch(request.Header.Get("If-None-Match"))

        if !obj.Exists() </span><span class="cov8" title="1">{
                if ifMatches["*"] </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                }</span><span class="cov8" title="1"> else {
                        srv.StandardResponse(writer, http.StatusNotFound)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">metadata := obj.Metadata()
        etag := resolveEtag(request, metadata)

        headers.Set("X-Backend-Timestamp", metadata["X-Timestamp"])
        if deleteAt, ok := metadata["X-Delete-At"]; ok </span><span class="cov0" title="0">{
                if deleteTime, err := common.ParseDate(deleteAt); err == nil &amp;&amp; deleteTime.Before(time.Now()) </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusNotFound)
                        return
                }</span>
        }

        <span class="cov8" title="1">lastModified, err := common.ParseDate(metadata["X-Timestamp"])
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting timestamp",
                        zap.String("obj", obj.Repr()),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers.Set("Last-Modified", common.FormatLastModified(lastModified))
        headers.Set("ETag", "\""+etag+"\"")
        xTimestamp, err := common.GetEpochFromTimestamp(metadata["X-Timestamp"])
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting the epoch time from x-timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">headers.Set("X-Timestamp", xTimestamp)
        for key, value := range metadata </span><span class="cov8" title="1">{
                if allowed, ok := server.allowedHeaders[key]; (ok &amp;&amp; allowed) ||
                        strings.HasPrefix(key, "X-Object-Meta-") ||
                        strings.HasPrefix(key, "X-Object-Sysmeta-") </span><span class="cov8" title="1">{
                        headers.Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">if len(ifMatches) &gt; 0 &amp;&amp; !ifMatches[etag] &amp;&amp; !ifMatches["*"] </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusPreconditionFailed)
                return
        }</span>

        <span class="cov8" title="1">if len(ifNoneMatches) &gt; 0 &amp;&amp; (ifNoneMatches[etag] || ifNoneMatches["*"]) </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusNotModified)
                return
        }</span>

        <span class="cov8" title="1">if ius, err := common.ParseDate(request.Header.Get("If-Unmodified-Since")); err == nil &amp;&amp; lastModified.After(ius) </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusPreconditionFailed)
                return
        }</span>

        <span class="cov8" title="1">if ims, err := common.ParseDate(request.Header.Get("If-Modified-Since")); err == nil &amp;&amp; lastModified.Before(ims) </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusNotModified)
                return
        }</span>

        <span class="cov8" title="1">headers.Set("Accept-Ranges", "bytes")
        headers.Set("Content-Type", metadata["Content-Type"])
        headers.Set("Content-Length", metadata["Content-Length"])

        if rangeHeader := request.Header.Get("Range"); rangeHeader != "" </span><span class="cov8" title="1">{
                ranges, err := common.ParseRange(rangeHeader, obj.ContentLength())
                if err != nil </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", "0")
                        headers.Set("Content-Range", fmt.Sprintf("bytes */%d", obj.ContentLength()))
                        writer.WriteHeader(http.StatusRequestedRangeNotSatisfiable)
                        return
                }</span><span class="cov8" title="1"> else if ranges != nil &amp;&amp; len(ranges) == 1 </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", strconv.FormatInt(int64(ranges[0].End-ranges[0].Start), 10))
                        headers.Set("Content-Range", fmt.Sprintf("bytes %d-%d/%d", ranges[0].Start, ranges[0].End-1, obj.ContentLength()))
                        writer.WriteHeader(http.StatusPartialContent)
                        obj.CopyRange(writer, ranges[0].Start, ranges[0].End)
                        return
                }</span><span class="cov8" title="1"> else if ranges != nil &amp;&amp; len(ranges) &gt; 1 </span><span class="cov8" title="1">{
                        w := common.NewMultiWriter(writer, metadata["Content-Type"], obj.ContentLength())
                        for _, rng := range ranges </span><span class="cov8" title="1">{
                                w.Expect(rng.Start, rng.End)
                        }</span>
                        <span class="cov8" title="1">headers.Set("Content-Length", strconv.FormatInt(w.ContentLength(), 10))
                        headers.Set("Content-Type", "multipart/byteranges;boundary="+w.Boundary())
                        writer.WriteHeader(http.StatusPartialContent)
                        for _, rng := range ranges </span><span class="cov8" title="1">{
                                part, err := w.CreatePart(rng.Start, rng.End)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">obj.CopyRange(part, rng.Start, rng.End)</span>
                        }
                        <span class="cov8" title="1">w.Close()
                        return</span>
                }
        }
        <span class="cov8" title="1">writer.WriteHeader(http.StatusOK)
        if request.Method == "GET" </span><span class="cov8" title="1">{
                if server.checkEtags </span><span class="cov0" title="0">{
                        hash := md5.New()
                        obj.Copy(writer, hash)
                        if hex.EncodeToString(hash.Sum(nil)) != metadata["ETag"] </span><span class="cov0" title="0">{
                                obj.Quarantine()
                        }</span>
                }<span class="cov8" title="1"> else {
                        obj.Copy(writer)
                }</span>
        }<span class="cov8" title="1"> else {
                writer.Write([]byte{})
        }</span>
}

func (server *ObjectServer) ObjPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        outHeaders := writer.Header()

        requestTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.GetLogger(request).Error("Error standardizing request X-Timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if vars["obj"] == "" </span><span class="cov0" title="0">{
                http.Error(writer, fmt.Sprintf("Invalid path: %s", request.URL.Path), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if request.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                http.Error(writer, "No content type", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if deleteAt := request.Header.Get("X-Delete-At"); deleteAt != "" </span><span class="cov8" title="1">{
                if deleteTime, err := common.ParseDate(deleteAt); err != nil || deleteTime.Before(time.Now()) </span><span class="cov0" title="0">{
                        http.Error(writer, "X-Delete-At in past", 400)
                        return
                }</span>
        }

        <span class="cov8" title="1">obj, err := server.newObject(request, vars, false)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting obj", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()

        if obj.Exists() </span><span class="cov0" title="0">{
                if inm := request.Header.Get("If-None-Match"); inm == "*" </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
                <span class="cov0" title="0">metadata := obj.Metadata()
                if requestTime, err := common.ParseDate(requestTimestamp); err == nil </span><span class="cov0" title="0">{
                        if lastModified, err := common.ParseDate(metadata["X-Timestamp"]); err == nil &amp;&amp; !requestTime.After(lastModified) </span><span class="cov0" title="0">{
                                outHeaders.Set("X-Backend-Timestamp", metadata["X-Timestamp"])
                                srv.StandardResponse(writer, http.StatusConflict)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if inm := request.Header.Get("If-None-Match"); inm != "*" &amp;&amp; strings.Contains(inm, metadata["ETag"]) </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
        }

        <span class="cov8" title="1">tempFile, err := obj.SetData(request.ContentLength)
        if err == DriveFullError </span><span class="cov0" title="0">{
                srv.GetLogger(request).Debug("Not enough space available")
                srv.CustomErrorResponse(writer, 507, vars)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error making new file", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">hash := md5.New()
        totalSize, err := common.Copy(request.Body, tempFile, hash)
        if err == io.ErrUnexpectedEOF </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, 499)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error writing to file", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">metadata := map[string]string{
                "name":           "/" + vars["account"] + "/" + vars["container"] + "/" + vars["obj"],
                "X-Timestamp":    requestTimestamp,
                "Content-Type":   request.Header.Get("Content-Type"),
                "Content-Length": strconv.FormatInt(totalSize, 10),
                "ETag":           hex.EncodeToString(hash.Sum(nil)),
        }
        for key := range request.Header </span><span class="cov8" title="1">{
                if allowed, ok := server.allowedHeaders[key]; (ok &amp;&amp; allowed) ||
                        strings.HasPrefix(key, "X-Object-Meta-") ||
                        strings.HasPrefix(key, "X-Object-Sysmeta-") </span><span class="cov8" title="1">{
                        metadata[key] = request.Header.Get(key)
                }</span>
        }
        <span class="cov8" title="1">requestEtag := strings.Trim(strings.ToLower(request.Header.Get("ETag")), "\"")
        if requestEtag != "" &amp;&amp; requestEtag != metadata["ETag"] </span><span class="cov8" title="1">{
                http.Error(writer, "Unprocessable Entity", 422)
                return
        }</span>
        <span class="cov8" title="1">outHeaders.Set("ETag", metadata["ETag"])

        if err := obj.Commit(metadata); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error saving object", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">server.containerUpdates(writer, request, metadata, request.Header.Get("X-Delete-At"), vars, srv.GetLogger(request))
        srv.StandardResponse(writer, http.StatusCreated)</span>
}

func (server *ObjectServer) ObjPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)

        requestTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error standardizing request X-Timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if vars["obj"] == "" </span><span class="cov0" title="0">{
                http.Error(writer, fmt.Sprintf("Invalid path: %s", request.URL.Path), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var deleteAtTime time.Time
        if deleteAt := request.Header.Get("X-Delete-At"); deleteAt != "" </span><span class="cov0" title="0">{
                if deleteAtTime, err := common.ParseDate(deleteAt); err != nil || deleteAtTime.Before(time.Now()) </span><span class="cov0" title="0">{
                        http.Error(writer, "X-Delete-At in past", 400)
                        return
                }</span>
        }

        <span class="cov8" title="1">obj, err := server.newObject(request, vars, false)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting obj", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()
        if !obj.Exists() </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">origMetadata := obj.Metadata()
        if requestTime, err := common.ParseDate(requestTimestamp); err == nil </span><span class="cov8" title="1">{
                if origLastModified, err := common.ParseDate(origMetadata["X-Timestamp"]); err == nil &amp;&amp; !requestTime.After(origLastModified) </span><span class="cov0" title="0">{
                        writer.Header().Set("X-Backend-Timestamp", origMetadata["X-Timestamp"])
                        srv.StandardResponse(writer, http.StatusConflict)
                        return
                }</span>
        }
        <span class="cov8" title="1">if t := request.Header.Get("Content-Type"); t != "" &amp;&amp; t != origMetadata["Content-Type"] </span><span class="cov8" title="1">{
                http.Error(writer, fmt.Sprintf("Content-Type may not be sent with object POST: %q", t), http.StatusConflict)
                return
        }</span>

        <span class="cov8" title="1">metadata := make(map[string]string)
        if v, ok := origMetadata["X-Static-Large-Object"]; ok </span><span class="cov0" title="0">{
                metadata["X-Static-Large-Object"] = v
        }</span>
        <span class="cov8" title="1">copyHdrs := map[string]bool{"Content-Disposition": true, "Content-Encoding": true, "X-Delete-At": true, "X-Object-Manifest": true, "X-Static-Large-Object": true}
        for _, v := range strings.Fields(request.Header.Get("X-Backend-Replication-Headers")) </span><span class="cov0" title="0">{
                copyHdrs[v] = true
        }</span>
        <span class="cov8" title="1">for key := range request.Header </span><span class="cov8" title="1">{
                if allowed, ok := server.allowedHeaders[key]; (ok &amp;&amp; allowed) ||
                        copyHdrs[key] ||
                        strings.HasPrefix(key, "X-Object-Meta-") ||
                        strings.HasPrefix(key, "X-Object-Transient-Sysmeta-") </span><span class="cov8" title="1">{
                        metadata[key] = request.Header.Get(key)
                }</span>
        }
        <span class="cov8" title="1">metadata["name"] = "/" + vars["account"] + "/" + vars["container"] + "/" + vars["obj"]
        metadata["X-Timestamp"] = requestTimestamp
        var origDeleteAtTime time.Time
        if origDeleteAt := origMetadata["X-Delete-At"]; origDeleteAt != "" </span><span class="cov0" title="0">{
                if origDeleteAtTime, err = common.ParseDate(origDeleteAt); err != nil </span><span class="cov0" title="0">{
                        origDeleteAtTime = time.Time{}
                }</span>
        }
        <span class="cov8" title="1">if !deleteAtTime.Equal(origDeleteAtTime) </span><span class="cov0" title="0">{
                if !deleteAtTime.IsZero() </span><span class="cov0" title="0">{
                        server.updateDeleteAt("PUT", request.Header, deleteAtTime, vars, srv.GetLogger(request))
                }</span>
                <span class="cov0" title="0">if !origDeleteAtTime.IsZero() </span><span class="cov0" title="0">{
                        server.updateDeleteAt("DELETE", request.Header, origDeleteAtTime, vars, srv.GetLogger(request))
                }</span>
        }

        <span class="cov8" title="1">if err := obj.commitMeta(metadata); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error saving object meta file", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, http.StatusAccepted)</span>
}

func (server *ObjectServer) ObjDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        headers := writer.Header()
        requestTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error standardizing request X-Timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">responseStatus := http.StatusNotFound

        obj, err := server.newObject(request, vars, false)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting obj", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()

        if ida := request.Header.Get("X-If-Delete-At"); ida != "" </span><span class="cov8" title="1">{
                _, err = strconv.ParseInt(ida, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">if !obj.Exists() </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
                <span class="cov8" title="1">metadata := obj.Metadata()
                if _, ok := metadata["X-Delete-At"]; ok </span><span class="cov8" title="1">{
                        if ida != metadata["X-Delete-At"] </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, http.StatusPreconditionFailed)
                                return
                        }</span>
                }<span class="cov8" title="1"> else {
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
        }

        <span class="cov8" title="1">deleteAt := ""
        if obj.Exists() </span><span class="cov8" title="1">{
                responseStatus = http.StatusNoContent
                metadata := obj.Metadata()
                if xda, ok := metadata["X-Delete-At"]; ok </span><span class="cov8" title="1">{
                        deleteAt = xda
                }</span>
                <span class="cov8" title="1">if origTimestamp, ok := metadata["X-Timestamp"]; ok &amp;&amp; origTimestamp &gt;= requestTimestamp </span><span class="cov0" title="0">{
                        headers.Set("X-Backend-Timestamp", origTimestamp)
                        srv.StandardResponse(writer, http.StatusConflict)
                        return
                }</span>
        }<span class="cov0" title="0"> else {
                responseStatus = http.StatusNotFound
        }</span>

        <span class="cov8" title="1">metadata := map[string]string{
                "X-Timestamp": requestTimestamp,
                "name":        "/" + vars["account"] + "/" + vars["container"] + "/" + vars["obj"],
        }
        if err := obj.Delete(metadata); err == DriveFullError </span><span class="cov0" title="0">{
                srv.GetLogger(request).Debug("Not enough space available")
                srv.CustomErrorResponse(writer, 507, vars)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error deleting object", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers.Set("X-Backend-Timestamp", metadata["X-Timestamp"])
        server.containerUpdates(writer, request, metadata, deleteAt, vars, srv.GetLogger(request))
        srv.StandardResponse(writer, responseStatus)</span>
}

func (server *ObjectServer) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
        return
}</span>

func (server *ObjectServer) ReconHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.ReconHandler(server.driveRoot, writer, request)
        return
}</span>

func (server *ObjectServer) OptionsHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.OptionsHandler("object-server", writer, request)
        return
}</span>

func (server *ObjectServer) DiskUsageHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        data, err := server.diskInUse.MarshalJSON()
        if err == nil </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
        }</span><span class="cov0" title="0"> else {
                writer.WriteHeader(http.StatusInternalServerError)
                writer.Write([]byte(err.Error()))
        }</span>
        <span class="cov0" title="0">return</span>
}

func (server *ObjectServer) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                newWriter := &amp;srv.WebWriter{ResponseWriter: writer, Status: 500, ResponseStarted: false}
                start := time.Now()
                logr := server.logger.With(zap.String("txn", request.Header.Get("X-Trans-Id")))
                request = srv.SetLogger(request, logr)
                next.ServeHTTP(newWriter, request)
                forceAcquire := request.Header.Get("X-Force-Acquire") == "true"

                extraInfo := "-"
                if forceAcquire </span><span class="cov0" title="0">{
                        extraInfo = "FA"
                }</span>
                <span class="cov8" title="1">logr.Info("Request log",
                        zap.String("remoteAddr", request.RemoteAddr),
                        zap.String("eventTime", time.Now().Format("02/Jan/2006:15:04:05 -0700")),
                        zap.String("method", request.Method),
                        zap.String("urlPath", common.Urlencode(request.URL.Path)),
                        zap.Int("status", newWriter.Status),
                        zap.String("contentLength", common.GetDefault(newWriter.Header(), "Content-Length", "-")),
                        zap.String("referer", common.GetDefault(request.Header, "Referer", "-")),
                        zap.String("userAgent", common.GetDefault(request.Header, "User-Agent", "-")),
                        zap.Float64("requestTimeSeconds", time.Since(start).Seconds()),
                        zap.String("extraInfo", extraInfo))</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (server *ObjectServer) AcquireDevice(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                vars := srv.GetVars(request)
                if device, ok := vars["device"]; ok &amp;&amp; device != "" </span><span class="cov8" title="1">{
                        devicePath := filepath.Join(server.driveRoot, device)
                        if server.checkMounts </span><span class="cov0" title="0">{
                                if mounted, err := fs.IsMount(devicePath); err != nil || mounted != true </span><span class="cov0" title="0">{
                                        vars["Method"] = request.Method
                                        srv.CustomErrorResponse(writer, 507, vars)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                        if concRequests := server.diskInUse.Acquire(device, forceAcquire); concRequests != 0 </span><span class="cov8" title="1">{
                                writer.Header().Set("X-Disk-Usage", strconv.FormatInt(concRequests, 10))
                                srv.StandardResponse(writer, 503)
                                return
                        }</span>
                        <span class="cov8" title="1">defer server.diskInUse.Release(device)

                        if account, ok := vars["account"]; ok &amp;&amp; account != "" </span><span class="cov8" title="1">{
                                limitKey := fmt.Sprintf("%s/%s", device, account)
                                if concRequests := server.accountDiskInUse.Acquire(limitKey, false); concRequests != 0 </span><span class="cov8" title="1">{
                                        srv.StandardResponse(writer, 498)
                                        return
                                }</span>
                                <span class="cov8" title="1">defer server.accountDiskInUse.Release(limitKey)</span>
                        }
                }
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (server *ObjectServer) updateDeviceLocks(seconds int64) <span class="cov0" title="0">{
        reloadTime := time.Duration(seconds) * time.Second
        for </span><span class="cov0" title="0">{
                time.Sleep(reloadTime)
                for _, key := range server.diskInUse.Keys() </span><span class="cov0" title="0">{
                        lockPath := filepath.Join(server.driveRoot, key, "lock_device")
                        if fs.Exists(lockPath) </span><span class="cov0" title="0">{
                                server.diskInUse.Lock(key)
                        }</span><span class="cov0" title="0"> else {
                                server.diskInUse.Unlock(key)
                        }</span>
                }
        }
}

func (server *ObjectServer) GetHandler(config conf.Config) http.Handler <span class="cov8" title="1">{
        commonHandlers := alice.New(server.LogRequest, middleware.RecoverHandler, middleware.ValidateRequest, server.AcquireDevice)
        router := srv.NewRouter()
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/diskusage", commonHandlers.ThenFunc(server.DiskUsageHandler))
        router.Get("/recon/:method/:recon_type", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/recon/:method", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjGetHandler))
        router.Head("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjGetHandler))
        router.Put("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjPutHandler))
        router.Post("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjPostHandler))
        router.Delete("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjDeleteHandler))
        router.Options("/", commonHandlers.ThenFunc(server.OptionsHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                http.Error(w, fmt.Sprintf("Invalid path: %s", r.URL.Path), http.StatusBadRequest)
        }</span>)
        <span class="cov8" title="1">return alice.New(middleware.GrepObject).Then(router)</span>
}

func GetServer(serverconf conf.Config, flags *flag.FlagSet) (bindIP string, bindPort int, serv srv.Server, logger srv.LowLevelLogger, err error) <span class="cov8" title="1">{
        server := &amp;ObjectServer{driveRoot: "/srv/node", hashPathPrefix: "", hashPathSuffix: "",
                allowedHeaders: map[string]bool{
                        "Content-Disposition":   true,
                        "Content-Encoding":      true,
                        "X-Delete-At":           true,
                        "X-Object-Manifest":     true,
                        "X-Static-Large-Object": true,
                },
        }
        server.hashPathPrefix, server.hashPathSuffix, err = conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, err
        }</span>
        <span class="cov8" title="1">server.objEngines = make(map[int]ObjectEngine)
        for _, policy := range conf.LoadPolicies() </span><span class="cov8" title="1">{
                if newEngine, err := FindEngine(policy.Type); err != nil </span><span class="cov0" title="0">{
                        return "", 0, nil, nil, fmt.Errorf("Unable to find object engine type %s: %v", policy.Type, err)
                }</span><span class="cov8" title="1"> else {
                        server.objEngines[policy.Index], err = newEngine(serverconf, policy, flags)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", 0, nil, nil, fmt.Errorf("Error instantiating object engine type %s: %v", policy.Type, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">server.driveRoot = serverconf.GetDefault("app:object-server", "devices", "/srv/node")
        server.checkMounts = serverconf.GetBool("app:object-server", "mount_check", true)
        server.checkEtags = serverconf.GetBool("app:object-server", "check_etags", false)
        server.diskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:object-server", "disk_limit", 25, 0))
        server.accountDiskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:object-server", "account_rate_limit", 20, 0))
        server.expiringDivisor = serverconf.GetInt("app:object-server", "expiring_objects_container_divisor", 86400)
        bindIP = serverconf.GetDefault("app:object-server", "bind_ip", "0.0.0.0")
        bindPort = int(serverconf.GetInt("app:object-server", "bind_port", 6000))
        if allowedHeaders, ok := serverconf.Get("app:object-server", "allowed_headers"); ok </span><span class="cov0" title="0">{
                headers := strings.Split(allowedHeaders, ",")
                for i := range headers </span><span class="cov0" title="0">{
                        server.allowedHeaders[textproto.CanonicalMIMEHeaderKey(strings.TrimSpace(headers[i]))] = true
                }</span>
        }
        <span class="cov8" title="1">logLevelString := serverconf.GetDefault("app:object-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        if server.logger, err = srv.SetupLogger("object-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>

        <span class="cov8" title="1">server.updateTimeout = time.Duration(serverconf.GetFloat("app:object-server", "container_update_timeout", 0.25) * float64(time.Second))
        connTimeout := time.Duration(serverconf.GetFloat("app:object-server", "conn_timeout", 1.0) * float64(time.Second))
        nodeTimeout := time.Duration(serverconf.GetFloat("app:object-server", "node_timeout", 10.0) * float64(time.Second))
        server.updateClient = &amp;http.Client{
                Timeout:   nodeTimeout,
                Transport: &amp;http.Transport{Dial: (&amp;net.Dialer{Timeout: connTimeout}).Dial},
        }

        deviceLockUpdateSeconds := serverconf.GetInt("app:object-server", "device_lock_update_seconds", 0)
        if deviceLockUpdateSeconds &gt; 0 </span><span class="cov0" title="0">{
                go server.updateDeviceLocks(deviceLockUpdateSeconds)
        }</span>

        <span class="cov8" title="1">statsdHost := serverconf.GetDefault("app:object-server", "log_statsd_host", "")
        if statsdHost != "" </span><span class="cov0" title="0">{
                statsdPort := serverconf.GetInt("app:object-server", "log_statsd_port", 8125)
                // Go metrics collection pause interval in seconds
                statsdPause := serverconf.GetInt("app:object-server", "statsd_collection_pause", 10)
                basePrefix := serverconf.GetDefault("app:object-server", "log_statsd_metric_prefix", "")
                prefix := basePrefix + ".go.objectserver"
                go common.CollectRuntimeMetrics(statsdHost, statsdPort, statsdPause, prefix)
        }</span>

        <span class="cov8" title="1">return bindIP, bindPort, server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "errors"
        "flag"
        "io"
        "sync"

        "github.com/troubling/hummingbird/common/conf"
)

// DriveFullError can be returned by Object.SetData and Object.Delete if the disk is too full for the operation.
var DriveFullError = errors.New("Drive Full")

type Object interface {
        // Exists determines whether or not there is an object to serve. Deleted objects do not exist, even if there is a tombstone.
        Exists() bool
        // Quarantine removes the file's data, presumably after determining it's been corrupted.
        Quarantine() error
        // Metadata returns the object's metadata.  Will be nil if the object doesn't exist.
        Metadata() map[string]string
        // ContentLength returns the object's content-length.
        ContentLength() int64
        // CopyRange copies a range of data from the object to the writer.
        CopyRange(io.Writer, int64, int64) (int64, error)
        // Copy copies an object's entire contents to the writer(s).
        Copy(...io.Writer) (int64, error)
        // SetData sets the data for the object, given the size (if known).  It returns a writer and an error if any.
        SetData(size int64) (io.Writer, error)
        // Commit saves a new object data that was started with SetData.
        Commit(metadata map[string]string) error
        commitMeta(metadata map[string]string) error
        // Delete deletes the object.
        Delete(metadata map[string]string) error
        // Close releases any resources held by the Object instance.
        Close() error
        // Repr returns a representation of the object, used for logging.
        Repr() string
}

// ObjectEngine is the type you have to give hummingbird to create a new object engine.
type ObjectEngine interface {
        // New creates a new instance of the Object, for interacting with a single object.
        New(vars map[string]string, needData bool, asyncWG *sync.WaitGroup) (Object, error)
}

// ObjectEngineConstructor&gt; is a function that, given configs and flags, returns an ObjectEngine
type ObjectEngineConstructor func(conf.Config, *conf.Policy, *flag.FlagSet) (ObjectEngine, error)

type engineFactoryEntry struct {
        name        string
        constructor ObjectEngineConstructor
}

var engineFactories = []engineFactoryEntry{}

// RegisterObjectEngine lets you tell hummingbird about a new object engine.
func RegisterObjectEngine(name string, newEngine ObjectEngineConstructor) <span class="cov8" title="1">{
        for _, e := range engineFactories </span><span class="cov8" title="1">{
                if e.name == name </span><span class="cov0" title="0">{
                        e.constructor = newEngine
                        return
                }</span>
        }
        <span class="cov8" title="1">engineFactories = append(engineFactories, engineFactoryEntry{name, newEngine})</span>
}

// FindEngine returns the registered object engine with the given name.
func FindEngine(name string) (ObjectEngineConstructor, error) <span class="cov8" title="1">{
        for _, e := range engineFactories </span><span class="cov8" title="1">{
                if e.name == name </span><span class="cov8" title="1">{
                        return e.constructor, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, errors.New("Not found")</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bytes"
        "encoding/json"
        "flag"
        "fmt"
        "net/http"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
)

type devLimiter struct {
        inUse             map[int]int
        m                 sync.Mutex
        max               int
        somethingFinished chan struct{}
}

func (d *devLimiter) start(j *PriorityRepJob) bool <span class="cov8" title="1">{
        d.m.Lock()
        doable := d.inUse[j.FromDevice.Id] &lt; d.max
        for _, dev := range j.ToDevices </span><span class="cov8" title="1">{
                doable = doable &amp;&amp; d.inUse[dev.Id] &lt; d.max
        }</span>
        <span class="cov8" title="1">if doable </span><span class="cov8" title="1">{
                d.inUse[j.FromDevice.Id] += 1
                for _, dev := range j.ToDevices </span><span class="cov8" title="1">{
                        d.inUse[dev.Id] += 1
                }</span>
        }
        <span class="cov8" title="1">d.m.Unlock()
        return doable</span>
}

func (d *devLimiter) finished(j *PriorityRepJob) <span class="cov8" title="1">{
        d.m.Lock()
        d.inUse[j.FromDevice.Id] -= 1
        for _, dev := range j.ToDevices </span><span class="cov8" title="1">{
                d.inUse[dev.Id] -= 1
        }</span>
        <span class="cov8" title="1">d.m.Unlock()
        select </span>{
        case d.somethingFinished &lt;- struct{}{}:</span><span class="cov8" title="1">
        default:</span><span class="cov0" title="0">
        }
}

func (d *devLimiter) waitForSomethingToFinish() <span class="cov0" title="0">{
        &lt;-d.somethingFinished
}</span>

// doPriRepJobs executes a list of PriorityRepJobs, limiting concurrent jobs per device to deviceMax.
func doPriRepJobs(jobs []*PriorityRepJob, deviceMax int, client *http.Client) <span class="cov8" title="1">{
        limiter := &amp;devLimiter{inUse: make(map[int]int), max: deviceMax, somethingFinished: make(chan struct{}, 1)}
        wg := sync.WaitGroup{}
        for len(jobs) &gt; 0 </span><span class="cov8" title="1">{
                foundDoable := false
                for i := range jobs </span><span class="cov8" title="1">{
                        if !limiter.start(jobs[i]) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">foundDoable = true
                        wg.Add(1)
                        go func(job *PriorityRepJob) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                defer limiter.finished(job)
                                url := fmt.Sprintf("http://%s:%d/priorityrep", job.FromDevice.ReplicationIp, job.FromDevice.ReplicationPort+500)
                                jsonned, err := json.Marshal(job)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println("Failed to serialize job for some reason:", err)
                                        return
                                }</span>
                                <span class="cov8" title="1">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonned))
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println("Failed to create request for some reason:", err)
                                        return
                                }</span>
                                <span class="cov8" title="1">req.ContentLength = int64(len(jsonned))
                                req.Header.Set("Content-Type", "application/json")
                                resp, err := client.Do(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error moving partition %d: %v\n", job.Partition, err)
                                        return
                                }</span>
                                <span class="cov8" title="1">resp.Body.Close()
                                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                                        fmt.Printf("Bad status code moving partition %d: %d\n", job.Partition, resp.StatusCode)
                                }</span><span class="cov8" title="1"> else {
                                        fmt.Printf("Replicating partition %d from %s/%s\n", job.Partition, job.FromDevice.Ip, job.FromDevice.Device)
                                }</span>
                        }(jobs[i])
                        <span class="cov8" title="1">jobs = append(jobs[:i], jobs[i+1:]...)
                        break</span>
                }
                <span class="cov8" title="1">if !foundDoable </span><span class="cov0" title="0">{
                        limiter.waitForSomethingToFinish()
                }</span>
        }
        <span class="cov8" title="1">wg.Wait()</span>
}

// getPartMoveJobs takes two rings and creates a list of jobs for any partition moves between them.
func getPartMoveJobs(oldRing, newRing ring.Ring) []*PriorityRepJob <span class="cov8" title="1">{
        jobs := make([]*PriorityRepJob, 0)
        for partition := uint64(0); true; partition++ </span><span class="cov8" title="1">{
                olddevs := oldRing.GetNodesInOrder(partition)
                newdevs := newRing.GetNodesInOrder(partition)
                if olddevs == nil || newdevs == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">for i := range olddevs </span><span class="cov8" title="1">{
                        if olddevs[i].Id != newdevs[i].Id </span><span class="cov8" title="1">{
                                // TODO: handle if a node just changes positions, which doesn't happen, but isn't against the contract.
                                jobs = append(jobs, &amp;PriorityRepJob{
                                        Partition:  partition,
                                        FromDevice: olddevs[i],
                                        ToDevices:  []*ring.Device{newdevs[i]},
                                })
                        }</span>
                }
        }
        <span class="cov8" title="1">return jobs</span>
}

// MoveParts takes two object .ring.gz files as []string{oldRing, newRing} and dispatches priority replication jobs to rebalance data in line with any ring changes.
func MoveParts(args []string) <span class="cov0" title="0">{
        flags := flag.NewFlagSet("moveparts", flag.ExitOnError)
        policy := flags.Int("p", 0, "policy index to use")
        flags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "USAGE: hummingbird moveparts [old ringfile]")
                flags.PrintDefaults()
        }</span>
        <span class="cov0" title="0">flags.Parse(args)
        if len(flags.Args()) != 1 </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>

        <span class="cov0" title="0">hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load hash path prefix and suffix:", err)
                return
        }</span>
        <span class="cov0" title="0">oldRing, err := ring.LoadRing(flags.Arg(0), hashPathPrefix, hashPathSuffix)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load old ring:", err)
                return
        }</span>
        <span class="cov0" title="0">curRing, err := ring.GetRing("object", hashPathPrefix, hashPathSuffix, *policy)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load current ring:", err)
                return
        }</span>
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: time.Hour}
        jobs := getPartMoveJobs(oldRing, curRing)
        fmt.Println("Job count:", len(jobs))
        doPriRepJobs(jobs, 2, client)
        fmt.Println("Done sending jobs.")</span>
}

// getRestoreDeviceJobs takes an ip address and device name, and creates a list of jobs to restore that device's data from peers.
func getRestoreDeviceJobs(theRing ring.Ring, ip string, devName string) []*PriorityRepJob <span class="cov8" title="1">{
        jobs := make([]*PriorityRepJob, 0)
        for partition := uint64(0); true; partition++ </span><span class="cov8" title="1">{
                devs := theRing.GetNodesInOrder(partition)
                if devs == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">for i, dev := range devs </span><span class="cov8" title="1">{
                        if dev.Device == devName &amp;&amp; (dev.Ip == ip || dev.ReplicationIp == ip) </span><span class="cov8" title="1">{
                                src := devs[(i+1)%len(devs)]
                                jobs = append(jobs, &amp;PriorityRepJob{
                                        Partition:  partition,
                                        FromDevice: src,
                                        ToDevices:  []*ring.Device{dev},
                                })
                        }</span>
                }
        }
        <span class="cov8" title="1">return jobs</span>
}

// RestoreDevice takes an IP address and device name such as []string{"172.24.0.1", "sda1"} and attempts to restores its data from peers.
func RestoreDevice(args []string) <span class="cov0" title="0">{
        flags := flag.NewFlagSet("restoredevice", flag.ExitOnError)
        policy := flags.Int("p", 0, "policy index to use")
        flags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "USAGE: hummingbird restoredevice [ip] [device]\n")
                flags.PrintDefaults()
        }</span>
        <span class="cov0" title="0">flags.Parse(args)
        if len(flags.Args()) != 2 </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>

        <span class="cov0" title="0">hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load hash path prefix and suffix:", err)
                return
        }</span>
        <span class="cov0" title="0">objRing, err := ring.GetRing("object", hashPathPrefix, hashPathSuffix, *policy)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load ring:", err)
                return
        }</span>
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: time.Hour}
        jobs := getRestoreDeviceJobs(objRing, flags.Arg(0), flags.Arg(1))
        fmt.Println("Job count:", len(jobs))
        doPriRepJobs(jobs, 2, client)
        fmt.Println("Done sending jobs.")</span>
}

func getRescuePartsJobs(objRing ring.Ring, partitions []uint64) []*PriorityRepJob <span class="cov8" title="1">{
        jobs := make([]*PriorityRepJob, 0)
        allDevices := objRing.AllDevices()
        for d := range allDevices </span><span class="cov8" title="1">{
                for _, p := range partitions </span><span class="cov8" title="1">{
                        nodes, _ := objRing.GetJobNodes(p, allDevices[d].Id)
                        jobs = append(jobs, &amp;PriorityRepJob{
                                Partition:  p,
                                FromDevice: &amp;allDevices[d],
                                ToDevices:  nodes,
                        })
                }</span>
        }
        <span class="cov8" title="1">return jobs</span>
}

func RescueParts(args []string) <span class="cov0" title="0">{
        flags := flag.NewFlagSet("rescueparts", flag.ExitOnError)
        policy := flags.Int("p", 0, "policy index to use")
        flags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "USAGE: hummingbird rescueparts partnum1,partnum2,...\n")
                flags.PrintDefaults()
        }</span>
        <span class="cov0" title="0">flags.Parse(args)
        if len(flags.Args()) != 1 </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>

        <span class="cov0" title="0">hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load hash path prefix and suffix:", err)
                return
        }</span>
        <span class="cov0" title="0">objRing, err := ring.GetRing("object", hashPathPrefix, hashPathSuffix, *policy)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load ring:", err)
                return
        }</span>
        <span class="cov0" title="0">partsStr := strings.Split(flags.Arg(0), ",")
        partsInt := make([]uint64, len(partsStr))
        for i, p := range partsStr </span><span class="cov0" title="0">{
                partsInt[i], err = strconv.ParseUint(p, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Invalid Partition:", p)
                        return
                }</span>
        }
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: time.Hour}
        jobs := getRescuePartsJobs(objRing, partsInt)
        fmt.Println("Job count:", len(jobs))
        doPriRepJobs(jobs, 1, client)
        fmt.Println("Done sending jobs.")</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bufio"
        "encoding/binary"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "net/http/httputil"
        "strconv"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
)

var RepUnmountedError = fmt.Errorf("Device unmounted")
var repDialer = (&amp;net.Dialer{Timeout: 5 * time.Second, KeepAlive: 30 * time.Second}).Dial

const repITimeout = time.Minute * 10
const repOTimeout = time.Minute
const repConnBufferSize = 32768

type BeginReplicationRequest struct {
        Device     string
        Partition  string
        NeedHashes bool
}

type BeginReplicationResponse struct {
        Hashes map[string]string
}

type SyncFileRequest struct {
        Path   string
        Xattrs string
        Size   int64
        Check  bool
        Ping   bool
        Done   bool
}

type SyncFileResponse struct {
        Exists      bool
        NewerExists bool
        GoAhead     bool
        Msg         string
}

type FileUploadResponse struct {
        Success bool
        Msg     string
}

type RepConn interface {
        SendMessage(v interface{}) error
        RecvMessage(v interface{}) error
        Write(data []byte) (l int, err error)
        Flush() error
        Read(data []byte) (l int, err error)
        Disconnected() bool
        Close()
}

type repConn struct {
        rw           *bufio.ReadWriter
        c            net.Conn
        disconnected bool
}

func (r *repConn) Disconnected() bool <span class="cov8" title="1">{
        return r.disconnected
}</span>

func (r *repConn) SendMessage(v interface{}) error <span class="cov8" title="1">{
        jsoned, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(r, binary.BigEndian, uint32(len(jsoned))); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">if _, err := r.Write(jsoned); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">if err := r.Flush(); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *repConn) RecvMessage(v interface{}) (err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(repITimeout))
        var length uint32
        if err = binary.Read(r, binary.BigEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return
        }</span>
        <span class="cov8" title="1">data := make([]byte, length)
        if _, err = io.ReadFull(r, data); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return
        }</span>
        <span class="cov8" title="1">if err = json.Unmarshal(data, v); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Write(data []byte) (l int, err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(repOTimeout))
        if l, err = r.rw.Write(data); err != nil </span><span class="cov0" title="0">{
                r.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Flush() (err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(repOTimeout))
        if err = r.rw.Flush(); err != nil </span><span class="cov0" title="0">{
                r.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Read(data []byte) (l int, err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(repITimeout))
        if l, err = io.ReadFull(r.rw, data); err != nil </span><span class="cov0" title="0">{
                r.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Close() <span class="cov8" title="1">{
        r.disconnected = true
        r.c.Close()
}</span>

func NewRepConn(dev *ring.Device, partition string, policy int) (RepConn, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s:%d/%s/%s", dev.ReplicationIp, dev.ReplicationPort, dev.Device, partition)
        req, err := http.NewRequest("REPCONN", url, nil)
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Add("X-Trans-Id", fmt.Sprintf("%s-%d", common.UUID(), dev.Id))
        conn, err := repDialer("tcp", req.URL.Host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">hc := httputil.NewClientConn(conn, nil)
        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode/100 != 2 </span><span class="cov8" title="1">{
                return nil, RepUnmountedError
        }</span>
        <span class="cov8" title="1">newc, _ := hc.Hijack()
        if newc, ok := newc.(*net.TCPConn); ok </span><span class="cov8" title="1">{
                newc.SetNoDelay(true)
        }</span>
        <span class="cov8" title="1">return &amp;repConn{
                rw: bufio.NewReadWriter(
                        bufio.NewReaderSize(newc, repConnBufferSize),
                        bufio.NewWriterSize(newc, repConnBufferSize)),
                c: newc,
        }, nil</span>
}

func NewIncomingRepConn(rw *bufio.ReadWriter, c net.Conn) RepConn <span class="cov8" title="1">{
        return &amp;repConn{rw: rw, c: c}
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "encoding/hex"
        "flag"
        "fmt"
        "io/ioutil"
        "math/rand"
        _ "net/http/pprof"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

var (
        StatsReportInterval    = 10 * time.Minute
        TmpEmptyTime           = 24 * time.Hour
        ReplicateDeviceTimeout = 4 * time.Hour
        // GetRing is a local pointer to the hummingbird function, for overriding in tests
        GetRing = ring.GetRing
)

type PriorityRepJob struct {
        Partition  uint64         `json:"partition"`
        FromDevice *ring.Device   `json:"from_device"`
        ToDevices  []*ring.Device `json:"to_devices"`
        Policy     int            `json:"policy"`
}

// minimal ring interface for replication
type replicationRing interface {
        GetJobNodes(partition uint64, localDevice int) (response []*ring.Device, handoff bool)
        GetMoreNodes(partition uint64) ring.MoreNodes
        LocalDevices(localPort int) (devs []*ring.Device, err error)
}

type quarantineFileError struct {
        msg string
}

func (q quarantineFileError) Error() string <span class="cov0" title="0">{
        return q.msg
}</span>

func deviceKey(dev *ring.Device, policy int) string <span class="cov8" title="1">{
        if policy == 0 </span><span class="cov8" title="1">{
                return dev.Device
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%d", dev.Device, policy)</span>
}

func getFile(filePath string) (fp *os.File, xattrs []byte, size int64, err error) <span class="cov8" title="1">{
        fp, err = os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, 0, fmt.Errorf("unable to open file (%v): %s", err, filePath)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        fp.Close()
                }</span>
        }()
        <span class="cov8" title="1">finfo, err := fp.Stat()
        if err != nil || !finfo.Mode().IsRegular() </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"not a regular file"}
        }</span>
        <span class="cov8" title="1">rawxattr, err := RawReadMetadata(fp.Fd())
        if err != nil || len(rawxattr) == 0 </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"error reading xattrs"}
        }</span>

        // Perform a mini-audit, since it's cheap and we can potentially avoid spreading bad data around.
        <span class="cov8" title="1">v, err := pickle.PickleLoads(rawxattr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"error unpickling xattrs"}
        }</span>
        <span class="cov8" title="1">metadata, ok := v.(map[interface{}]interface{})
        if !ok </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"invalid metadata type"}
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                if _, ok := key.(string); !ok </span><span class="cov8" title="1">{
                        return nil, nil, 0, quarantineFileError{"invalid key in metadata"}
                }</span>
                <span class="cov8" title="1">if _, ok := value.(string); !ok </span><span class="cov8" title="1">{
                        return nil, nil, 0, quarantineFileError{"invalid value in metadata"}
                }</span>
        }
        <span class="cov8" title="1">switch filepath.Ext(filePath) </span>{
        case ".data":<span class="cov8" title="1">
                for _, reqEntry := range []string{"Content-Length", "Content-Type", "name", "ETag", "X-Timestamp"} </span><span class="cov8" title="1">{
                        if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                return nil, nil, 0, quarantineFileError{".data missing required metadata"}
                        }</span>
                }
                <span class="cov8" title="1">if contentLength, err := strconv.ParseInt(metadata["Content-Length"].(string), 10, 64); err != nil || contentLength != finfo.Size() </span><span class="cov0" title="0">{
                        return nil, nil, 0, quarantineFileError{"invalid content-length"}
                }</span>
        case ".ts":<span class="cov8" title="1">
                for _, reqEntry := range []string{"name", "X-Timestamp"} </span><span class="cov8" title="1">{
                        if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                return nil, nil, 0, quarantineFileError{".ts missing required metadata"}
                        }</span>
                }
        }
        <span class="cov8" title="1">return fp, rawxattr, finfo.Size(), nil</span>
}

type ReplicationDeviceStats struct {
        Stats            map[string]int64
        LastCheckin      time.Time
        RunStarted       time.Time
        DeviceStarted    time.Time
        LastPassDate     time.Time
        LastPassDuration time.Duration
        TotalPasses      int64
}

type ReplicationDevice interface {
        Replicate()
        ReplicateLoop()
        Key() string
        Cancel()
        PriorityReplicate(pri PriorityRepJob, timeout time.Duration) bool
        Stats() *ReplicationDeviceStats
}

type replicationDevice struct {
        // If you have a better way to make struct methods that are overridable for tests, please call my house.
        i interface {
                beginReplication(dev *ring.Device, partition string, hashes bool, rChan chan beginReplicationResponse)
                listObjFiles(objChan chan string, cancel chan struct{}, partdir string, needSuffix func(string) bool)
                syncFile(objFile string, dst []*syncFileArg, handoff bool) (syncs int, insync int, err error)
                replicateLocal(partition string, nodes []*ring.Device, moreNodes ring.MoreNodes)
                replicateHandoff(partition string, nodes []*ring.Device)
                cleanTemp()
                listPartitions() ([]string, error)
                replicatePartition(partition string)
        }
        r      *Replicator
        dev    *ring.Device
        policy int
        cancel chan struct{}
        priRep chan PriorityRepJob
        stats  ReplicationDeviceStats
}

func (rd *replicationDevice) Stats() *ReplicationDeviceStats <span class="cov8" title="1">{
        return &amp;rd.stats
}</span>

type statUpdate struct {
        deviceKey string
        stat      string
        value     int64
}

func (rd *replicationDevice) updateStat(stat string, amount int64) <span class="cov8" title="1">{
        rd.r.updateStat &lt;- statUpdate{rd.Key(), stat, amount}
}</span>

type beginReplicationResponse struct {
        dev    *ring.Device
        conn   RepConn
        hashes map[string]string
        err    error
}

func (rd *replicationDevice) listObjFiles(objChan chan string, cancel chan struct{}, partdir string, needSuffix func(string) bool) <span class="cov8" title="1">{
        defer close(objChan)
        suffixDirs, err := filepath.Glob(filepath.Join(partdir, "[a-f0-9][a-f0-9][a-f0-9]"))
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[listObjFiles]", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">if len(suffixDirs) == 0 </span><span class="cov8" title="1">{
                os.Remove(filepath.Join(partdir, ".lock"))
                os.Remove(filepath.Join(partdir, "hashes.pkl"))
                os.Remove(filepath.Join(partdir, "hashes.invalid"))
                os.Remove(partdir)
                return
        }</span>
        <span class="cov8" title="1">for i := len(suffixDirs) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{ // shuffle suffixDirs list
                j := rand.Intn(i + 1)
                suffixDirs[j], suffixDirs[i] = suffixDirs[i], suffixDirs[j]
        }</span>
        <span class="cov8" title="1">for _, suffDir := range suffixDirs </span><span class="cov8" title="1">{
                if !needSuffix(filepath.Base(suffDir)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">hashDirs, err := filepath.Glob(filepath.Join(suffDir, "????????????????????????????????"))
                if err != nil </span><span class="cov0" title="0">{
                        rd.r.logger.Error("[listObjFiles]", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">if len(hashDirs) == 0 </span><span class="cov8" title="1">{
                        os.Remove(suffDir)
                        continue</span>
                }
                <span class="cov8" title="1">for _, hashDir := range hashDirs </span><span class="cov8" title="1">{
                        fileList, err := filepath.Glob(filepath.Join(hashDir, "*.[tdm]*"))
                        if len(fileList) == 0 </span><span class="cov8" title="1">{
                                os.Remove(hashDir)
                                continue</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("[listObjFiles]", zap.Error(err))
                                return
                        }</span>
                        <span class="cov8" title="1">for _, objFile := range fileList </span><span class="cov8" title="1">{
                                select </span>{
                                case objChan &lt;- objFile:</span><span class="cov8" title="1">
                                case &lt;-cancel:<span class="cov8" title="1">
                                        return</span>
                                }
                        }
                }
        }
}

type syncFileArg struct {
        conn RepConn
        dev  *ring.Device
}

func (rd *replicationDevice) syncFile(objFile string, dst []*syncFileArg, handoff bool) (syncs int, insync int, err error) <span class="cov8" title="1">{
        // TODO: parallelize the data transfer someday
        var wrs []*syncFileArg
        lst := strings.Split(objFile, string(os.PathSeparator))
        relPath := filepath.Join(lst[len(lst)-5:]...)
        fp, xattrs, fileSize, err := getFile(objFile)
        if _, ok := err.(quarantineFileError); ok </span><span class="cov0" title="0">{
                hashDir := filepath.Dir(objFile)
                rd.r.logger.Error("[syncFile] Failed audit and is being quarantined",
                        zap.String("hashDir", hashDir),
                        zap.Error(err))
                QuarantineHash(hashDir)
                return 0, 0, nil
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                return 0, 0, nil
        }</span>
        <span class="cov8" title="1">defer fp.Close()

        // are we already going to sync to this region?
        syncingRemoteRegion := make(map[int]bool)

        // ask each server if we need to sync the file
        for _, sfa := range dst </span><span class="cov8" title="1">{
                var sfr SyncFileResponse
                thisPath := filepath.Join(sfa.dev.Device, relPath)
                sfa.conn.SendMessage(SyncFileRequest{Path: thisPath, Xattrs: hex.EncodeToString(xattrs), Size: fileSize,
                        // if we're already syncing handoffs to this remote region, just do a check
                        Check: handoff &amp;&amp; syncingRemoteRegion[sfa.dev.Region],
                        // If we're not syncing handoffs, we don't care about the state. Just ping to keep the connection alive.
                        Ping: !handoff &amp;&amp; syncingRemoteRegion[sfa.dev.Region],
                })
                if err := sfa.conn.RecvMessage(&amp;sfr); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }<span class="cov8" title="1"> else if sfr.GoAhead </span><span class="cov8" title="1">{
                        wrs = append(wrs, sfa)
                        if sfa.dev.Region != rd.dev.Region </span><span class="cov8" title="1">{
                                syncingRemoteRegion[sfa.dev.Region] = true
                        }</span>
                }<span class="cov8" title="1"> else if sfr.NewerExists </span><span class="cov8" title="1">{
                        insync++
                        if os.Remove(objFile) == nil </span><span class="cov8" title="1">{
                                InvalidateHash(filepath.Dir(objFile))
                        }</span>
                }<span class="cov8" title="1"> else if sfr.Exists </span><span class="cov8" title="1">{
                        insync++
                }</span>
        }
        <span class="cov8" title="1">if len(wrs) == 0 </span><span class="cov8" title="1">{ // nobody needed the file
                return
        }</span>

        // send the file to servers
        <span class="cov8" title="1">scratch := make([]byte, 32768)
        var length int
        var totalRead int64
        for length, err = fp.Read(scratch); err == nil; length, err = fp.Read(scratch) </span><span class="cov8" title="1">{
                totalRead += int64(length)
                for index, sfa := range wrs </span><span class="cov8" title="1">{
                        if sfa == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, err := sfa.conn.Write(scratch[0:length]); err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Failed to write to remoteDevice",
                                        zap.Int("device id", sfa.dev.Id),
                                        zap.Error(err))
                                wrs[index] = nil
                        }</span>
                }
        }
        <span class="cov8" title="1">if totalRead != fileSize </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("Failed to read the full file: %s, %v", objFile, err)
        }</span>

        // get file upload results
        <span class="cov8" title="1">for _, sfa := range wrs </span><span class="cov8" title="1">{
                if sfa == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var fur FileUploadResponse
                sfa.conn.Flush()
                if sfa.conn.RecvMessage(&amp;fur) == nil </span><span class="cov8" title="1">{
                        if fur.Success </span><span class="cov8" title="1">{
                                syncs++
                                insync++
                                rd.updateStat("FilesSent", 1)
                                rd.updateStat("BytesSent", fileSize)
                        }</span>
                }
        }
        <span class="cov8" title="1">return syncs, insync, nil</span>
}

func (rd *replicationDevice) beginReplication(dev *ring.Device, partition string, hashes bool, rChan chan beginReplicationResponse) <span class="cov8" title="1">{
        var brr BeginReplicationResponse
        if rc, err := NewRepConn(dev, partition, rd.policy); err != nil </span><span class="cov8" title="1">{
                rChan &lt;- beginReplicationResponse{dev: dev, err: err}
        }</span><span class="cov8" title="1"> else if err := rc.SendMessage(BeginReplicationRequest{Device: dev.Device, Partition: partition, NeedHashes: hashes}); err != nil </span><span class="cov0" title="0">{
                rChan &lt;- beginReplicationResponse{dev: dev, err: err}
        }</span><span class="cov8" title="1"> else if err := rc.RecvMessage(&amp;brr); err != nil </span><span class="cov0" title="0">{
                rChan &lt;- beginReplicationResponse{dev: dev, err: err}
        }</span><span class="cov8" title="1"> else {
                rChan &lt;- beginReplicationResponse{dev: dev, conn: rc, hashes: brr.Hashes}
        }</span>
}

func (rd *replicationDevice) replicateLocal(partition string, nodes []*ring.Device, moreNodes ring.MoreNodes) <span class="cov8" title="1">{
        path := filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy), partition)
        syncCount := 0
        startGetHashesRemote := time.Now()
        remoteHashes := make(map[int]map[string]string)
        remoteConnections := make(map[int]RepConn)
        rChan := make(chan beginReplicationResponse)
        for _, dev := range nodes </span><span class="cov8" title="1">{
                go rd.i.beginReplication(dev, partition, true, rChan)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(nodes); i++ </span><span class="cov8" title="1">{
                rData := &lt;-rChan
                if rData.err == nil </span><span class="cov8" title="1">{
                        defer rData.conn.Close()
                        remoteHashes[rData.dev.Id] = rData.hashes
                        remoteConnections[rData.dev.Id] = rData.conn
                }</span><span class="cov8" title="1"> else if rData.err == RepUnmountedError </span><span class="cov8" title="1">{
                        if nextNode := moreNodes.Next(); nextNode != nil </span><span class="cov8" title="1">{
                                go rd.i.beginReplication(nextNode, partition, true, rChan)
                                nodes = append(nodes, nextNode)
                        }</span><span class="cov0" title="0"> else {
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if len(remoteHashes) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">timeGetHashesRemote := float64(time.Now().Sub(startGetHashesRemote)) / float64(time.Second)
        startGetHashesLocal := time.Now()

        recalc := []string{}
        hashes, err := GetHashes(rd.r.deviceRoot, rd.dev.Device, partition, recalc, rd.r.reclaimAge, rd.policy, rd.r.logger)
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateLocal] error getting local hashes", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for suffix, localHash := range hashes </span><span class="cov8" title="1">{
                for _, remoteHash := range remoteHashes </span><span class="cov8" title="1">{
                        if remoteHash[suffix] != "" &amp;&amp; localHash != remoteHash[suffix] </span><span class="cov8" title="1">{
                                recalc = append(recalc, suffix)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">hashes, err = GetHashes(rd.r.deviceRoot, rd.dev.Device, partition, recalc, rd.r.reclaimAge, rd.policy, rd.r.logger)
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateLocal] error recalculating local hashes", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">timeGetHashesLocal := float64(time.Now().Sub(startGetHashesLocal)) / float64(time.Second)

        objChan := make(chan string, 100)
        cancel := make(chan struct{})
        defer close(cancel)
        go rd.i.listObjFiles(objChan, cancel, path, func(suffix string) bool </span><span class="cov8" title="1">{
                for _, remoteHash := range remoteHashes </span><span class="cov8" title="1">{
                        if hashes[suffix] != remoteHash[suffix] </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        })
        <span class="cov8" title="1">startSyncing := time.Now()
        for objFile := range objChan </span><span class="cov8" title="1">{
                toSync := make([]*syncFileArg, 0)
                suffix := filepath.Base(filepath.Dir(filepath.Dir(objFile)))
                for _, dev := range nodes </span><span class="cov8" title="1">{
                        if rhashes, ok := remoteHashes[dev.Id]; ok &amp;&amp; hashes[suffix] != rhashes[suffix] </span><span class="cov8" title="1">{
                                if !remoteConnections[dev.Id].Disconnected() </span><span class="cov8" title="1">{
                                        toSync = append(toSync, &amp;syncFileArg{conn: remoteConnections[dev.Id], dev: dev})
                                }</span>
                        }
                }
                <span class="cov8" title="1">if len(toSync) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if syncs, _, err := rd.i.syncFile(objFile, toSync, false); err == nil </span><span class="cov8" title="1">{
                        syncCount += syncs
                }</span><span class="cov0" title="0"> else {
                        rd.r.logger.Error("[syncFile]", zap.Error(err))
                        return
                }</span>
        }
        <span class="cov8" title="1">for _, conn := range remoteConnections </span><span class="cov8" title="1">{
                if !conn.Disconnected() </span><span class="cov8" title="1">{
                        conn.SendMessage(SyncFileRequest{Done: true})
                }</span>
        }
        <span class="cov8" title="1">timeSyncing := float64(time.Now().Sub(startSyncing)) / float64(time.Second)
        if syncCount &gt; 0 </span><span class="cov8" title="1">{
                rd.r.logger.Info("[replicateLocal]",
                        zap.String("Partition", path),
                        zap.Any("Files Synced", syncCount),
                        zap.Float64("timeGetHashesRemote", timeGetHashesRemote),
                        zap.Float64("timeGetHashesLocal", timeGetHashesLocal),
                        zap.Float64("timeSyncing", timeSyncing))
        }</span>
}

func (rd *replicationDevice) replicateHandoff(partition string, nodes []*ring.Device) <span class="cov8" title="1">{
        path := filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy), partition)
        syncCount := 0
        remoteConnections := make(map[int]RepConn)
        rChan := make(chan beginReplicationResponse)
        for _, dev := range nodes </span><span class="cov8" title="1">{
                go rd.i.beginReplication(dev, partition, false, rChan)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(nodes); i++ </span><span class="cov8" title="1">{
                rData := &lt;-rChan
                if rData.err == nil </span><span class="cov8" title="1">{
                        defer rData.conn.Close()
                        remoteConnections[rData.dev.Id] = rData.conn
                }</span>
        }
        <span class="cov8" title="1">if len(remoteConnections) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">objChan := make(chan string, 100)
        cancel := make(chan struct{})
        defer close(cancel)
        go rd.i.listObjFiles(objChan, cancel, path, func(string) bool </span><span class="cov8" title="1">{ return true }</span>)
        <span class="cov8" title="1">for objFile := range objChan </span><span class="cov8" title="1">{
                toSync := make([]*syncFileArg, 0)
                for _, dev := range nodes </span><span class="cov8" title="1">{
                        if remoteConnections[dev.Id] != nil &amp;&amp; !remoteConnections[dev.Id].Disconnected() </span><span class="cov8" title="1">{
                                toSync = append(toSync, &amp;syncFileArg{conn: remoteConnections[dev.Id], dev: dev})
                        }</span>
                }
                <span class="cov8" title="1">if len(toSync) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if syncs, insync, err := rd.i.syncFile(objFile, toSync, true); err == nil </span><span class="cov8" title="1">{
                        syncCount += syncs

                        success := insync == len(nodes)
                        if rd.r.quorumDelete </span><span class="cov0" title="0">{
                                success = insync &gt;= len(nodes)/2+1
                        }</span>
                        <span class="cov8" title="1">if success </span><span class="cov8" title="1">{
                                os.Remove(objFile)
                                os.Remove(filepath.Dir(objFile))
                        }</span>
                }<span class="cov0" title="0"> else {
                        rd.r.logger.Error("[syncFile]", zap.Error(err))
                        return
                }</span>
        }
        <span class="cov8" title="1">for _, conn := range remoteConnections </span><span class="cov8" title="1">{
                if !conn.Disconnected() </span><span class="cov8" title="1">{
                        conn.SendMessage(SyncFileRequest{Done: true})
                }</span>
        }
        <span class="cov8" title="1">if syncCount &gt; 0 </span><span class="cov8" title="1">{
                rd.r.logger.Info("[replicateHandoff]", zap.String("Partition", path), zap.Any("Files Synced", syncCount))
        }</span>
}

func (rd *replicationDevice) Key() string <span class="cov8" title="1">{
        return deviceKey(rd.dev, rd.policy)
}</span>

func (rd *replicationDevice) cleanTemp() <span class="cov8" title="1">{
        tempDir := TempDirPath(rd.r.deviceRoot, rd.dev.Device)
        if tmpContents, err := ioutil.ReadDir(tempDir); err == nil </span><span class="cov8" title="1">{
                for _, tmpEntry := range tmpContents </span><span class="cov8" title="1">{
                        if time.Since(tmpEntry.ModTime()) &gt; TmpEmptyTime </span><span class="cov8" title="1">{
                                os.RemoveAll(filepath.Join(tempDir, tmpEntry.Name()))
                        }</span>
                }
        }
}

func (rd *replicationDevice) replicatePartition(partition string) <span class="cov8" title="1">{
        rd.r.concurrencySem &lt;- struct{}{}
        defer func() </span><span class="cov8" title="1">{
                &lt;-rd.r.concurrencySem
        }</span>()
        <span class="cov8" title="1">partitioni, err := strconv.ParseUint(partition, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">nodes, handoff := rd.r.Rings[rd.policy].GetJobNodes(partitioni, rd.dev.Id)
        if handoff </span><span class="cov8" title="1">{
                rd.i.replicateHandoff(partition, nodes)
        }</span><span class="cov8" title="1"> else {
                rd.i.replicateLocal(partition, nodes, rd.r.Rings[rd.policy].GetMoreNodes(partitioni))
        }</span>
        <span class="cov8" title="1">rd.updateStat("PartitionsDone", 1)</span>
}

func (rd *replicationDevice) listPartitions() ([]string, error) <span class="cov8" title="1">{
        objPath := filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy))
        partitions, err := filepath.Glob(filepath.Join(objPath, "[0-9]*"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">partitionList := make([]string, 0, len(partitions))
        for _, partition := range partitions </span><span class="cov8" title="1">{
                partition = filepath.Base(partition)
                if len(rd.r.partitions) &gt; 0 &amp;&amp; !rd.r.partitions[partition] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, err := strconv.ParseUint(partition, 10, 64); err == nil </span><span class="cov8" title="1">{
                        partitionList = append(partitionList, partition)
                }</span>
        }
        <span class="cov8" title="1">for i := len(partitionList) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{ // shuffle partition list
                j := rand.Intn(i + 1)
                partitionList[j], partitionList[i] = partitionList[i], partitionList[j]
        }</span>
        <span class="cov8" title="1">return partitionList, nil</span>
}

func (rd *replicationDevice) Replicate() <span class="cov8" title="1">{
        defer srv.LogPanics(rd.r.logger, fmt.Sprintf("PANIC REPLICATING DEVICE: %s", rd.dev.Device))
        rd.updateStat("startRun", 1)
        if mounted, err := fs.IsMount(filepath.Join(rd.r.deviceRoot, rd.dev.Device)); rd.r.checkMounts &amp;&amp; (err != nil || mounted != true) </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateDevice] Drive not mounted", zap.String("Device", rd.dev.Device))
                return
        }</span>
        <span class="cov8" title="1">if fs.Exists(filepath.Join(rd.r.deviceRoot, rd.dev.Device, "lock_device")) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">rd.i.cleanTemp()

        partitionList, err := rd.i.listPartitions()
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateDevice] Error getting partition list",
                        zap.String("Device", rd.dev.Device),
                        zap.Error(err))
                return
        }</span><span class="cov8" title="1"> else if len(partitionList) == 0 </span><span class="cov8" title="1">{
                rd.r.logger.Error("[replicateDevice] No partitions found",
                        zap.String("filepath", filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy))))
                return
        }</span>
        <span class="cov8" title="1">rd.updateStat("PartitionsTotal", int64(len(partitionList)))

        for _, partition := range partitionList </span><span class="cov8" title="1">{
                rd.updateStat("checkin", 1)
                select </span>{
                case &lt;-rd.cancel:<span class="cov8" title="1">
                        </span><span class="cov8" title="1">{
                                rd.r.logger.Error("replicateDevice canceled for device", zap.String("Device", rd.dev.Device))
                                return
                        }</span>
                default:</span><span class="cov8" title="1">
                }
                <span class="cov8" title="1">rd.processPriorityJobs()
                rd.i.replicatePartition(partition)</span>
        }
        <span class="cov8" title="1">rd.updateStat("FullReplicateCount", 1)</span>
}

func (rd *replicationDevice) Cancel() <span class="cov0" title="0">{
        close(rd.cancel)
}</span>

func (rd *replicationDevice) ReplicateLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        rd.Replicate()</span>
                }
                <span class="cov8" title="1">time.Sleep(rd.r.loopSleepTime)</span>
        }
}

type NoMoreNodes struct{}

func (n *NoMoreNodes) Next() *ring.Device <span class="cov0" title="0">{
        return nil
}</span>

func (rd *replicationDevice) PriorityReplicate(pri PriorityRepJob, timeout time.Duration) bool <span class="cov0" title="0">{
        timer := time.NewTimer(timeout)
        defer timer.Stop()
        select </span>{
        case rd.priRep &lt;- pri:<span class="cov0" title="0">
                return true</span>
        case &lt;-timer.C:<span class="cov0" title="0">
                return false</span>
        }
}

// processPriorityJobs runs any pending priority jobs given the device's id
func (rd *replicationDevice) processPriorityJobs() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case pri := &lt;-rd.priRep:<span class="cov8" title="1">
                        func() </span><span class="cov8" title="1">{
                                time.Sleep(rd.r.partSleepTime)
                                rd.r.concurrencySem &lt;- struct{}{}
                                defer func() </span><span class="cov8" title="1">{
                                        &lt;-rd.r.concurrencySem
                                }</span>()
                                <span class="cov8" title="1">partition := strconv.FormatUint(pri.Partition, 10)
                                _, handoff := rd.r.Rings[rd.policy].GetJobNodes(pri.Partition, pri.FromDevice.Id)
                                toDevicesArr := make([]string, len(pri.ToDevices))
                                for i, s := range pri.ToDevices </span><span class="cov8" title="1">{
                                        toDevicesArr[i] = fmt.Sprintf("%s:%d/%s", s.Ip, s.Port, s.Device)
                                }</span>
                                <span class="cov8" title="1">jobType := "local"
                                if handoff </span><span class="cov8" title="1">{
                                        jobType = "handoff"
                                }</span>
                                <span class="cov8" title="1">rd.r.logger.Info("PriorityReplicationJob",
                                        zap.Uint64("partition", pri.Partition),
                                        zap.String("jobType", jobType),
                                        zap.String("From Device", pri.FromDevice.Device),
                                        zap.String("To Device", strings.Join(toDevicesArr, ",")))
                                if handoff </span><span class="cov8" title="1">{
                                        rd.i.replicateHandoff(partition, pri.ToDevices)
                                }</span><span class="cov8" title="1"> else {
                                        rd.i.replicateLocal(partition, pri.ToDevices, &amp;NoMoreNodes{})
                                }</span>
                        }()
                        <span class="cov8" title="1">rd.updateStat("PriorityRepsDone", 1)</span>
                default:<span class="cov8" title="1">
                        return</span>
                }
        }
}

var newReplicationDevice = func(dev *ring.Device, policy int, r *Replicator) *replicationDevice <span class="cov8" title="1">{
        rd := &amp;replicationDevice{
                r:      r,
                dev:    dev,
                policy: policy,
                cancel: make(chan struct{}),
                priRep: make(chan PriorityRepJob),
                stats: ReplicationDeviceStats{
                        LastCheckin:   time.Now(),
                        DeviceStarted: time.Now(),
                        Stats: map[string]int64{
                                "PartitionsDone":   0,
                                "PartitionsTotal":  0,
                                "FilesSent":        0,
                                "BytesSent":        0,
                                "PriorityRepsDone": 0,
                        },
                },
        }
        rd.i = rd
        return rd
}</span>

// Object replicator daemon object
type Replicator struct {
        checkMounts        bool
        deviceRoot         string
        reconCachePath     string
        logger             srv.LowLevelLogger
        logLevel           *zap.AtomicLevel
        port               int
        bindIp             string
        Rings              map[int]replicationRing
        runningDevices     map[string]ReplicationDevice
        cancelCounts       map[string]int64
        runningDevicesLock sync.Mutex
        devices            map[string]bool
        partitions         map[string]bool
        concurrency        int
        concurrencySem     chan struct{}
        updateStat         chan statUpdate
        reclaimAge         int64
        quorumDelete       bool
        reserve            int64
        replicationMan     *ReplicationManager
        replicateTimeout   time.Duration
        onceDone           chan struct{}
        onceWaiting        int64
        loopSleepTime      time.Duration
        partSleepTime      time.Duration
}

func (r *Replicator) cancelStalledDevices() <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                stats := rd.Stats()
                if time.Since(stats.LastCheckin) &gt; ReplicateDeviceTimeout </span><span class="cov8" title="1">{
                        rd.Cancel()
                        r.cancelCounts[key] += 1
                        delete(r.runningDevices, key)
                }</span>
        }
}

func (r *Replicator) verifyRunningDevices() <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        expectedDevices := make(map[string]bool)
        for policy, ring := range r.Rings </span><span class="cov8" title="1">{
                ringDevices, err := ring.LocalDevices(r.port)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Error getting local devices from ring", zap.Error(err))
                        return
                }</span>
                // look for devices that aren't running but should be
                <span class="cov8" title="1">for _, dev := range ringDevices </span><span class="cov8" title="1">{
                        expectedDevices[deviceKey(dev, policy)] = true
                        if len(r.devices) &gt; 0 &amp;&amp; !r.devices[dev.Device] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, ok := r.runningDevices[deviceKey(dev, policy)]; !ok </span><span class="cov8" title="1">{
                                r.runningDevices[deviceKey(dev, policy)] = newReplicationDevice(dev, policy, r)
                                go r.runningDevices[deviceKey(dev, policy)].ReplicateLoop()
                        }</span>
                }
        }
        // look for devices that are running but shouldn't be
        <span class="cov8" title="1">for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                if _, found := expectedDevices[key]; !found </span><span class="cov8" title="1">{
                        rd.Cancel()
                        delete(r.runningDevices, key)
                }</span>
        }
}

func (r *Replicator) reportStats() <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        minLastPass := time.Now()
        allHaveCompleted := true
        for _, rd := range r.runningDevices </span><span class="cov8" title="1">{
                stats := rd.Stats()
                if stats.TotalPasses &lt;= 1 </span><span class="cov8" title="1">{
                        allHaveCompleted = false
                }</span>
                <span class="cov8" title="1">if stats.LastPassDate.Before(minLastPass) </span><span class="cov8" title="1">{
                        minLastPass = stats.LastPassDate
                }</span>
                <span class="cov8" title="1">processingTimeSec := time.Since(stats.RunStarted).Seconds()
                doneParts := stats.Stats["PartitionsDone"]
                totalParts := stats.Stats["PartitionsTotal"]
                partsPerSecond := float64(doneParts) / processingTimeSec

                remaining := time.Duration(
                        int64(float64(totalParts-doneParts)/partsPerSecond)) * time.Second
                var remainingStr string
                if remaining &gt;= time.Hour </span><span class="cov8" title="1">{
                        remainingStr = fmt.Sprintf("%.0fh", remaining.Hours())
                }</span><span class="cov8" title="1"> else if remaining &gt;= time.Minute </span><span class="cov0" title="0">{
                        remainingStr = fmt.Sprintf("%.0fm", remaining.Minutes())
                }</span><span class="cov8" title="1"> else {
                        remainingStr = fmt.Sprintf("%.0fs", remaining.Seconds())
                }</span>
                <span class="cov8" title="1">r.logger.Info("Partition Replicated",
                        zap.String("Device", rd.Key()),
                        zap.Int64("doneParts", doneParts),
                        zap.Int64("totalParts", totalParts),
                        zap.Float64("DoneParts/TotalParts", float64(100*doneParts)/float64(totalParts)),
                        zap.Float64("processingTimeSec", processingTimeSec),
                        zap.Float64("partsPerSecond", partsPerSecond),
                        zap.String("remainingStr", remainingStr))</span>

        }
        <span class="cov8" title="1">if allHaveCompleted </span><span class="cov0" title="0">{
                // this is a mess but object_replication_time (in old way) is # minutes
                // passed since 1 complete pass of all devices started.
                // replication_last is unix time stamp when last complete pass was finished
                // now "last pass" means oldest device lastPass
                maxLastPassComplete := time.Since(minLastPass).Minutes()
                middleware.DumpReconCache(r.reconCachePath, "object",
                        map[string]interface{}{
                                "object_replication_time": maxLastPassComplete,
                                "object_replication_last": float64(minLastPass.UnixNano()) / float64(time.Second),
                        })
        }</span>
}

func (r *Replicator) priorityReplicate(pri PriorityRepJob, timeout time.Duration) bool <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        rd, ok := r.runningDevices[deviceKey(pri.FromDevice, pri.Policy)]
        r.runningDevicesLock.Unlock()
        if ok </span><span class="cov8" title="1">{
                return rd.PriorityReplicate(pri, timeout)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (r *Replicator) getDeviceProgress() map[string]map[string]interface{} <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        deviceProgress := make(map[string]map[string]interface{})
        for key, device := range r.runningDevices </span><span class="cov8" title="1">{
                stats := device.Stats()
                deviceProgress[key] = map[string]interface{}{
                        "StartDate":          stats.DeviceStarted,
                        "LastUpdate":         stats.LastCheckin,
                        "LastPassDuration":   stats.LastPassDuration,
                        "LastPassFinishDate": stats.LastPassDate,
                        "LastPassUpdate":     stats.RunStarted,
                        "TotalPasses":        stats.TotalPasses,
                        "CancelCount":        r.cancelCounts[key],
                }
                for k, v := range stats.Stats </span><span class="cov8" title="1">{
                        deviceProgress[key][k] = v
                }</span>
        }
        <span class="cov8" title="1">return deviceProgress</span>
}

func (r *Replicator) runLoopCheck(reportTimer &lt;-chan time.Time) <span class="cov8" title="1">{
        select </span>{
        case update := &lt;-r.updateStat:<span class="cov8" title="1">
                r.runningDevicesLock.Lock()
                defer r.runningDevicesLock.Unlock()
                if rd, ok := r.runningDevices[update.deviceKey]; ok </span><span class="cov8" title="1">{
                        stats := rd.Stats()
                        stats.LastCheckin = time.Now()
                        switch update.stat </span>{
                        case "checkin":</span><span class="cov8" title="1">
                        case "startRun":<span class="cov8" title="1">
                                stats.RunStarted = time.Now()
                                for k := range stats.Stats </span><span class="cov8" title="1">{
                                        stats.Stats[k] = 0
                                }</span>
                        case "FullReplicateCount":<span class="cov8" title="1">
                                stats.LastPassDuration = time.Since(stats.RunStarted)
                                stats.LastPassDate = time.Now()
                                stats.TotalPasses++
                                stats.Stats["FullReplicateCount"] += update.value</span>
                        default:<span class="cov8" title="1">
                                stats.Stats[update.stat] += update.value</span>
                        }
                }
        case &lt;-reportTimer:<span class="cov0" title="0">
                r.cancelStalledDevices()
                r.verifyRunningDevices()
                r.reportStats()</span>
        case &lt;-r.onceDone:<span class="cov8" title="1">
                r.onceWaiting--</span>
        }
}

// Run replication passes in a loop until forever.
func (r *Replicator) RunForever() <span class="cov0" title="0">{
        go r.startWebServer()
        reportTimer := time.NewTimer(StatsReportInterval)
        r.verifyRunningDevices()
        for </span><span class="cov0" title="0">{
                r.runLoopCheck(reportTimer.C)
        }</span>
}

// Run a single replication pass. (NOTE: we will prob get rid of this because of priorityRepl)
func (r *Replicator) Run() <span class="cov8" title="1">{
        for policy, theRing := range r.Rings </span><span class="cov8" title="1">{
                devices, err := theRing.LocalDevices(r.port)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Error getting local devices from ring", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                        rd := newReplicationDevice(dev, policy, r)
                        key := rd.Key()
                        r.runningDevices[key] = rd
                        r.onceWaiting++
                        go func(rd *replicationDevice) </span><span class="cov8" title="1">{
                                rd.Replicate()
                                r.onceDone &lt;- struct{}{}
                        }</span>(rd)
                }
        }
        <span class="cov8" title="1">for r.onceWaiting &gt; 0 </span><span class="cov8" title="1">{
                r.runLoopCheck(make(chan time.Time))
        }</span>
        <span class="cov8" title="1">r.reportStats()</span>
}

func NewReplicator(serverconf conf.Config, flags *flag.FlagSet) (srv.Daemon, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        if !serverconf.HasSection("object-replicator") </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Unable to find object-replicator config section")
        }</span>
        <span class="cov8" title="1">concurrency := int(serverconf.GetInt("object-replicator", "concurrency", 1))

        logLevelString := serverconf.GetDefault("object-replicator", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))

        replicator := &amp;Replicator{
                runningDevices:   make(map[string]ReplicationDevice),
                cancelCounts:     make(map[string]int64),
                reserve:          serverconf.GetInt("object-replicator", "fallocate_reserve", 0),
                replicationMan:   NewReplicationManager(serverconf.GetLimit("object-replicator", "replication_limit", 3, 100)),
                replicateTimeout: time.Minute, // TODO(redbo): does this need to be configurable?
                reconCachePath:   serverconf.GetDefault("object-replicator", "recon_cache_path", "/var/cache/swift"),
                checkMounts:      serverconf.GetBool("object-replicator", "mount_check", true),
                deviceRoot:       serverconf.GetDefault("object-replicator", "devices", "/srv/node"),
                port:             int(serverconf.GetInt("object-replicator", "bind_port", 6500)),
                bindIp:           serverconf.GetDefault("object-replicator", "bind_ip", "0.0.0.0"),
                quorumDelete:     serverconf.GetBool("object-replicator", "quorum_delete", false),
                reclaimAge:       int64(serverconf.GetInt("object-replicator", "reclaim_age", int64(common.ONE_WEEK))),
                logLevel:         &amp;logLevel,
                Rings:            make(map[int]replicationRing),
                concurrency:      concurrency,
                concurrencySem:   make(chan struct{}, concurrency),
                updateStat:       make(chan statUpdate),
                devices:          make(map[string]bool),
                partitions:       make(map[string]bool),
                onceDone:         make(chan struct{}),
                loopSleepTime:    time.Second * 30,
                partSleepTime:    time.Duration(serverconf.GetInt("object-replicator", "ms_per_part", 100)) * time.Millisecond,
        }

        hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Unable to get hash prefix and suffix")
        }</span>
        <span class="cov8" title="1">for _, policy := range conf.LoadPolicies() </span><span class="cov8" title="1">{
                if policy.Type != "replication" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if replicator.Rings[policy.Index], err = GetRing("object", hashPathPrefix, hashPathSuffix, policy.Index); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("Unable to load ring for Policy %d.", policy.Index)
                }</span>
        }
        <span class="cov8" title="1">if replicator.logger, err = srv.SetupLogger("object-replicator", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">devices_flag := flags.Lookup("devices")
        if devices_flag != nil </span><span class="cov0" title="0">{
                if devices := devices_flag.Value.(flag.Getter).Get().(string); len(devices) &gt; 0 </span><span class="cov0" title="0">{
                        for _, devName := range strings.Split(devices, ",") </span><span class="cov0" title="0">{
                                replicator.devices[strings.TrimSpace(devName)] = true
                        }</span>
                }
        }
        <span class="cov8" title="1">partitions_flag := flags.Lookup("partitions")
        if partitions_flag != nil </span><span class="cov0" title="0">{
                if partitions := partitions_flag.Value.(flag.Getter).Get().(string); len(partitions) &gt; 0 </span><span class="cov0" title="0">{
                        for _, part := range strings.Split(partitions, ",") </span><span class="cov0" title="0">{
                                replicator.partitions[strings.TrimSpace(part)] = true
                        }</span>
                }
        }
        <span class="cov8" title="1">if !replicator.quorumDelete </span><span class="cov8" title="1">{
                quorumFlag := flags.Lookup("q")
                if quorumFlag != nil &amp;&amp; quorumFlag.Value.(flag.Getter).Get() == true </span><span class="cov8" title="1">{
                        replicator.quorumDelete = true
                }</span>
        }
        <span class="cov8" title="1">if serverconf.GetBool("object-replicator", "vm_test_mode", false) </span><span class="cov0" title="0">{ // slow down the replicator in saio mode
                replicator.partSleepTime = time.Duration(serverconf.GetInt("object-replicator", "ms_per_part", 500)) * time.Millisecond
        }</span>
        <span class="cov8" title="1">statsdHost := serverconf.GetDefault("object-replicator", "log_statsd_host", "")
        if statsdHost != "" </span><span class="cov0" title="0">{
                statsdPort := serverconf.GetInt("object-replicator", "log_statsd_port", 8125)
                // Go metrics collection pause interval in seconds
                statsdPause := serverconf.GetInt("object-replicator", "statsd_collection_pause", 10)
                basePrefix := serverconf.GetDefault("object-replicator", "log_statsd_metric_prefix", "")
                prefix := basePrefix + ".go.objectreplicator"
                go common.CollectRuntimeMetrics(statsdHost, statsdPort, statsdPause, prefix)
        }</span>
        <span class="cov8" title="1">return replicator, replicator.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bufio"
        "encoding/hex"
        "encoding/json"
        "io/ioutil"
        "net"
        "net/http"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/justinas/alice"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

// ReplicationManager is used by the object server to limit replication concurrency
type ReplicationManager struct {
        lock         sync.Mutex
        devSem       map[string]chan struct{}
        totalSem     chan struct{}
        limitPerDisk int64
        limitOverall int64
}

// Begin gives or rejects permission for a new replication session on the given device.
func (r *ReplicationManager) Begin(device string, timeout time.Duration) bool <span class="cov8" title="1">{
        r.lock.Lock()
        devSem, ok := r.devSem[device]
        if !ok </span><span class="cov8" title="1">{
                devSem = make(chan struct{}, r.limitPerDisk)
                r.devSem[device] = devSem
        }</span>
        <span class="cov8" title="1">r.lock.Unlock()
        timeoutTimer := time.NewTicker(timeout)
        defer timeoutTimer.Stop()
        loopTimer := time.NewTicker(time.Millisecond * 10)
        defer loopTimer.Stop()
        for </span><span class="cov8" title="1">{
                select </span>{
                case devSem &lt;- struct{}{}:<span class="cov8" title="1">
                        select </span>{
                        case r.totalSem &lt;- struct{}{}:<span class="cov8" title="1">
                                return true</span>
                        case &lt;-loopTimer.C:<span class="cov0" title="0">
                                &lt;-devSem</span>
                        }
                case &lt;-timeoutTimer.C:<span class="cov0" title="0">
                        return false</span>
                }
        }
}

// Done marks the session completed, removing it from any accounting.
func (r *ReplicationManager) Done(device string) <span class="cov8" title="1">{
        r.lock.Lock()
        &lt;-r.devSem[device]
        &lt;-r.totalSem
        r.lock.Unlock()
}</span>

func NewReplicationManager(limitPerDisk int64, limitOverall int64) *ReplicationManager <span class="cov8" title="1">{
        return &amp;ReplicationManager{
                limitPerDisk: limitPerDisk,
                limitOverall: limitOverall,
                devSem:       make(map[string]chan struct{}),
                totalSem:     make(chan struct{}, limitOverall),
        }
}</span>

// ProgressReportHandler handles HTTP requests for current replication progress
func (r *Replicator) ProgressReportHandler(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        data, err := json.Marshal(r.getDeviceProgress())
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error Marshaling device progress", zap.Error(err))
                w.WriteHeader(http.StatusInternalServerError)
                w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write(data)
        return</span>
}

// priorityRepHandler handles HTTP requests for priority replications jobs.
func (r *Replicator) priorityRepHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        var pri PriorityRepJob
        data, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(500)
                return
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(data, &amp;pri); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(400)
                return
        }</span>
        <span class="cov8" title="1">if r.checkMounts </span><span class="cov0" title="0">{
                if mounted, err := fs.IsMount(filepath.Join(r.deviceRoot, pri.FromDevice.Device)); err != nil || mounted == false </span><span class="cov0" title="0">{
                        w.WriteHeader(507)
                        return
                }</span>
        }
        <span class="cov8" title="1">if !fs.Exists(filepath.Join(r.deviceRoot, pri.FromDevice.Device, "objects", strconv.FormatUint(pri.Partition, 10))) </span><span class="cov8" title="1">{
                w.WriteHeader(404)
                return
        }</span>
        <span class="cov0" title="0">if r.priorityReplicate(pri, time.Hour) </span><span class="cov0" title="0">{
                w.WriteHeader(200)
        }</span><span class="cov0" title="0"> else {
                w.WriteHeader(500)
        }</span>
}

func (r *Replicator) objReplicateHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)

        var recalculate []string
        if len(vars["suffixes"]) &gt; 0 </span><span class="cov8" title="1">{
                recalculate = strings.Split(vars["suffixes"], "-")
        }</span>
        <span class="cov8" title="1">policy, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov0" title="0">{
                policy = 0
        }</span>
        <span class="cov8" title="1">hashes, err := GetHashes(r.deviceRoot, vars["device"], vars["partition"], recalculate, r.reclaimAge, policy, srv.GetLogger(request))
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get hashes",
                        zap.String("Device", vars["device"]),
                        zap.String("Partition", vars["partition"]))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(http.StatusOK)
        writer.Write(pickle.PickleDumps(hashes))</span>
}

func (r *Replicator) objRepConnHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        var conn net.Conn
        var rw *bufio.ReadWriter
        var err error
        var brr BeginReplicationRequest

        vars := srv.GetVars(request)

        policy, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov0" title="0">{
                policy = 0
        }</span>

        <span class="cov8" title="1">writer.WriteHeader(http.StatusOK)
        if hijacker, ok := writer.(http.Hijacker); !ok </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Writer not a Hijacker")
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span><span class="cov8" title="1"> else if conn, rw, err = hijacker.Hijack(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Hijack failed")
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        rc := NewIncomingRepConn(rw, conn)
        if err := rc.RecvMessage(&amp;brr); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Error receiving BeginReplicationRequest", zap.Error(err))
                writer.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if !r.replicationMan.Begin(brr.Device, r.replicateTimeout) </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Timed out waiting for concurrency slot")
                writer.WriteHeader(503)
                return
        }</span>
        <span class="cov8" title="1">defer r.replicationMan.Done(brr.Device)
        var hashes map[string]string
        if brr.NeedHashes </span><span class="cov8" title="1">{
                hashes, err = GetHashes(r.deviceRoot, brr.Device, brr.Partition, nil, r.reclaimAge, policy, srv.GetLogger(request))
                if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("[ObjRepConnHandler] Error getting hashes", zap.Error(err))
                        writer.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov8" title="1">if err := rc.SendMessage(BeginReplicationResponse{Hashes: hashes}); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Error sending BeginReplicationResponse", zap.Error(err))
                writer.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                errType, err := func() (string, error) </span><span class="cov8" title="1">{ // this is a closure so we can use defers inside
                        var sfr SyncFileRequest
                        if err := rc.RecvMessage(&amp;sfr); err != nil </span><span class="cov0" title="0">{
                                return "receiving SyncFileRequest", err
                        }</span>
                        <span class="cov8" title="1">if sfr.Done </span><span class="cov8" title="1">{
                                return "", replicationDone
                        }</span>
                        <span class="cov8" title="1">if sfr.Ping </span><span class="cov0" title="0">{
                                return "ping", rc.SendMessage(SyncFileResponse{Msg: "pong"})
                        }</span>
                        <span class="cov8" title="1">tempDir := TempDirPath(r.deviceRoot, vars["device"])
                        fileName := filepath.Join(r.deviceRoot, sfr.Path)
                        hashDir := filepath.Dir(fileName)

                        if ext := filepath.Ext(fileName); (ext != ".data" &amp;&amp; ext != ".ts" &amp;&amp; ext != ".meta") || len(filepath.Base(filepath.Dir(fileName))) != 32 </span><span class="cov0" title="0">{
                                return "invalid file path", rc.SendMessage(SyncFileResponse{Msg: "bad file path"})
                        }</span>
                        <span class="cov8" title="1">if fs.Exists(fileName) </span><span class="cov8" title="1">{
                                return "file exists", rc.SendMessage(SyncFileResponse{Exists: true, Msg: "exists"})
                        }</span>
                        <span class="cov8" title="1">dataFile, metaFile := ObjectFiles(hashDir)
                        if filepath.Base(fileName) &lt; filepath.Base(dataFile) || filepath.Base(fileName) &lt; filepath.Base(metaFile) </span><span class="cov8" title="1">{
                                return "newer file exists", rc.SendMessage(SyncFileResponse{NewerExists: true, Msg: "newer exists"})
                        }</span>
                        <span class="cov8" title="1">if sfr.Check </span><span class="cov0" title="0">{
                                return "just check", rc.SendMessage(SyncFileResponse{Exists: false, Msg: "doesn't exist"})
                        }</span>
                        <span class="cov8" title="1">tempFile, err := fs.NewAtomicFileWriter(tempDir, hashDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return "creating file writer", err
                        }</span>
                        <span class="cov8" title="1">defer tempFile.Abandon()
                        if err := tempFile.Preallocate(sfr.Size, r.reserve); err != nil </span><span class="cov0" title="0">{
                                return "preallocating space", err
                        }</span>
                        <span class="cov8" title="1">if xattrs, err := hex.DecodeString(sfr.Xattrs); err != nil || len(xattrs) == 0 </span><span class="cov0" title="0">{
                                return "parsing xattrs", rc.SendMessage(SyncFileResponse{Msg: "bad xattrs"})
                        }</span><span class="cov8" title="1"> else if err := RawWriteMetadata(tempFile.Fd(), xattrs); err != nil </span><span class="cov0" title="0">{
                                return "writing metadata", err
                        }</span>
                        <span class="cov8" title="1">if err := rc.SendMessage(SyncFileResponse{GoAhead: true, Msg: "go ahead"}); err != nil </span><span class="cov0" title="0">{
                                return "sending go ahead", err
                        }</span>
                        <span class="cov8" title="1">if _, err := common.CopyN(rc, sfr.Size, tempFile); err != nil </span><span class="cov0" title="0">{
                                return "copying data", err
                        }</span>
                        <span class="cov8" title="1">if err := tempFile.Save(fileName); err != nil </span><span class="cov0" title="0">{
                                return "saving file", err
                        }</span>
                        <span class="cov8" title="1">if dataFile != "" || metaFile != "" </span><span class="cov0" title="0">{
                                HashCleanupListDir(hashDir, r.reclaimAge)
                        }</span>
                        <span class="cov8" title="1">InvalidateHash(hashDir)
                        err = rc.SendMessage(FileUploadResponse{Success: true, Msg: "YAY"})
                        return "file done", err</span>
                }()
                <span class="cov8" title="1">if err == replicationDone </span><span class="cov8" title="1">{
                        return
                }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("[ObjRepConnHandler] Error replicating",
                                zap.String("errType", errType),
                                zap.Error(err))
                        writer.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
        }
}

func (r *Replicator) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                newWriter := &amp;srv.WebWriter{ResponseWriter: writer, Status: 500, ResponseStarted: false}
                start := time.Now()
                logr := r.logger.With(zap.String("txn", request.Header.Get("X-Trans-Id")))
                request = srv.SetLogger(request, logr)
                next.ServeHTTP(newWriter, request)
                lvl, _ := r.logLevel.MarshalText()
                if (request.Method != "REPLICATE" &amp;&amp; request.Method != "REPCONN") || strings.ToUpper(string(lvl)) == "DEBUG" </span><span class="cov0" title="0">{
                        logr.Info("Request log",
                                zap.String("remoteAddr", request.RemoteAddr),
                                zap.String("eventTime", time.Now().Format("02/Jan/2006:15:04:05 -0700")),
                                zap.String("method", request.Method),
                                zap.String("urlPath", common.Urlencode(request.URL.Path)),
                                zap.Int("status", newWriter.Status),
                                zap.String("contentLength", common.GetDefault(newWriter.Header(), "Content-Length", "-")),
                                zap.String("referer", common.GetDefault(request.Header, "Referer", "-")),
                                zap.String("userAgent", common.GetDefault(request.Header, "User-Agent", "-")),
                                zap.Float64("requestTimeSeconds", time.Since(start).Seconds()))
                }</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (r *Replicator) GetHandler() http.Handler <span class="cov8" title="1">{
        commonHandlers := alice.New(r.LogRequest, middleware.ValidateRequest)
        router := srv.NewRouter()
        router.Get("/priorityrep", commonHandlers.ThenFunc(r.priorityRepHandler))
        router.Get("/progress", commonHandlers.ThenFunc(r.ProgressReportHandler))
        for _, policy := range conf.LoadPolicies() </span><span class="cov8" title="1">{
                router.HandlePolicy("REPCONN", "/:device/:partition", policy.Index, commonHandlers.ThenFunc(r.objRepConnHandler))
                router.HandlePolicy("REPLICATE", "/:device/:partition/:suffixes", policy.Index, commonHandlers.ThenFunc(r.objReplicateHandler))
                router.HandlePolicy("REPLICATE", "/:device/:partition", policy.Index, commonHandlers.ThenFunc(r.objReplicateHandler))
        }</span>
        <span class="cov8" title="1">router.Get("/debug/*_", http.DefaultServeMux)
        return router</span>
}

func (r *Replicator) startWebServer() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if sock, err := srv.RetryListen(r.bindIp, r.port); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Listen failed", zap.Error(err))
                }</span><span class="cov0" title="0"> else {
                        http.Serve(sock, r.GetHandler())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "errors"
        "flag"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
)

// SwiftObject implements an Object that is compatible with Swift's object server.
type SwiftObject struct {
        file         *os.File
        afw          fs.AtomicFileWriter
        hashDir      string
        tempDir      string
        dataFile     string
        metaFile     string
        workingClass string
        metadata     map[string]string
        reserve      int64
        reclaimAge   int64
        asyncWG      *sync.WaitGroup // Used to keep track of async goroutines
}

// Metadata returns the object's metadata.
func (o *SwiftObject) Metadata() map[string]string <span class="cov8" title="1">{
        return o.metadata
}</span>

// ContentLength parses and returns the Content-Length for the object.
func (o *SwiftObject) ContentLength() int64 <span class="cov8" title="1">{
        if contentLength, err := strconv.ParseInt(o.metadata["Content-Length"], 10, 64); err != nil </span><span class="cov0" title="0">{
                return -1
        }</span><span class="cov8" title="1"> else {
                return contentLength
        }</span>
}

// Quarantine removes the object's underlying files to the Quarantined directory on the device.
func (o *SwiftObject) Quarantine() error <span class="cov8" title="1">{
        o.Close()
        if QuarantineHash(o.hashDir) == nil </span><span class="cov8" title="1">{
                return InvalidateHash(o.hashDir)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists returns true if the object exists, that is if it has a .data file.
func (o *SwiftObject) Exists() bool <span class="cov8" title="1">{
        return strings.HasSuffix(o.dataFile, ".data")
}</span>

// Copy copies all data from the underlying .data file to the given writers.
func (o *SwiftObject) Copy(dsts ...io.Writer) (written int64, err error) <span class="cov8" title="1">{
        if len(dsts) == 1 </span><span class="cov8" title="1">{
                return io.Copy(dsts[0], o.file)
        }</span><span class="cov8" title="1"> else {
                return common.Copy(o.file, dsts...)
        }</span>
}

// CopyRange copies data in the range of start to end from the underlying .data file to the writer.
func (o *SwiftObject) CopyRange(w io.Writer, start int64, end int64) (int64, error) <span class="cov8" title="1">{
        if _, err := o.file.Seek(start, os.SEEK_SET); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return common.CopyN(o.file, end-start, w)</span>
}

// Repr returns a string that identifies the object in some useful way, used for logging.
func (o *SwiftObject) Repr() string <span class="cov0" title="0">{
        if o.dataFile != "" &amp;&amp; o.metaFile != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("SwiftObject(%s, %s)", o.dataFile, o.metaFile)
        }</span><span class="cov0" title="0"> else if o.dataFile != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("SwiftObject(%s)", o.dataFile)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("SwiftObject(%s)", o.hashDir)</span>
}

func (o *SwiftObject) newFile(class string, size int64) (io.Writer, error) <span class="cov8" title="1">{
        var err error
        o.Close()
        if o.afw, err = fs.NewAtomicFileWriter(o.tempDir, o.hashDir); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error creating temp file: %v", err)
        }</span>
        <span class="cov8" title="1">if err := o.afw.Preallocate(size, o.reserve); err != nil </span><span class="cov0" title="0">{
                o.afw.Abandon()
                return nil, DriveFullError
        }</span>
        <span class="cov8" title="1">o.workingClass = class
        return o.afw, nil</span>
}

// SetData is called to set the object's data.  It takes a size (if available, otherwise set to zero).
func (o *SwiftObject) SetData(size int64) (io.Writer, error) <span class="cov8" title="1">{
        return o.newFile("data", size)
}</span>

// Commit commits an open data file to disk, given the metadata.
func (o *SwiftObject) Commit(metadata map[string]string) error <span class="cov8" title="1">{
        defer o.afw.Abandon()
        timestamp, ok := metadata["X-Timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("No timestamp in metadata")
        }</span>
        <span class="cov8" title="1">if err := WriteMetadata(o.afw.Fd(), metadata); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error writing metadata: %v", err)
        }</span>
        <span class="cov8" title="1">fileName := filepath.Join(o.hashDir, fmt.Sprintf("%s.%s", timestamp, o.workingClass))
        o.afw.Save(fileName)
        o.asyncWG.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer o.asyncWG.Done()
                HashCleanupListDir(o.hashDir, o.reclaimAge)
                if dir, err := os.OpenFile(o.hashDir, os.O_RDONLY, 0666); err == nil </span><span class="cov8" title="1">{
                        dir.Sync()
                        dir.Close()
                }</span>
                <span class="cov8" title="1">InvalidateHash(o.hashDir)</span>
        }()
        <span class="cov8" title="1">return nil</span>
}

func (o *SwiftObject) commitMeta(metadata map[string]string) error <span class="cov8" title="1">{
        if _, err := o.newFile("meta", 0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer o.Close()
        return o.Commit(metadata)</span>
}

// Delete deletes the object.
func (o *SwiftObject) Delete(metadata map[string]string) error <span class="cov8" title="1">{
        if _, err := o.newFile("ts", 0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span><span class="cov8" title="1"> else {
                defer o.Close()
                return o.Commit(metadata)
        }</span>
}

// Close releases any resources used by the instance of SwiftObject
func (o *SwiftObject) Close() error <span class="cov8" title="1">{
        if o.afw != nil </span><span class="cov8" title="1">{
                defer o.afw.Abandon()
                o.afw = nil
        }</span>
        <span class="cov8" title="1">if o.file != nil </span><span class="cov8" title="1">{
                defer o.file.Close()
                o.file = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type SwiftEngine struct {
        driveRoot      string
        hashPathPrefix string
        hashPathSuffix string
        reserve        int64
        reclaimAge     int64
        policy         int
}

// New returns an instance of SwiftObject with the given parameters. Metadata is read in and if needData is true, the file is opened.  AsyncWG is a waitgroup if the object spawns any async operations
func (f *SwiftEngine) New(vars map[string]string, needData bool, asyncWG *sync.WaitGroup) (Object, error) <span class="cov8" title="1">{
        var err error
        sor := &amp;SwiftObject{reclaimAge: f.reclaimAge, reserve: f.reserve, asyncWG: asyncWG}
        sor.hashDir = ObjHashDir(vars, f.driveRoot, f.hashPathPrefix, f.hashPathSuffix, f.policy)
        sor.tempDir = TempDirPath(f.driveRoot, vars["device"])
        sor.dataFile, sor.metaFile = ObjectFiles(sor.hashDir)
        if sor.Exists() </span><span class="cov8" title="1">{
                var stat os.FileInfo
                if needData </span><span class="cov8" title="1">{
                        if sor.file, err = os.Open(sor.dataFile); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if sor.metadata, err = OpenObjectMetadata(sor.file.Fd(), sor.metaFile); err != nil </span><span class="cov0" title="0">{
                                sor.Quarantine()
                                return nil, fmt.Errorf("Error getting metadata: %v", err)
                        }</span>
                }<span class="cov8" title="1"> else {
                        if sor.metadata, err = ObjectMetadata(sor.dataFile, sor.metaFile); err != nil </span><span class="cov0" title="0">{
                                sor.Quarantine()
                                return nil, fmt.Errorf("Error getting metadata: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">if sor.file != nil </span><span class="cov8" title="1">{
                        if stat, err = sor.file.Stat(); err != nil </span><span class="cov0" title="0">{
                                sor.Close()
                                return nil, fmt.Errorf("Error statting file: %v", err)
                        }</span>
                }<span class="cov8" title="1"> else if stat, err = os.Stat(sor.dataFile); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error statting file: %v", err)
                }</span>
                <span class="cov8" title="1">if contentLength, err := strconv.ParseInt(sor.metadata["Content-Length"], 10, 64); err != nil </span><span class="cov8" title="1">{
                        sor.Quarantine()
                        return nil, fmt.Errorf("Unable to parse content-length: %s", sor.metadata["Content-Length"])
                }</span><span class="cov8" title="1"> else if stat.Size() != contentLength </span><span class="cov8" title="1">{
                        sor.Quarantine()
                        return nil, fmt.Errorf("File size doesn't match content-length: %d vs %d", stat.Size(), contentLength)
                }</span>
        }
        <span class="cov8" title="1">return sor, nil</span>
}

var replicationDone = fmt.Errorf("Replication done")

// SwiftEngineConstructor creates a SwiftEngine given the object server configs.
func SwiftEngineConstructor(config conf.Config, policy *conf.Policy, flags *flag.FlagSet) (ObjectEngine, error) <span class="cov8" title="1">{
        driveRoot := config.GetDefault("app:object-server", "devices", "/srv/node")
        reserve := config.GetInt("app:object-server", "fallocate_reserve", 0)
        hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Unable to load hashpath prefix and suffix")
        }</span>
        <span class="cov8" title="1">reclaimAge := int64(config.GetInt("app:object-server", "reclaim_age", int64(common.ONE_WEEK)))
        return &amp;SwiftEngine{
                driveRoot:      driveRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                reserve:        reserve,
                reclaimAge:     reclaimAge,
                policy:         policy.Index}, nil</span>
}

func init() <span class="cov8" title="1">{
        RegisterObjectEngine("replication", SwiftEngineConstructor)
}</span>

// make sure these things satisfy interfaces at compile time
var _ ObjectEngineConstructor = SwiftEngineConstructor
var _ Object = &amp;SwiftObject{}
var _ ObjectEngine = &amp;SwiftEngine{}
</pre>
		
		<pre class="file" id="file53" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "crypto/md5"
        "encoding/hex"
        "fmt"
        "io"
        "math/big"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

/*This hash is used to represent a zero byte async file that is
  created for an expiring object*/
const zeroByteHash = "d41d8cd98f00b204e9800998ecf8427e"
const deleteAtAccount = ".expiring_objects"

func headerToMap(headers http.Header) map[string]string <span class="cov8" title="1">{
        ret := make(map[string]string)
        for key, value := range headers </span><span class="cov8" title="1">{
                if len(value) &gt; 0 </span><span class="cov8" title="1">{
                        ret[key] = headers.Get(key)
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func splitHeader(header string) []string <span class="cov8" title="1">{
        if header == "" </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return strings.Split(header, ",")</span>
}

func (server *ObjectServer) hashPath(account, container, obj string) string <span class="cov8" title="1">{
        h := md5.New()
        io.WriteString(h, server.hashPathPrefix+"/"+account+"/"+container+"/"+obj+server.hashPathSuffix)
        return hex.EncodeToString(h.Sum(nil))
}</span>

func (server *ObjectServer) expirerContainer(deleteAt time.Time, account, container, obj string) string <span class="cov8" title="1">{
        i := new(big.Int)
        fmt.Sscanf(server.hashPath(account, container, obj), "%x", i)
        shardInt := i.Mod(i, big.NewInt(100)).Int64()
        timestamp := (deleteAt.Unix()/server.expiringDivisor)*server.expiringDivisor - shardInt
        if timestamp &lt; 0 </span><span class="cov0" title="0">{
                timestamp = 0
        }</span><span class="cov8" title="1"> else if timestamp &gt; 9999999999 </span><span class="cov0" title="0">{
                timestamp = 9999999999
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%010d", timestamp)</span>
}

func (server *ObjectServer) sendContainerUpdate(host, device, method, partition, account, container, obj string, headers http.Header) bool <span class="cov8" title="1">{
        obj_url := fmt.Sprintf("http://%s/%s/%s/%s/%s/%s", host, device, partition,
                common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj))
        if req, err := http.NewRequest(method, obj_url, nil); err == nil </span><span class="cov8" title="1">{
                req.Header = headers
                if resp, err := server.updateClient.Do(req); err == nil </span><span class="cov8" title="1">{
                        resp.Body.Close()
                        if resp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (server *ObjectServer) saveAsync(method, account, container, obj, localDevice string, headers http.Header) <span class="cov8" title="1">{
        hash := server.hashPath(account, container, obj)
        asyncFile := filepath.Join(server.driveRoot, localDevice, "async_pending", hash[29:32], hash+"-"+headers.Get("X-Timestamp"))
        tempDir := TempDirPath(server.driveRoot, localDevice)
        data := map[string]interface{}{
                "op":        method,
                "account":   account,
                "container": container,
                "obj":       obj,
                "headers":   headerToMap(headers),
        }
        if os.MkdirAll(filepath.Dir(asyncFile), 0755) == nil </span><span class="cov8" title="1">{
                writer, err := fs.NewAtomicFileWriter(tempDir, filepath.Dir(asyncFile))
                if err == nil </span><span class="cov8" title="1">{
                        defer writer.Abandon()
                        writer.Write(pickle.PickleDumps(data))
                        writer.Save(asyncFile)
                }</span>
        }
}

func (server *ObjectServer) updateContainer(metadata map[string]string, request *http.Request, vars map[string]string, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        partition := request.Header.Get("X-Container-Partition")
        hosts := splitHeader(request.Header.Get("X-Container-Host"))
        devices := splitHeader(request.Header.Get("X-Container-Device"))
        if partition == "" || len(hosts) == 0 || len(devices) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">requestHeaders := http.Header{
                "X-Backend-Storage-Policy-Index": {common.GetDefault(request.Header, "X-Backend-Storage-Policy-Index", "0")},
                "Referer":                        {common.GetDefault(request.Header, "Referer", "-")},
                "User-Agent":                     {common.GetDefault(request.Header, "User-Agent", "-")},
                "X-Trans-Id":                     {common.GetDefault(request.Header, "X-Trans-Id", "-")},
                "X-Timestamp":                    {request.Header.Get("X-Timestamp")},
        }
        if request.Method != "DELETE" </span><span class="cov8" title="1">{
                requestHeaders.Add("X-Content-Type", metadata["Content-Type"])
                requestHeaders.Add("X-Size", metadata["Content-Length"])
                requestHeaders.Add("X-Etag", metadata["ETag"])
        }</span>
        <span class="cov8" title="1">failures := 0
        for index := range hosts </span><span class="cov8" title="1">{
                if !server.sendContainerUpdate(hosts[index], devices[index], request.Method, partition, vars["account"], vars["container"], vars["obj"], requestHeaders) </span><span class="cov8" title="1">{
                        logger.Error("ERROR container update failed (saving for async update later)",
                                zap.String("Host", hosts[index]),
                                zap.String("Device", devices[index]))
                        failures++
                }</span>
        }
        <span class="cov8" title="1">if failures &gt; 0 </span><span class="cov8" title="1">{
                server.saveAsync(request.Method, vars["account"], vars["container"], vars["obj"], vars["device"], requestHeaders)
        }</span>
}

func (server *ObjectServer) updateDeleteAt(method string, header http.Header, deleteAtTime time.Time, vars map[string]string, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        container := common.GetDefault(header, "X-Delete-At-Container", "")
        if container == "" </span><span class="cov8" title="1">{
                container = server.expirerContainer(deleteAtTime, vars["account"], vars["container"], vars["obj"])
        }</span>
        <span class="cov8" title="1">obj := fmt.Sprintf("%010d-%s/%s/%s", deleteAtTime.Unix(), vars["account"], vars["container"], vars["obj"])
        partition := common.GetDefault(header, "X-Delete-At-Partition", "")
        hosts := splitHeader(header.Get("X-Delete-At-Host"))
        devices := splitHeader(header.Get("X-Delete-At-Device"))
        requestHeaders := http.Header{
                "X-Backend-Storage-Policy-Index": {common.GetDefault(header, "X-Backend-Storage-Policy-Index", "0")},
                "Referer":                        {common.GetDefault(header, "Referer", "-")},
                "User-Agent":                     {common.GetDefault(header, "User-Agent", "-")},
                "X-Trans-Id":                     {common.GetDefault(header, "X-Trans-Id", "-")},
                "X-Timestamp":                    {header.Get("X-Timestamp")},
        }
        if method != "DELETE" </span><span class="cov8" title="1">{
                requestHeaders.Add("X-Content-Type", "text/plain")
                requestHeaders.Add("X-Size", "0")
                requestHeaders.Add("X-Etag", zeroByteHash)
        }</span>
        <span class="cov8" title="1">failures := 0
        for index := range hosts </span><span class="cov8" title="1">{
                if !server.sendContainerUpdate(hosts[index], devices[index], method, partition, deleteAtAccount, container, obj, requestHeaders) </span><span class="cov8" title="1">{
                        logger.Error("ERROR container update failed with (saving for async update later)",
                                zap.String("Host", hosts[index]),
                                zap.String("Device", devices[index]))
                        failures++
                }</span>
        }
        <span class="cov8" title="1">if failures &gt; 0 || len(hosts) == 0 </span><span class="cov8" title="1">{
                server.saveAsync(method, deleteAtAccount, container, obj, vars["device"], requestHeaders)
        }</span>
}

func (server *ObjectServer) containerUpdates(writer http.ResponseWriter, request *http.Request, metadata map[string]string, deleteAt string, vars map[string]string, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        defer middleware.Recover(writer, request, "PANIC WHILE UPDATING CONTAINER LISTINGS")
        if deleteAtTime, err := common.ParseDate(deleteAt); err != nil </span><span class="cov8" title="1">{
                go server.updateDeleteAt(request.Method, request.Header, deleteAtTime, vars, logger)
        }</span>

        <span class="cov8" title="1">firstDone := make(chan struct{}, 1)
        go func() </span><span class="cov8" title="1">{
                server.updateContainer(metadata, request, vars, logger)
                firstDone &lt;- struct{}{}
        }</span>()
        <span class="cov8" title="1">select </span>{
        case &lt;-firstDone:</span><span class="cov8" title="1">
        case &lt;-time.After(server.updateTimeout):</span><span class="cov0" title="0">
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package probe

import (
        "bytes"
        "flag"
        "fmt"
        "io/ioutil"
        "log"
        "net"
        "net/http"
        "net/http/httptest"
        "net/url"
        "os"
        "path/filepath"
        "strconv"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/test"
        "github.com/troubling/hummingbird/objectserver"
)

type TestReplicatorWebServer struct {
        *httptest.Server
        host       string
        port       int
        root       string
        replicator *objectserver.Replicator
}

func (t *TestReplicatorWebServer) Close() <span class="cov8" title="1">{
        os.RemoveAll(t.root)
        t.Server.Close()
}</span>

// Environment encapsulates a temporary SAIO-style environment for the object server, replicator, and auditor
// and provides a few utility functions for manipulating it.
type Environment struct {
        driveRoots             []string
        servers                []*httptest.Server
        ports                  []int
        hosts                  []string
        replicatorServers      []*TestReplicatorWebServer
        auditors               []*objectserver.AuditorDaemon
        ring                   ring.Ring
        hashPrefix, hashSuffix string
}

// Close frees any resources associated with the Environment.
func (e *Environment) Close() <span class="cov8" title="1">{
        for _, s := range e.servers </span><span class="cov8" title="1">{
                s.Close()
        }</span>
        <span class="cov8" title="1">for _, s := range e.replicatorServers </span><span class="cov8" title="1">{
                s.Close()
        }</span>
        <span class="cov8" title="1">for _, s := range e.driveRoots </span><span class="cov8" title="1">{
                os.RemoveAll(s)
        }</span>
}

// FileLocations returns a list of file paths for the object's hash directory on all three underlying object servers.
func (e *Environment) FileLocations(account, container, obj string, policy int) (paths []string) <span class="cov8" title="1">{
        partition := e.ring.GetPartition(account, container, obj)
        vars := map[string]string{"account": account, "container": container, "obj": obj, "partition": strconv.Itoa(int(partition)), "device": "sda"}
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                path := objectserver.ObjHashDir(vars, e.driveRoots[i], e.hashPrefix, e.hashSuffix, policy)
                paths = append(paths, path)
        }</span>
        <span class="cov8" title="1">return</span>
}

// PutObject uploads an object "/a/c/o" to the indicated server with X-Timestamp set to timestamp and body set to data.
func (e *Environment) PutObject(server int, timestamp string, data string, policy int) bool <span class="cov8" title="1">{
        body := bytes.NewBuffer([]byte(data))
        req, err := http.NewRequest("PUT", fmt.Sprintf("http://%s:%d/sda/0/a/c/o", e.hosts[server], e.ports[server]), body)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/octet-stream")
        req.Header.Set("Content-Length", strconv.Itoa(len(data)))
        req.Header.Set("X-Timestamp", timestamp)
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        resp, err := http.DefaultClient.Do(req)
        return err == nil &amp;&amp; resp.StatusCode == 201</span>
}

// DeleteObject deletes the object.
func (e *Environment) DeleteObject(server int, timestamp string, policy int) bool <span class="cov8" title="1">{
        req, err := http.NewRequest("DELETE", fmt.Sprintf("http://%s:%d/sda/0/a/c/o", e.hosts[server], e.ports[server]), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Timestamp", timestamp)
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        resp, err := http.DefaultClient.Do(req)
        return err == nil &amp;&amp; resp.StatusCode == 204</span>
}

// ObjExists returns a boolean indicating that it can fetch the named object and that its X-Timestamp matches the timestamp argument.
func (e *Environment) ObjExists(server int, timestamp string, policy int) bool <span class="cov8" title="1">{
        req, err := http.NewRequest("HEAD", fmt.Sprintf("http://%s:%d/sda/0/a/c/o", e.hosts[server], e.ports[server]), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        resp, err := http.DefaultClient.Do(req)
        if err != nil || resp.StatusCode != 200 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return resp.Header.Get("X-Timestamp") == timestamp</span>
}

// NewEnvironment creates a new environment.  Arguments should be a series of key, value pairs that are added to the object server configuration file.
func NewEnvironment(settings ...string) *Environment <span class="cov8" title="1">{
        oldGetRing := objectserver.GetRing
        defer func() </span><span class="cov8" title="1">{
                objectserver.GetRing = oldGetRing
        }</span>()

        <span class="cov8" title="1">testRing := &amp;test.FakeRing{}
        objectserver.GetRing = func(ringType, prefix, suffix string, policy int) (ring.Ring, error) </span><span class="cov8" title="1">{
                return testRing, nil
        }</span>
        <span class="cov8" title="1">log.SetFlags(log.LstdFlags | log.Lshortfile)
        oldLoadPolicies := conf.LoadPolicies
        conf.LoadPolicies = func() conf.PolicyList </span><span class="cov8" title="1">{
                return conf.PolicyList(map[int]*conf.Policy{
                        0: {
                                Index:      0,
                                Type:       "replication",
                                Name:       "Policy-0",
                                Aliases:    nil,
                                Default:    false,
                                Deprecated: false,
                        },
                        1: {
                                Index:      1,
                                Type:       "replication",
                                Name:       "Policy-1",
                                Aliases:    nil,
                                Default:    false,
                                Deprecated: false,
                        },
                })
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                conf.LoadPolicies = oldLoadPolicies
        }</span>()
        <span class="cov8" title="1">env := &amp;Environment{ring: testRing}
        env.hashPrefix, env.hashSuffix, _ = conf.GetHashPrefixAndSuffix()
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                driveRoot, _ := ioutil.TempDir("", "")
                os.MkdirAll(filepath.Join(driveRoot, "sda", "objects"), 0755)
                ts := httptest.NewServer(nil)
                u, _ := url.Parse(ts.URL)
                host, ports, _ := net.SplitHostPort(u.Host)
                port, _ := strconv.Atoi(ports)

                trs := httptest.NewServer(nil)
                trsURL, _ := url.Parse(trs.URL)
                trsHost, trsPorts, _ := net.SplitHostPort(trsURL.Host)
                trsPort, _ := strconv.Atoi(trsPorts)

                configString := "[DEFAULT]\nmount_check=false\n"
                configString += fmt.Sprintf("devices=%s\n", driveRoot)
                configString += fmt.Sprintf("bind_port=%d\n", port)
                configString += fmt.Sprintf("bind_ip=%s\n", host)
                for i := 0; i &lt; len(settings); i += 2 </span><span class="cov0" title="0">{
                        configString += fmt.Sprintf("%s=%s\n", settings[i], settings[i+1])
                }</span>
                <span class="cov8" title="1">configString += "[app:object-server]\n[object-replicator]\n"
                configString += fmt.Sprintf("bind_port=%d\n", trsPort)
                configString += fmt.Sprintf("bind_ip=%s\n", trsHost)
                configString += "[object-auditor]\n"
                conf, _ := conf.StringConfig(configString)
                _, _, server, _, err := objectserver.GetServer(conf, &amp;flag.FlagSet{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov8" title="1">ts.Config.Handler = server.GetHandler(conf)

                replicator, _, err := objectserver.NewReplicator(conf, &amp;flag.FlagSet{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov8" title="1">replicator.(*objectserver.Replicator).Rings[0] = env.ring
                replicator.(*objectserver.Replicator).Rings[1] = env.ring
                trs.Config.Handler = replicator.(*objectserver.Replicator).GetHandler()

                replicatorServer := &amp;TestReplicatorWebServer{Server: trs, host: host, port: port, root: driveRoot, replicator: replicator.(*objectserver.Replicator)}
                auditor, _, err := objectserver.NewAuditor(conf, &amp;flag.FlagSet{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov8" title="1">env.ring.(*test.FakeRing).MockDevices = append(env.ring.(*test.FakeRing).MockDevices, &amp;ring.Device{
                        Id: i, Device: "sda", Ip: host, Port: port, Region: 0, ReplicationIp: trsHost, ReplicationPort: trsPort, Weight: 1, Zone: i,
                })

                env.driveRoots = append(env.driveRoots, driveRoot)
                env.servers = append(env.servers, ts)
                env.ports = append(env.ports, port)
                env.hosts = append(env.hosts, host)
                env.replicatorServers = append(env.replicatorServers, replicatorServer)
                env.auditors = append(env.auditors, auditor.(*objectserver.AuditorDaemon))</span>
        }
        <span class="cov8" title="1">env.ring.(*test.FakeRing).MockMoreNodes = env.ring.(*test.FakeRing).MockDevices[3]
        return env</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "fmt"
        "net/http"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"
)

func (server *ProxyServer) AccountGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">options := make(map[string]string)
        if request.ParseForm() == nil </span><span class="cov0" title="0">{
                for k, v := range request.Form </span><span class="cov0" title="0">{
                        if listingQueryParms[k] &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                                options[k] = v[0]
                        }</span>
                }
        }
        <span class="cov0" title="0">resp := ctx.C.GetAccount(vars["account"], options, request.Header)
        if resp.StatusCode == http.StatusNotFound &amp;&amp; server.accountAutoCreate </span><span class="cov0" title="0">{
                resp.Body.Close()
                ctx.AutoCreateAccount(vars["account"], request.Header)
                resp = ctx.C.GetAccount(vars["account"], options, request.Header)
        }</span>
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)
        defer resp.Body.Close()
        common.Copy(resp.Body, writer)</span>
}

func (server *ProxyServer) AccountHeadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.HeadAccount(vars["account"], request.Header)
        if resp.StatusCode == http.StatusNotFound &amp;&amp; server.accountAutoCreate </span><span class="cov0" title="0">{
                resp.Body.Close()
                ctx.AutoCreateAccount(vars["account"], request.Header)
                resp = ctx.C.HeadAccount(vars["account"], request.Header)
        }</span>
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        writer.WriteHeader(resp.StatusCode)</span>
}

func (server *ProxyServer) AccountPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if status, str := CheckMetadata(request, "Account"); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">defer ctx.InvalidateAccountInfo(vars["account"])
        resp := ctx.C.PostAccount(vars["account"], request.Header)
        if resp.StatusCode == http.StatusNotFound &amp;&amp; server.accountAutoCreate </span><span class="cov0" title="0">{
                resp.Body.Close()
                ctx.AutoCreateAccount(vars["account"], request.Header)
                resp = ctx.C.PostAccount(vars["account"], request.Header)
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) AccountPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if status, str := CheckMetadata(request, "Account"); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">defer ctx.InvalidateAccountInfo(vars["account"])
        resp := ctx.C.PutAccount(vars["account"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) AccountDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">defer ctx.InvalidateAccountInfo(vars["account"])
        resp := ctx.C.DeleteAccount(vars["account"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
)

const (
        MAX_FILE_SIZE             = int64(5368709122)
        MAX_META_NAME_LENGTH      = 128
        MAX_META_VALUE_LENGTH     = 256
        MAX_META_COUNT            = 90
        MAX_META_OVERALL_SIZE     = 4096
        MAX_HEADER_SIZE           = 8192
        MAX_OBJECT_NAME_LENGTH    = 1024
        CONTAINER_LISTING_LIMIT   = 10000
        ACCOUNT_LISTING_LIMIT     = 10000
        MAX_ACCOUNT_NAME_LENGTH   = 256
        MAX_CONTAINER_NAME_LENGTH = 256
        EXTRA_HEADER_COUNT        = 0
)

var DEFAULT_CONSTRAINTS = map[string]interface{}{
        "max_file_size":             MAX_FILE_SIZE,
        "max_meta_name_length":      MAX_META_NAME_LENGTH,
        "max_meta_value_length":     MAX_META_VALUE_LENGTH,
        "max_meta_count":            MAX_META_COUNT,
        "max_meta_overall_size":     MAX_META_OVERALL_SIZE,
        "max_header_size":           MAX_HEADER_SIZE,
        "max_object_name_length":    MAX_OBJECT_NAME_LENGTH,
        "container_listing_limit":   CONTAINER_LISTING_LIMIT,
        "account_listing_limit":     ACCOUNT_LISTING_LIMIT,
        "max_account_name_length":   MAX_ACCOUNT_NAME_LENGTH,
        "max_container_name_length": MAX_CONTAINER_NAME_LENGTH,
        "extra_header_count":        EXTRA_HEADER_COUNT,
}

func CheckMetadata(req *http.Request, targetType string) (int, string) <span class="cov8" title="1">{
        metaCount := 0
        metaSize := 0
        metaPrefix := fmt.Sprintf("X-%s-Meta-", targetType)
        for key := range req.Header </span><span class="cov8" title="1">{
                value := req.Header.Get(key)
                if len(value) &gt; MAX_HEADER_SIZE </span><span class="cov8" title="1">{
                        errStr := fmt.Sprintf("Header value too long: %s", key)
                        if len(key) &gt; MAX_META_NAME_LENGTH </span><span class="cov0" title="0">{
                                errStr = fmt.Sprintf("Header value too long: %s", key[:MAX_META_NAME_LENGTH])
                        }</span>
                        <span class="cov8" title="1">return http.StatusBadRequest, errStr</span>
                }
                <span class="cov8" title="1">if !strings.HasPrefix(key, metaPrefix) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">key = key[len(metaPrefix):]
                metaCount += 1
                metaSize += len(key) + len(value)
                if key == "" </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "Metadata name cannot be empty"
                }</span>
                <span class="cov8" title="1">if common.StringInSlice(targetType, []string{"Account", "Container"}) &amp;&amp; (strings.Contains(key, "\x00") || strings.Contains(value, "\x00")) </span><span class="cov0" title="0">{
                        return http.StatusBadRequest, "Metadata must be valid UTF-8"
                }</span>
                <span class="cov8" title="1">if len(key) &gt; MAX_META_NAME_LENGTH </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Metadata name too long: %s%s", metaPrefix, key)
                }</span>
                <span class="cov8" title="1">if len(value) &gt; MAX_META_VALUE_LENGTH </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Metadata value longer than %d: %s%s", MAX_META_VALUE_LENGTH, metaPrefix, key)
                }</span>
                <span class="cov8" title="1">if metaCount &gt; MAX_META_COUNT </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Too many metadata items; max %d", MAX_META_COUNT)
                }</span>
                <span class="cov8" title="1">if metaSize &gt; MAX_META_OVERALL_SIZE </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Total metadata too large; max %d", MAX_META_OVERALL_SIZE)
                }</span>
        }
        <span class="cov8" title="1">return http.StatusOK, ""</span>
}

func CheckObjPut(req *http.Request, objectName string) (int, string) <span class="cov8" title="1">{
        if req.ContentLength &gt; MAX_FILE_SIZE </span><span class="cov8" title="1">{
                return http.StatusRequestEntityTooLarge, "Your request is too large."
        }</span>
        <span class="cov8" title="1">if req.Header.Get("X-Copy-From") != "" &amp;&amp; req.ContentLength != 0 </span><span class="cov8" title="1">{
                return http.StatusBadRequest, "Copy requests require a zero byte body"
        }</span>
        <span class="cov8" title="1">if req.Header.Get("Content-Length") == "" &amp;&amp; !common.StringInSlice("chunked", req.TransferEncoding) </span><span class="cov8" title="1">{
                return http.StatusLengthRequired, "Missing Content-Length header."
        }</span>
        <span class="cov8" title="1">if len(objectName) &gt; MAX_OBJECT_NAME_LENGTH </span><span class="cov8" title="1">{
                return http.StatusBadRequest, fmt.Sprintf("Object name length of %d longer than %d", len(objectName), MAX_OBJECT_NAME_LENGTH)
        }</span>
        <span class="cov8" title="1">if req.Header.Get("Content-Type") == "" </span><span class="cov8" title="1">{
                return http.StatusBadRequest, "No content type"
        }</span>

        <span class="cov8" title="1">if xda := req.Header.Get("X-Delete-At"); xda != "" </span><span class="cov8" title="1">{
                if deleteAfter, err := strconv.ParseInt(xda, 10, 64); err != nil </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "Non-integer X-Delete-At"
                }</span><span class="cov8" title="1"> else if deleteAfter &lt; time.Now().Unix() </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "X-Delete-At in past"
                }</span>
        }<span class="cov8" title="1"> else if xda := req.Header.Get("X-Delete-After"); xda != "" </span><span class="cov8" title="1">{
                if deleteAfter, err := strconv.ParseInt(xda, 10, 64); err != nil </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "Non-integer X-Delete-After"
                }</span><span class="cov8" title="1"> else if deleteAfter &lt; 0 </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "X-Delete-After in past"
                }</span><span class="cov8" title="1"> else {
                        req.Header.Set("X-Delete-At", strconv.FormatInt(time.Now().Unix()+deleteAfter, 10))
                }</span>
        }
        <span class="cov8" title="1">if strings.Contains(req.Header.Get("Content-Type"), "\x00") </span><span class="cov0" title="0">{
                return http.StatusBadRequest, "Invalid Content-Type"
        }</span>
        <span class="cov8" title="1">return CheckMetadata(req, "Object")</span>
}

func CheckContainerPut(req *http.Request, containerName string) (int, string) <span class="cov8" title="1">{
        if len(containerName) &gt; MAX_CONTAINER_NAME_LENGTH </span><span class="cov8" title="1">{
                return http.StatusBadRequest, fmt.Sprintf("Container name length of %d longer than %d", len(containerName), MAX_CONTAINER_NAME_LENGTH)
        }</span>
        <span class="cov0" title="0">return CheckMetadata(req, "Container")</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"
)

var listingQueryParms = map[string]bool{
        "format":     true,
        "limit":      true,
        "marker":     true,
        "end_marker": true,
        "prefix":     true,
        "delimiter":  true,
        "reverse":    true,
        "path":       true,
}

func (server *ProxyServer) ContainerGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">options := make(map[string]string)
        if request.ParseForm() == nil </span><span class="cov0" title="0">{
                for k, v := range request.Form </span><span class="cov0" title="0">{
                        if listingQueryParms[k] &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                                options[k] = v[0]
                        }</span>
                }
        }
        <span class="cov0" title="0">resp := ctx.C.GetContainer(vars["account"], vars["container"], options, request.Header)
        defer resp.Body.Close()
        ctx.ACL = resp.Header.Get("X-Container-Read")
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)
        common.Copy(resp.Body, writer)</span>
}

func (server *ProxyServer) ContainerHeadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">resp := ctx.C.HeadContainer(vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        ctx.ACL = resp.Header.Get("X-Container-Read")
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)</span>
}

func (server *ProxyServer) ContainerPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">if err := cleanACLs(request); err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if status, str := CheckContainerPut(request, vars["container"]); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">resp := ctx.C.PostContainer(vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ContainerPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if err := cleanACLs(request); err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">_, err := ctx.GetAccountInfo(vars["account"])
        if err != nil </span><span class="cov0" title="0">{
                if server.accountAutoCreate </span><span class="cov0" title="0">{
                        ctx.AutoCreateAccount(vars["account"], request.Header)
                        _, err = ctx.GetAccountInfo(vars["account"])
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">if status, str := CheckContainerPut(request, vars["container"]); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">resp := ctx.C.PutContainer(vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ContainerDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.DeleteContainer(vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func cleanACLs(r *http.Request) error <span class="cov0" title="0">{
        for _, header := range []string{"X-Container-Read", "X-Container-Write"} </span><span class="cov0" title="0">{
                if r.Header.Get(header) != "" </span><span class="cov0" title="0">{
                        cleanedValue, err := middleware.CleanACL(header, r.Header.Get(header))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">r.Header.Set(header, cleanedValue)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func setVary(writer http.ResponseWriter, h string) <span class="cov8" title="1">{
        if v := writer.Header().Get("Vary"); v != "" </span><span class="cov8" title="1">{
                writer.Header().Set("Vary", fmt.Sprintf("%s, %s", v, h))
        }</span><span class="cov8" title="1"> else {
                writer.Header().Set("Vary", h)
        }</span>
}

var publicMethods = []string{"HEAD", "GET", "PUT", "POST", "OPTIONS", "DELETE", "COPY"}

func (server *ProxyServer) OptionsHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        origin := request.Header.Get("Origin")
        methodString := strings.Join(publicMethods, ", ")
        if origin == "" || vars["container"] == "" </span><span class="cov8" title="1">{
                writer.Header().Set("Allow", methodString)
                srv.StandardResponse(writer, 200)
                return
        }</span>
        <span class="cov8" title="1">if rqm := request.Header.Get("Access-Control-Request-Method"); rqm == "" </span><span class="cov8" title="1">{
                srv.SimpleErrorResponse(writer, 401, "")
                return
        }</span><span class="cov8" title="1"> else {
                found := false
                for _, method := range publicMethods </span><span class="cov8" title="1">{
                        if rqm == method </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        srv.SimpleErrorResponse(writer, 401, "")
                        return
                }</span>
        }
        <span class="cov8" title="1">if ci, err := ctx.C.GetContainerInfo(vars["account"], vars["container"]); err == nil </span><span class="cov8" title="1">{
                if common.IsOriginAllowed(ci.Metadata["Access-Control-Allow-Origin"], origin) </span><span class="cov8" title="1">{
                        writer.Header().Set("Allow", methodString)
                        if ci.Metadata["Access-Control-Allow-Origin"] == "*" </span><span class="cov8" title="1">{
                                writer.Header().Set("Access-Control-Allow-Origin", "*")
                        }</span><span class="cov8" title="1"> else {
                                writer.Header().Set("Access-Control-Allow-Origin", origin)
                                setVary(writer, "Origin")
                        }</span>
                        <span class="cov8" title="1">if ma := ci.Metadata["Access-Control-Max-Age"]; ma != "" </span><span class="cov0" title="0">{
                                writer.Header().Set("Access-Control-Max-Age", ma)
                        }</span>
                        <span class="cov8" title="1">if rh := request.Header.Get("Access-Control-Request-Headers"); rh != "" </span><span class="cov0" title="0">{
                                writer.Header().Set("Access-Control-Allow-Headers", rh)
                                setVary(writer, "Access-Control-Request-Headers")
                        }</span>
                        <span class="cov8" title="1">srv.StandardResponse(writer, 200)
                        return</span>
                }
        }
        <span class="cov8" title="1">srv.SimpleErrorResponse(writer, 401, "")
        return</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "flag"
        "fmt"
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"

        "github.com/justinas/alice"
        "go.uber.org/zap"
)

type ProxyServer struct {
        logger            srv.LowLevelLogger
        logLevel          zap.AtomicLevel
        mc                ring.MemcacheRing
        accountAutoCreate bool
        proxyDirectClient *client.ProxyDirectClient
}

func (server *ProxyServer) Finalize() <span class="cov0" title="0">{
}</span>

func (server *ProxyServer) GetHandler(config conf.Config) http.Handler <span class="cov0" title="0">{
        router := srv.NewRouter()
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectGetHandler))
        router.Head("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectHeadHandler))
        router.Put("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectPutHandler))
        router.Delete("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectDeleteHandler))
        router.Post("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectPostHandler))
        router.Options("/v1/:account/:container/*obj", http.HandlerFunc(server.OptionsHandler))

        router.Get("/v1/:account/:container", http.HandlerFunc(server.ContainerGetHandler))
        router.Get("/v1/:account/:container/", http.HandlerFunc(server.ContainerGetHandler))
        router.Head("/v1/:account/:container", http.HandlerFunc(server.ContainerHeadHandler))
        router.Head("/v1/:account/:container/", http.HandlerFunc(server.ContainerHeadHandler))
        router.Put("/v1/:account/:container", http.HandlerFunc(server.ContainerPutHandler))
        router.Put("/v1/:account/:container/", http.HandlerFunc(server.ContainerPutHandler))
        router.Delete("/v1/:account/:container", http.HandlerFunc(server.ContainerDeleteHandler))
        router.Delete("/v1/:account/:container/", http.HandlerFunc(server.ContainerDeleteHandler))
        router.Post("/v1/:account/:container", http.HandlerFunc(server.ContainerPostHandler))
        router.Post("/v1/:account/:container/", http.HandlerFunc(server.ContainerPostHandler))
        router.Options("/v1/:account/:container", http.HandlerFunc(server.OptionsHandler))
        router.Options("/v1/:account/:container/", http.HandlerFunc(server.OptionsHandler))

        router.Get("/v1/:account", http.HandlerFunc(server.AccountGetHandler))
        router.Get("/v1/:account/", http.HandlerFunc(server.AccountGetHandler))
        router.Head("/v1/:account", http.HandlerFunc(server.AccountHeadHandler))
        router.Head("/v1/:account/", http.HandlerFunc(server.AccountHeadHandler))
        router.Put("/v1/:account", http.HandlerFunc(server.AccountPutHandler))
        router.Put("/v1/:account/", http.HandlerFunc(server.AccountPutHandler))
        router.Delete("/v1/:account", http.HandlerFunc(server.AccountDeleteHandler))
        router.Delete("/v1/:account/", http.HandlerFunc(server.AccountDeleteHandler))
        router.Post("/v1/:account", http.HandlerFunc(server.AccountPostHandler))
        router.Post("/v1/:account/", http.HandlerFunc(server.AccountPostHandler))
        router.Options("/v1/:account", http.HandlerFunc(server.OptionsHandler))
        router.Options("/v1/:account/", http.HandlerFunc(server.OptionsHandler))

        tempAuth := config.GetBool("proxy-server", "tempauth_enabled", true)
        var middlewares []struct {
                construct func(config conf.Section) (func(http.Handler) http.Handler, error)
                section   string
        }
        // TODO: make this all dynamical and stuff
        if tempAuth </span><span class="cov0" title="0">{
                middlewares = []struct {
                        construct func(config conf.Section) (func(http.Handler) http.Handler, error)
                        section   string
                }{
                        {middleware.NewCatchError, "filter:catch_errors"},
                        {middleware.NewHealthcheck, "filter:healthcheck"},
                        {middleware.NewRequestLogger, "filter:proxy-logging"},
                        {middleware.NewCors, "filter:cors"}, // TODO: i dont want to have to have a seciton for this
                        {middleware.NewFormPost, "filter:formpost"},
                        {middleware.NewTempURL, "filter:tempurl"},
                        {middleware.NewTempAuth, "filter:tempauth"},
                        {middleware.NewMultirange, "filter:multirange"},
                        {middleware.NewRatelimiter, "filter:ratelimit"},
                        {middleware.NewStaticWeb, "filter:staticweb"},
                        {middleware.NewCopyMiddleware, "filter:copy"},
                        {middleware.NewXlo, "filter:slo"},
                }
        }</span><span class="cov0" title="0"> else {
                middlewares = []struct {
                        construct func(config conf.Section) (func(http.Handler) http.Handler, error)
                        section   string
                }{
                        {middleware.NewCatchError, "filter:catch_errors"},
                        {middleware.NewHealthcheck, "filter:healthcheck"},
                        {middleware.NewRequestLogger, "filter:proxy-logging"},
                        {middleware.NewCors, "filter:cors"},
                        {middleware.NewFormPost, "filter:formpost"},
                        {middleware.NewTempURL, "filter:tempurl"},
                        {middleware.NewAuthToken, "filter:authtoken"},
                        {middleware.NewKeystoneAuth, "filter:keystoneauth"},
                        {middleware.NewMultirange, "filter:multirange"},
                        {middleware.NewRatelimiter, "filter:ratelimit"},
                        {middleware.NewStaticWeb, "filter:staticweb"},
                        {middleware.NewCopyMiddleware, "filter:copy"},
                        {middleware.NewXlo, "filter:slo"},
                }
        }</span>
        <span class="cov0" title="0">pipeline := alice.New(middleware.NewContext(server.mc, server.logger, server.proxyDirectClient))
        for _, m := range middlewares </span><span class="cov0" title="0">{
                mid, err := m.construct(config.GetSection(m.section))
                if err != nil </span><span class="cov0" title="0">{
                        // TODO: propagate error upwards instead of panicking
                        panic("Unable to construct middleware")</span>
                }
                <span class="cov0" title="0">pipeline = pipeline.Append(mid)</span>
        }
        <span class="cov0" title="0">return pipeline.Then(router)</span>
}

func GetServer(serverconf conf.Config, flags *flag.FlagSet) (string, int, srv.Server, srv.LowLevelLogger, error) <span class="cov0" title="0">{
        var err error
        server := &amp;ProxyServer{}
        server.mc, err = ring.NewMemcacheRingFromConfig(serverconf)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, err
        }</span>

        <span class="cov0" title="0">bindIP := serverconf.GetDefault("DEFAULT", "bind_ip", "0.0.0.0")
        bindPort := serverconf.GetInt("DEFAULT", "bind_port", 8080)

        logLevelString := serverconf.GetDefault("app:proxy-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        server.accountAutoCreate = serverconf.GetBool("app:proxy-server", "account_autocreate", false)
        if server.logger, err = srv.SetupLogger("proxy-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov0" title="0">policies := conf.LoadPolicies()
        server.proxyDirectClient, err = client.NewProxyDirectClient(policies)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, nil, fmt.Errorf("Error setting up proxyDirectClient: %v", err)
        }</span>
        <span class="cov0" title="0">info := map[string]interface{}{
                "version":            common.Version,
                "strict_cors_mode":   true,
                "policies":           policies.GetPolicyInfo(),
                "account_autocreate": server.accountAutoCreate,
        }
        for k, v := range DEFAULT_CONSTRAINTS </span><span class="cov0" title="0">{
                info[k] = v
        }</span>
        <span class="cov0" title="0">middleware.RegisterInfo("swift", info)
        return bindIP, int(bindPort), server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/troubling/hummingbird/common"
)

// Returns a cleaned ACL header value, validating that it meets the formatting
// requirements for standard Hummingbird ACL strings.
func CleanACL(name string, value string) (string, error) <span class="cov8" title="1">{
        name = strings.ToLower(name)
        var values []string
        for _, rawValue := range strings.Split(value, ",") </span><span class="cov8" title="1">{
                rawValue = strings.TrimSpace(rawValue)
                if rawValue == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !strings.Contains(rawValue, ":") </span><span class="cov8" title="1">{
                        values = append(values, rawValue)
                        continue</span>
                }
                <span class="cov8" title="1">v := strings.SplitN(rawValue, ":", 2)
                v[0] = strings.TrimSpace(v[0])
                v[1] = strings.TrimSpace(v[1])
                if v[0] == "" || !strings.HasPrefix(v[0], ".") </span><span class="cov8" title="1">{
                        values = append(values, rawValue)
                }</span><span class="cov8" title="1"> else if common.StringInSlice(v[0], []string{".r", ".ref", ".referer", ".referrer"}) </span><span class="cov8" title="1">{
                        if strings.Contains(name, "write") </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("Referrers not allowed in write ACL: %s", rawValue)
                        }</span>
                        <span class="cov8" title="1">negate := false
                        if v[1] != "" &amp;&amp; strings.HasPrefix(v[1], "-") </span><span class="cov8" title="1">{
                                negate = true
                                v[1] = strings.TrimSpace(v[1][1:])
                        }</span>
                        <span class="cov8" title="1">if v[1] != "" &amp;&amp; v[1] != "*" &amp;&amp; strings.HasPrefix(v[1], "*") </span><span class="cov8" title="1">{
                                v[1] = strings.TrimSpace(v[1][1:])
                        }</span>
                        <span class="cov8" title="1">if v[1] == "" || v[1] == "." </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("No host/domain value after referrer designation in ACL: %s", rawValue)
                        }</span>
                        <span class="cov8" title="1">if negate </span><span class="cov8" title="1">{
                                values = append(values, fmt.Sprintf(".r:-%s", v[1]))
                        }</span><span class="cov8" title="1"> else {
                                values = append(values, fmt.Sprintf(".r:%s", v[1]))
                        }</span>
                }<span class="cov8" title="1"> else {
                        return "", fmt.Errorf("Unknown designator %s in ACL: %s", v[0], rawValue)
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(values, ","), nil</span>

}

// Parses a standard Hummingbird ACL string into a referrers list and groups list.
func ParseACL(acl string) ([]string, []string) <span class="cov8" title="1">{
        referrers := []string{}
        groups := []string{}
        if acl != "" </span><span class="cov8" title="1">{
                for _, value := range strings.Split(acl, ",") </span><span class="cov8" title="1">{
                        if strings.HasPrefix(value, ".r:") </span><span class="cov8" title="1">{
                                referrers = append(referrers, value[len(".r:"):])
                        }</span><span class="cov8" title="1"> else {
                                groups = append(groups, value)
                        }</span>
                }
        }
        <span class="cov8" title="1">return referrers, groups</span>
}

//Returns True if the referrer should be allowed based on the referrerACL list
func ReferrerAllowed(referrer string, referrerACL []string) bool <span class="cov8" title="1">{
        allow := false
        if len(referrerACL) &gt; 0 </span><span class="cov8" title="1">{
                rHost := "unknown"
                if u, err := url.Parse(referrer); err == nil </span><span class="cov8" title="1">{
                        rHost = u.Hostname()
                }</span>
                <span class="cov8" title="1">for _, mHost := range referrerACL </span><span class="cov8" title="1">{
                        if strings.HasPrefix(mHost, "-") </span><span class="cov8" title="1">{
                                mHost = mHost[1:]
                                if mHost == rHost || (strings.HasPrefix(mHost, ".") &amp;&amp; strings.HasSuffix(rHost, mHost)) </span><span class="cov8" title="1">{
                                        allow = false
                                }</span>
                        }<span class="cov8" title="1"> else if mHost == "*" || mHost == rHost || (strings.HasPrefix(mHost, ".") &amp;&amp; strings.HasSuffix(rHost, mHost)) </span><span class="cov8" title="1">{
                                allow = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return allow</span>
}

func AuthorizeUnconfirmedIdentity(r *http.Request, obj string, referrers []string, roles []string) (bool, error) <span class="cov8" title="1">{
        if ReferrerAllowed(r.Referer(), referrers) </span><span class="cov8" title="1">{
                if obj != "" || common.StringInSlice(".rlistings", roles) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
                <span class="cov8" title="1">return false, nil</span>
        }
        <span class="cov8" title="1">return false, errors.New("unable to confirm identity")</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common/conf"
        "go.uber.org/zap"
)

type identity struct {
        client          *http.Client
        authURL         string
        authPlugin      string
        projectDomainID string
        userDomainID    string
        projectName     string
        userName        string
        password        string
        userAgent       string
}

type authToken struct {
        *identity
        next      http.Handler
        cacheTime int
}

var authHeaders = []string{"X-Identity-Status",
        "X-Service-Identity-Status",
        "X-Domain-Id",
        "X-Domain-Name",
        "X-Project-Id",
        "X-Project-Name",
        "X-Project-Domain-Id",
        "X-Project-Domain-Name",
        "X-User-Id",
        "X-User-Name",
        "X-User-Domain-Id",
        "X-User-Domain-Name",
        "X-Roles",
        "X-Service-Domain-Id",
        "X-Service-Domain-Name",
        "X-Service-Project-Id",
        "X-Service-Project-Name",
        "X-Service-Project-Domain-Id",
        "X-Service-Project-Domain-Name",
        "X-Service-User-Id",
        "X-Service-User-Name",
        "X-Service-User-Domain-Id",
        "X-Service-User-Domain-Name",
        "X-Service-Roles",
        "X-Service-Catalog",
        "X-Is-Admin-Project",
        //Deprecated Headers
        "X-Role",
        "X-User",
        "X-Tenant-Id",
        "X-Tenant-Name",
        "X-Tenant",
}

type domain struct {
        ID      string `json:"id"`
        Name    string `json:"name,omitempty"`
        Enabled bool   `json:"enabled,omitempty"`
}

type project struct {
        ID      string  `json:"id,omitempty"`
        Name    string  `json:"name,omitempty"`
        Enabled bool    `json:"enabled,omitempty"`
        Domain  *domain `json:"domain"`
}

type token struct {
        ExpiresAt time.Time `json:"expires_at"`
        IssuedAt  time.Time `json:"issued_at"`
        Methods   []string
        User      struct {
                ID      string
                Name    string
                Email   string
                Enabled bool
                Domain  struct {
                        ID   string
                        Name string
                }
        }
        Project *project
        Domain  *domain
        Roles   *[]struct {
                ID   string
                Name string
        }
}

func (t token) Valid() bool <span class="cov8" title="1">{
        now := time.Now().Unix()
        return now &lt; t.ExpiresAt.Unix()
}</span>

func (t token) populateReqHeader(r *http.Request, headerPrefix string) <span class="cov8" title="1">{
        r.Header.Set(fmt.Sprintf("X%s-User-Id", headerPrefix), t.User.ID)
        r.Header.Set(fmt.Sprintf("X%s-User-Name", headerPrefix), t.User.Name)
        r.Header.Set(fmt.Sprintf("X%s-User-Domain-Id", headerPrefix), t.User.Domain.ID)
        r.Header.Set(fmt.Sprintf("X%s-User-Domain-Name", headerPrefix), t.User.Domain.Name)

        if project := t.Project; project != nil </span><span class="cov8" title="1">{
                r.Header.Set(fmt.Sprintf("X%s-Project-Name", headerPrefix), project.Name)
                r.Header.Set(fmt.Sprintf("X%s-Project-Id", headerPrefix), project.ID)
                r.Header.Set(fmt.Sprintf("X%s-Project-Domain-Name", headerPrefix), project.Domain.Name)
                r.Header.Set(fmt.Sprintf("X%s-Project-Domain-Id", headerPrefix), project.Domain.ID)
        }</span>

        <span class="cov8" title="1">if domain := t.Domain; domain != nil </span><span class="cov8" title="1">{
                r.Header.Set(fmt.Sprintf("X%s-Domain-Id", headerPrefix), domain.ID)
                r.Header.Set(fmt.Sprintf("X%s-Domain-Name", headerPrefix), domain.Name)
        }</span>

        <span class="cov8" title="1">if roles := t.Roles; roles != nil </span><span class="cov8" title="1">{
                roleNames := []string{}
                for _, role := range *t.Roles </span><span class="cov8" title="1">{
                        roleNames = append(roleNames, role.Name)
                }</span>
                <span class="cov8" title="1">r.Header.Set(fmt.Sprintf("X%s-Roles", headerPrefix), strings.Join(roleNames, ","))</span>
        }
}

type identityReq struct {
        Auth struct {
                Identity struct {
                        Methods  []string `json:"methods"`
                        Password struct {
                                User struct {
                                        Domain struct {
                                                ID string `json:"id"`
                                        } `json:"domain"`
                                        Name     string `json:"name"`
                                        Password string `json:"password"`
                                } `json:"user"`
                        } `json:"password"`
                } `json:"identity"`

                Scope struct {
                        Project *project `json:"project"`
                } `json:"scope"`
        } `json:"auth"`
}

type identityResponse struct {
        Error *struct {
                Code    int
                Message string
                Title   string
        }
        Token *token
}

func (at *authToken) fetchAndValidateToken(ctx *ProxyContext, authToken string) (*token, bool) <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">var tok *token
        tokenValid := false
        if cachedToken, err := ctx.Cache.Get(authToken); err == nil </span><span class="cov8" title="1">{
                ctx.Logger.Debug("Found cache token",
                        zap.String("token", authToken))
                if t, ok := cachedToken.(token); ok </span><span class="cov8" title="1">{
                        tok = &amp;t
                        tokenValid = true
                }</span>
        }

        <span class="cov8" title="1">if tok == nil </span><span class="cov8" title="1">{
                var err error
                tok, err = at.validate(authToken)
                if err != nil </span><span class="cov8" title="1">{
                        ctx.Logger.Debug("Failed to validate token", zap.Error(err))
                        tokenValid = false
                }</span>

                <span class="cov8" title="1">if tok != nil </span><span class="cov8" title="1">{
                        tokenValid = true
                        ttl := at.cacheTime
                        if expiresIn := tok.ExpiresAt.Sub(time.Now()); expiresIn &lt; time.Duration(at.cacheTime)*time.Second </span><span class="cov0" title="0">{
                                ttl = int(expiresIn / time.Second)
                        }</span>
                        <span class="cov8" title="1">ctx.Cache.Set(authToken, *tok, ttl)</span>
                }
        }
        <span class="cov8" title="1">return tok, tokenValid</span>
}

func (at *authToken) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := GetProxyContext(r)
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                at.next.ServeHTTP(w, r)
                return
        }</span>
        <span class="cov8" title="1">removeAuthHeaders(r)
        r.Header.Set("X-Identity-Status", "Invalid")
        serviceAuthToken := r.Header.Get("X-Service-Token")
        if serviceAuthToken != "" </span><span class="cov0" title="0">{
                serviceToken, serviceTokenValid := at.fetchAndValidateToken(ctx, serviceAuthToken)
                if serviceToken != nil &amp;&amp; serviceTokenValid </span><span class="cov0" title="0">{
                        r.Header.Set("X-Service-Identity-Status", "Confirmed")
                        serviceToken.populateReqHeader(r, "-Service")
                }</span><span class="cov0" title="0"> else {
                        r.Header.Set("X-Service-Identity-Status", "Invalid")
                }</span>
        }

        <span class="cov8" title="1">userAuthToken := r.Header.Get("X-Auth-Token")
        if userAuthToken == "" </span><span class="cov8" title="1">{
                userAuthToken = r.Header.Get("X-Storage-Token")
        }</span>
        <span class="cov8" title="1">if userAuthToken != "" </span><span class="cov8" title="1">{
                userToken, userTokenValid := at.fetchAndValidateToken(ctx, userAuthToken)
                if userToken != nil &amp;&amp; userTokenValid </span><span class="cov8" title="1">{
                        r.Header.Set("X-Identity-Status", "Confirmed")
                        userToken.populateReqHeader(r, "")
                }</span>
        }
        <span class="cov8" title="1">at.next.ServeHTTP(w, r)</span>
}

func (at *authToken) validate(token string) (*token, error) <span class="cov8" title="1">{
        if !strings.HasSuffix(at.authURL, "/") </span><span class="cov8" title="1">{
                at.authURL += "/"
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest("GET", at.authURL+"v3/auth/tokens?nocatalog", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">serverAuthToken, err := at.serverAuth()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Auth-Token", serverAuthToken)
        req.Header.Set("X-Subject-Token", token)
        req.Header.Set("User-Agent", at.userAgent)

        r, err := at.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        if r.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, errors.New(r.Status)
        }</span>

        <span class="cov8" title="1">var resp identityResponse
        if err = json.NewDecoder(r.Body).Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if e := resp.Error; e != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s : %s", r.Status, e.Message)
        }</span>
        <span class="cov8" title="1">if r.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", r.Status)
        }</span>
        <span class="cov8" title="1">if resp.Token == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Response didn't contain token context")
        }</span>
        <span class="cov8" title="1">if !resp.Token.Valid() </span><span class="cov8" title="1">{
                return nil, errors.New("Returned token is not valid")

        }</span>
        <span class="cov8" title="1">return resp.Token, nil</span>
}

// serverAuth return the X-Auth-Token to use or an error.
func (at *authToken) serverAuth() (string, error) <span class="cov8" title="1">{
        authReq := &amp;identityReq{}
        authReq.Auth.Identity.Methods = []string{at.authPlugin}
        authReq.Auth.Identity.Password.User.Domain.ID = at.userDomainID
        authReq.Auth.Identity.Password.User.Name = at.userName
        authReq.Auth.Identity.Password.User.Password = at.password
        authReq.Auth.Scope.Project = &amp;project{Domain: &amp;domain{ID: at.projectDomainID}, Name: at.projectName}
        authReqBody, err := json.Marshal(authReq)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", at.authURL+"v3/auth/tokens", bytes.NewBuffer(authReqBody))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        resp, err := at.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("server auth token request gave status %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">rv := resp.Header.Get("X-Subject-Token")
        return rv, nil</span>
}

func removeAuthHeaders(r *http.Request) <span class="cov8" title="1">{
        for _, header := range authHeaders </span><span class="cov8" title="1">{
                r.Header.Del(header)
        }</span>
}

func NewAuthToken(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;authToken{
                        next:      next,
                        cacheTime: int(config.GetInt("token_cache_time", 300)),
                        identity: &amp;identity{authURL: config.GetDefault("auth_uri", "http://127.0.0.1:5000/"),
                                authPlugin:      config.GetDefault("auth_plugin", "password"),
                                projectDomainID: config.GetDefault("project_domain_id", "default"),
                                userDomainID:    config.GetDefault("user_domain_id", "default"),
                                projectName:     config.GetDefault("project_name", "service"),
                                userName:        config.GetDefault("username", "swift"),
                                password:        config.GetDefault("password", "password"),
                                userAgent:       config.GetDefault("user_agent", "hummingbird-keystone-middleware/1.0"),
                                client: &amp;http.Client{
                                        Timeout: 5 * time.Second,
                                }},
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file61" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

func Recover(w http.ResponseWriter, r *http.Request, msg string) <span class="cov0" title="0">{
        if err := recover(); err != nil </span><span class="cov0" title="0">{
                transactionId := r.Header.Get("X-Trans-Id")
                if ctx := GetProxyContext(r); ctx != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error(msg, zap.Any("err", err), zap.String("txn", transactionId))
                        // if we haven't set a status code yet, we can send a 500 response.
                        if started, _ := ctx.Response(); !started </span><span class="cov0" title="0">{
                                srv.StandardResponse(w, http.StatusInternalServerError)
                        }</span>
                }
        }
}

func NewCatchError(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(
                        func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                defer Recover(w, r, "PANIC")
                                next.ServeHTTP(w, r)
                        }</span>,
                )
        }, nil
}
</pre>
		
		<pre class="file" id="file62" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"
        "sync"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

var (
        serverInfo     = make(map[string]interface{})
        sil            sync.Mutex
        excludeHeaders = []string{
                "X-Account-Sysmeta-",
                "X-Container-Sysmeta-",
                "X-Object-Sysmeta-",
                "X-Object-Transient-Sysmeta-",
                "X-Backend-",
        }
)

func RegisterInfo(name string, data interface{}) <span class="cov0" title="0">{
        sil.Lock()
        defer sil.Unlock()
        serverInfo[name] = data
}</span>

func serverInfoDump() ([]byte, error) <span class="cov0" title="0">{
        sil.Lock()
        defer sil.Unlock()
        data, err := json.Marshal(serverInfo)
        return data, err
}</span>

type AccountInfo struct {
        ContainerCount int64
        ObjectCount    int64
        ObjectBytes    int64
        Metadata       map[string]string
        SysMetadata    map[string]string
}

type AuthorizeFunc func(r *http.Request) (bool, int)
type subrequestCopy func(dst, src *http.Request)

type ProxyContextMiddleware struct {
        next              http.Handler
        log               srv.LowLevelLogger
        Cache             ring.MemcacheRing
        proxyDirectClient *client.ProxyDirectClient
}

type ProxyContext struct {
        *ProxyContextMiddleware
        C                client.ProxyClient
        Authorize        AuthorizeFunc
        RemoteUsers      []string
        StorageOwner     bool
        ACL              string
        subrequestCopy   subrequestCopy
        Logger           srv.LowLevelLogger
        TxId             string
        responseSent     bool
        status           int
        accountInfoCache map[string]*AccountInfo
        depth            int
        Source           string
}

func GetProxyContext(r *http.Request) *ProxyContext <span class="cov8" title="1">{
        if rv := r.Context().Value("proxycontext"); rv != nil </span><span class="cov8" title="1">{
                return rv.(*ProxyContext)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ctx *ProxyContext) Response() (bool, int) <span class="cov0" title="0">{
        return ctx.responseSent, ctx.status
}</span>

func (ctx *ProxyContext) addSubrequestCopy(f subrequestCopy) <span class="cov0" title="0">{
        if ctx.subrequestCopy == nil </span><span class="cov0" title="0">{
                ctx.subrequestCopy = f
                return
        }</span>
        <span class="cov0" title="0">ca := ctx.subrequestCopy
        ctx.subrequestCopy = func(dst, src *http.Request) </span><span class="cov0" title="0">{
                ca(dst, src)
                f(dst, src)
        }</span>
}

func getPathParts(request *http.Request) (bool, string, string, string) <span class="cov8" title="1">{
        parts := strings.SplitN(request.URL.Path, "/", 5)
        apiRequest := len(parts) &gt; 0 &amp;&amp; parts[1] == "v1"
        if len(parts) == 5 </span><span class="cov8" title="1">{
                return apiRequest, parts[2], parts[3], parts[4]
        }</span><span class="cov8" title="1"> else if len(parts) == 4 </span><span class="cov8" title="1">{
                return apiRequest, parts[2], parts[3], ""
        }</span><span class="cov8" title="1"> else if len(parts) == 3 </span><span class="cov8" title="1">{
                return apiRequest, parts[2], "", ""
        }</span>
        <span class="cov0" title="0">return apiRequest, "", "", ""</span>
}

func (ctx *ProxyContext) GetAccountInfo(account string) (*AccountInfo, error) <span class="cov8" title="1">{
        key := fmt.Sprintf("account/%s", account)
        ai := ctx.accountInfoCache[key]
        if ai == nil </span><span class="cov0" title="0">{
                if err := ctx.Cache.GetStructured(key, &amp;ai); err != nil </span><span class="cov0" title="0">{
                        ai = nil
                }</span>
        }
        <span class="cov8" title="1">if ai == nil </span><span class="cov0" title="0">{
                resp := ctx.C.HeadAccount(account, nil)
                resp.Body.Close()
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%d error retrieving info for account %s", resp.StatusCode, account)
                }</span>
                <span class="cov0" title="0">ai = &amp;AccountInfo{
                        Metadata:    make(map[string]string),
                        SysMetadata: make(map[string]string),
                }
                var err error
                if ai.ContainerCount, err = strconv.ParseInt(resp.Header.Get("X-Account-Container-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for account %s : %s", account, err)
                }</span>
                <span class="cov0" title="0">if ai.ObjectCount, err = strconv.ParseInt(resp.Header.Get("X-Account-Object-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for account %s : %s", account, err)
                }</span>
                <span class="cov0" title="0">if ai.ObjectBytes, err = strconv.ParseInt(resp.Header.Get("X-Account-Bytes-Used"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for account %s : %s", account, err)
                }</span>
                <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                        if strings.HasPrefix(k, "X-Account-Meta-") </span><span class="cov0" title="0">{
                                ai.Metadata[k[15:]] = resp.Header.Get(k)
                        }</span><span class="cov0" title="0"> else if strings.HasPrefix(k, "X-Account-Sysmeta-") </span><span class="cov0" title="0">{
                                ai.SysMetadata[k[18:]] = resp.Header.Get(k)
                        }</span>
                }
                <span class="cov0" title="0">ctx.Cache.Set(key, ai, 30)</span>
        }
        <span class="cov8" title="1">return ai, nil</span>
}

func (ctx *ProxyContext) InvalidateAccountInfo(account string) <span class="cov0" title="0">{
        key := fmt.Sprintf("account/%s", account)
        delete(ctx.accountInfoCache, key)
        ctx.Cache.Delete(key)
}</span>

func (ctx *ProxyContext) AutoCreateAccount(account string, headers http.Header) <span class="cov0" title="0">{
        h := http.Header{"X-Timestamp": []string{common.GetTimestamp()},
                "X-Trans-Id": []string{ctx.TxId}}
        for key := range headers </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "X-Account-Sysmeta-") </span><span class="cov0" title="0">{
                        h[key] = []string{headers.Get(key)}
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.PutAccount(account, h)
        if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                ctx.InvalidateAccountInfo(account)
        }</span>
}

func (ctx *ProxyContext) newSubrequest(method, urlStr string, body io.Reader, req *http.Request, source string) (*http.Request, error) <span class="cov8" title="1">{
        subreq, err := http.NewRequest(method, urlStr, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">subctx := &amp;ProxyContext{
                ProxyContextMiddleware: ctx.ProxyContextMiddleware,
                Authorize:              ctx.Authorize,
                RemoteUsers:            ctx.RemoteUsers,
                subrequestCopy:         ctx.subrequestCopy,
                Logger:                 ctx.Logger.With(zap.String("src", source)),
                C:                      ctx.C,
                TxId:                   ctx.TxId,
                accountInfoCache:       ctx.accountInfoCache,
                responseSent:           false,
                status:                 500,
                depth:                  ctx.depth + 1,
                Source:                 source,
        }
        subreq = subreq.WithContext(context.WithValue(req.Context(), "proxycontext", subctx))
        if subctx.subrequestCopy != nil </span><span class="cov0" title="0">{
                subctx.subrequestCopy(subreq, req)
        }</span>
        <span class="cov8" title="1">if v := req.Header.Get("Referer"); v != "" </span><span class="cov0" title="0">{
                subreq.Header.Set("Referer", v)
        }</span>
        <span class="cov8" title="1">subreq.Header.Set("X-Trans-Id", subctx.TxId)
        subreq.Header.Set("X-Timestamp", common.GetTimestamp())
        return subreq, nil</span>
}

func (ctx *ProxyContext) serveHTTPSubrequest(writer http.ResponseWriter, subreq *http.Request) <span class="cov8" title="1">{
        subctx := GetProxyContext(subreq)
        // TODO: check subctx.depth
        subwriter := srv.NewCustomWriter(writer, func(w http.ResponseWriter, status int) int </span><span class="cov8" title="1">{
                subctx.responseSent = true
                subctx.status = status
                return status
        }</span>)
        <span class="cov8" title="1">subwriter.Header().Set("X-Trans-Id", subctx.TxId)
        ctx.next.ServeHTTP(subwriter, subreq)</span>
}

func (m *ProxyContextMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        if !srv.ValidateRequest(writer, request) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if request.URL.Path == "/info" </span><span class="cov0" title="0">{
                if request.Method == "GET" </span><span class="cov0" title="0">{
                        if data, err := serverInfoDump(); err != nil </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 500)
                        }</span><span class="cov0" title="0"> else {
                                writer.Header().Set("Content-Type", "application/json")
                                writer.WriteHeader(200)
                                writer.Write(data)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }<span class="cov0" title="0"> else if request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        writer.Header().Set("Allow", "HEAD, GET, OPTIONS")
                        writer.WriteHeader(200)
                        return
                }</span><span class="cov0" title="0"> else if request.Method == "HEAD" </span><span class="cov0" title="0">{
                        if _, err := serverInfoDump(); err != nil </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 500)
                        }</span><span class="cov0" title="0"> else {
                                writer.WriteHeader(200)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">for k := range request.Header </span><span class="cov0" title="0">{
                for _, ex := range excludeHeaders </span><span class="cov0" title="0">{
                        if strings.HasPrefix(k, ex) || k == "X-Timestamp" </span><span class="cov0" title="0">{
                                delete(request.Header, k)
                        }</span>
                }
        }

        <span class="cov0" title="0">transId := common.GetTransactionId()
        request.Header.Set("X-Trans-Id", transId)
        writer.Header().Set("X-Trans-Id", transId)
        writer.Header().Set("X-Openstack-Request-Id", transId)
        request.Header.Set("X-Timestamp", common.GetTimestamp())
        logr := m.log.With(zap.String("txn", transId))
        ctx := &amp;ProxyContext{
                ProxyContextMiddleware: m,
                Authorize:              nil,
                Logger:                 logr,
                TxId:                   transId,
                responseSent:           false,
                status:                 500,
                accountInfoCache:       make(map[string]*AccountInfo),
                C:                      client.NewProxyClient(m.proxyDirectClient, m.Cache, make(map[string]*client.ContainerInfo)),
        }
        // we'll almost certainly need the AccountInfo and ContainerInfo for the current path, so pre-fetch them in parallel.
        apiRequest, account, container, _ := getPathParts(request)
        if apiRequest &amp;&amp; account != "" </span><span class="cov0" title="0">{
                wg := &amp;sync.WaitGroup{}
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        ctx.GetAccountInfo(account)
                }</span>()
                <span class="cov0" title="0">if container != "" </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func() </span><span class="cov0" title="0">{
                                defer wg.Done()
                                ctx.C.GetContainerInfo(account, container)
                        }</span>()
                }
                <span class="cov0" title="0">wg.Wait()</span>
        }
        <span class="cov0" title="0">newWriter := srv.NewCustomWriter(writer, func(w http.ResponseWriter, status int) int </span><span class="cov0" title="0">{
                // strip out any bad headers before calling real WriteHeader
                for k := range w.Header() </span><span class="cov0" title="0">{
                        if k == "X-Account-Sysmeta-Project-Domain-Id" </span><span class="cov0" title="0">{
                                w.Header().Set("X-Account-Project-Domain-Id", w.Header().Get(k))
                        }</span>
                        <span class="cov0" title="0">for _, ex := range excludeHeaders </span><span class="cov0" title="0">{
                                if strings.HasPrefix(k, ex) </span><span class="cov0" title="0">{
                                        delete(w.Header(), k)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if status == http.StatusUnauthorized &amp;&amp; w.Header().Get("Www-Authenticate") == "" </span><span class="cov0" title="0">{
                        if account != "" </span><span class="cov0" title="0">{
                                w.Header().Set("Www-Authenticate", fmt.Sprintf("Swift realm=\"%s\"", common.Urlencode(account)))
                        }</span><span class="cov0" title="0"> else {
                                w.Header().Set("Www-Authenticate", "Swift realm=\"unknown\"")
                        }</span>
                }
                <span class="cov0" title="0">ctx.responseSent = true
                ctx.status = status
                return status</span>
        })
        <span class="cov0" title="0">request = request.WithContext(context.WithValue(request.Context(), "proxycontext", ctx))
        m.next.ServeHTTP(newWriter, request)</span>
}

func NewContext(mc ring.MemcacheRing, log srv.LowLevelLogger, proxyDirectClient *client.ProxyDirectClient) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;ProxyContextMiddleware{
                        Cache:             mc,
                        log:               log,
                        next:              next,
                        proxyDirectClient: proxyDirectClient,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/http/httptest"
        "net/url"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

type CopyWriter struct {
        http.ResponseWriter
        Logger        srv.LowLevelLogger
        accountName   string
        containerName string
        objectName    string
        origReqMethod string
        postAsCopy    bool
}

func (cw *CopyWriter) WriteHeader(status int) <span class="cov8" title="1">{
        if cw.postAsCopy &amp;&amp; status == http.StatusCreated </span><span class="cov8" title="1">{
                cw.ResponseWriter.WriteHeader(http.StatusAccepted)
        }</span><span class="cov8" title="1"> else {
                cw.ResponseWriter.WriteHeader(status)
        }</span>
}

type copyMiddleware struct {
        next http.Handler
}

func (cw *CopyWriter) getSrcAccountName(request *http.Request) string <span class="cov8" title="1">{
        copyFromAccount := request.Header.Get("X-Copy-From-Account")
        name, err := common.CheckNameFormat(request, copyFromAccount, "Account")
        if err == nil </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return cw.accountName</span>
}

func (cw *CopyWriter) getDestAccountName(request *http.Request) string <span class="cov8" title="1">{
        destAccount := request.Header.Get("Destination-Account")
        name, err := common.CheckNameFormat(request, destAccount, "Account")
        if err == nil </span><span class="cov8" title="1">{
                request.Header.Set("X-Copy-From-Account", cw.accountName)
                cw.accountName = name
                request.Header.Del("Destination-Account")
        }</span>
        <span class="cov8" title="1">return cw.accountName</span>
}

func getHeaderContainerObjectName(request *http.Request, header string) (string, string, error) <span class="cov8" title="1">{
        path, err := url.QueryUnescape(request.Header.Get(header))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", errors.New(fmt.Sprintf("Invalid %s", header))
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(path, "/") </span><span class="cov8" title="1">{
                path = "/" + path
        }</span>

        <span class="cov8" title="1">parts := strings.SplitN(path, "/", 3)
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return "", "", errors.New(fmt.Sprintf("Invalid %s", header))
        }</span>
        <span class="cov8" title="1">name, name_err := common.CheckNameFormat(request, parts[1], "Account")
        if name_err != nil </span><span class="cov8" title="1">{
                return "", "", errors.New(fmt.Sprintf("Invalid %s", header))
        }</span>
        <span class="cov8" title="1">return name, parts[2], nil</span>
}

type PipeResponseWriter struct {
        w      *io.PipeWriter
        status int
        header http.Header
        done   chan bool
        Logger srv.LowLevelLogger
}

func (w *PipeResponseWriter) Write(stuff []byte) (int, error) <span class="cov8" title="1">{
        written, err := w.w.Write(stuff)
        if err != nil </span><span class="cov0" title="0">{
                w.Logger.Error("PipeResponseWriter Write() error", zap.Error(err))
        }</span>
        <span class="cov8" title="1">return written, err</span>
}

func (w *PipeResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return w.header
}</span>

func (w *PipeResponseWriter) WriteHeader(status int) <span class="cov8" title="1">{
        w.status = status
        w.done &lt;- true
}</span>

func (w *PipeResponseWriter) Close() <span class="cov8" title="1">{
        w.w.Close()
}</span>

func NewPipeResponseWriter(writer *io.PipeWriter, done chan bool, logger srv.LowLevelLogger) *PipeResponseWriter <span class="cov8" title="1">{
        header := make(map[string][]string)
        return &amp;PipeResponseWriter{
                w:      writer,
                header: header,
                done:   done,
                Logger: logger,
        }
}</span>

func (c *copyMiddleware) getSourceObject(object string, request *http.Request, post bool) (io.ReadCloser, http.Header, int) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        subRequest, err := ctx.newSubrequest("GET", object, nil, request, "copy")
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("getSourceObject GET error", zap.Error(err))
                return nil, nil, 400
        }</span>
        <span class="cov8" title="1">if request.FormValue("multipart-manifest") == "get" </span><span class="cov8" title="1">{
                subRequest.URL.RawQuery = "multipart-manifest=get&amp;format=raw"
        }</span>
        <span class="cov8" title="1">copyItems(subRequest.Header, request.Header)
        // FIXME. Are we going to do X-Newest?
        subRequest.Header.Set("X-Newest", "true")
        subRequest.Header.Del("X-Backend-Storage-Policy-Index")
        if post </span><span class="cov8" title="1">{
                // POST doesn't need to auth the internal GET; if they issued a POST
                // and it was authorized and we happen to need to do a GET+PUT for our
                // own reasons, that's fine.
                GetProxyContext(subRequest).Authorize = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{ return true, http.StatusOK }</span>
        }

        <span class="cov8" title="1">pipeReader, pipeWriter := io.Pipe()
        done := make(chan bool)
        writer := NewPipeResponseWriter(pipeWriter, done, ctx.Logger)
        go func() </span><span class="cov8" title="1">{
                ctx.serveHTTPSubrequest(writer, subRequest)
                writer.Close()
        }</span>()
        <span class="cov8" title="1">&lt;-done

        return pipeReader, writer.Header(), writer.status</span>
}

func (c *copyMiddleware) handlePostAsCopy(writer *CopyWriter, request *http.Request) <span class="cov8" title="1">{
        request.Method = "PUT"
        writer.postAsCopy = true

        request.URL.Path = fmt.Sprintf("/v1/%s/%s/%s", writer.accountName, writer.containerName, writer.objectName)
        request.ContentLength = 0
        request.Header.Del("Range")
        objectPath := fmt.Sprintf("/%s/%s", writer.containerName, writer.objectName)
        request.Header.Set("X-Copy-From", common.Urlencode(objectPath))

        values, err := url.ParseQuery(request.URL.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
        }</span>
        <span class="cov8" title="1">values.Set("multipart-manifest", "get")
        values.Set("format", "raw")
        request.URL.RawQuery = values.Encode()

        c.handlePut(writer, request)</span>
}

func (c *copyMiddleware) handleCopy(writer *CopyWriter, request *http.Request) <span class="cov8" title="1">{
        if request.Header.Get("Destination") == "" </span><span class="cov8" title="1">{
                // FIXME.
                // swift has: body='Destination header required'
                srv.StandardResponse(writer, 412)
        }</span>
        <span class="cov8" title="1">destAccount := writer.getDestAccountName(request)
        destContainer, destObject, err := getHeaderContainerObjectName(request, "Destination")
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, 412)
                return
        }</span>
        <span class="cov8" title="1">source := fmt.Sprintf("%s/%s", writer.containerName, writer.objectName)
        writer.containerName = destContainer
        writer.objectName = destObject

        request.Method = "PUT"
        request.URL.Path = fmt.Sprintf("/v1/%s/%s/%s", destAccount, destContainer, destObject)
        request.ContentLength = 0
        request.Header.Set("X-Copy-From", common.Urlencode(source))
        request.Header.Del("Destination")

        c.handlePut(writer, request)</span>
}

func RemoveItemsWithPrefix(header http.Header, prefix string) <span class="cov8" title="1">{
        for k := range header </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, prefix) </span><span class="cov0" title="0">{
                        header.Del(k)
                }</span>
        }
}

func copyItemsWithPrefix(dest, src http.Header, prefix string) <span class="cov8" title="1">{
        for k, v := range src </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, prefix) </span><span class="cov8" title="1">{
                        dest.Del(k)
                        for _, v1 := range v </span><span class="cov8" title="1">{
                                dest.Add(k, v1)
                        }</span>
                }
        }
}

// TODO: This seems like it might copy headers it shouldn't.
// Also, shouldn't it be called copyHeaders instead?
func copyItems(dest, src http.Header) <span class="cov8" title="1">{
        for k, v := range src </span><span class="cov8" title="1">{
                dest.Del(k)
                for _, v1 := range v </span><span class="cov8" title="1">{
                        dest.Add(k, v1)
                }</span>
        }
}

func copyMetaItems(dest, src http.Header) <span class="cov8" title="1">{
        copyItemsWithPrefix(dest, src, "X-Object-Meta-")
        copyItemsWithPrefix(dest, src, "X-Object-Sysmeta-")
        copyItemsWithPrefix(dest, src, "X-Object-Transient-Sysmeta-")
        dest.Set("X-Delete-At", src.Get("X-Delete-At"))
}</span>

func excludeContains(exclude []string, k string) bool <span class="cov8" title="1">{
        for _, ex := range exclude </span><span class="cov8" title="1">{
                if k == ex </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func copyItemsExclude(dest, src http.Header, exclude []string) <span class="cov8" title="1">{
        for k, v := range src </span><span class="cov8" title="1">{
                if !excludeContains(exclude, k) </span><span class="cov8" title="1">{
                        dest.Del(k)
                        for _, v1 := range v </span><span class="cov8" title="1">{
                                dest.Add(k, v1)
                        }</span>
                }
        }
}

func (c *copyMiddleware) handlePut(writer *CopyWriter, request *http.Request) <span class="cov8" title="1">{
        if request.ContentLength != 0 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
                return
        }</span>

        <span class="cov8" title="1">srcAccountName := writer.getSrcAccountName(request)
        srcContainer, srcObject, err := getHeaderContainerObjectName(request, "X-Copy-From")
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 412)
                return
        }</span>

        <span class="cov8" title="1">srcPath := fmt.Sprintf("/v1/%s/%s/%s", srcAccountName, srcContainer, srcObject)

        post := writer.origReqMethod == "POST"
        if !post </span><span class="cov8" title="1">{
                writer.Logger.Info(fmt.Sprintf("Copying object from %s to %s", srcPath, request.URL.Path))
        }</span>

        <span class="cov8" title="1">srcBody, srcHeader, srcStatus := c.getSourceObject(common.Urlencode(srcPath), request, post)
        if srcBody != nil </span><span class="cov8" title="1">{
                defer srcBody.Close()
        }</span>
        <span class="cov8" title="1">if srcStatus &gt;= 300 </span><span class="cov0" title="0">{
                // Return the result of the GET
                for k := range srcHeader </span><span class="cov0" title="0">{
                        writer.Header().Set(k, srcHeader.Get(k))
                }</span>
                <span class="cov0" title="0">writer.WriteHeader(srcStatus)
                if srcBody != nil </span><span class="cov0" title="0">{
                        common.Copy(srcBody, writer)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">origHeader := make(map[string][]string)
        copyItems(origHeader, request.Header)
        if post </span><span class="cov8" title="1">{
                // Post-as-copy: ignore new sysmeta, copy existing sysmeta
                RemoveItemsWithPrefix(request.Header, "X-Object-Sysmeta-")
                copyItemsWithPrefix(request.Header, srcHeader, "X-Object-Sysmeta-")
        }</span><span class="cov8" title="1"> else if common.LooksTrue(request.Header.Get("X-Fresh-Metadata")) </span><span class="cov0" title="0">{
                // # x-fresh-metadata only applies to copy, not post-as-copy: ignore
                // existing user metadata, update existing sysmeta with new
                copyItemsWithPrefix(request.Header, srcHeader, "X-Object-Sysmeta-")
                copyItemsWithPrefix(request.Header, origHeader, "X-Object-Sysmeta-")
        }</span><span class="cov8" title="1"> else {
                // First copy existing sysmeta, user meta and other headers from the
                // source to the request, apart from headers that are conditionally
                // copied below and timestamps.
                exclude := []string{"X-Static-Large-Object", "X-Object-Manifest",
                        "Etag", "Content-Type", "X-Timestamp", "X-Backend-Timestamp"}
                copyItemsExclude(request.Header, srcHeader, exclude)
                // now update with original req headers
                copyItems(request.Header, origHeader)
        }</span>

        <span class="cov8" title="1">values, err := url.ParseQuery(request.URL.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
        }</span>
        <span class="cov8" title="1">if values.Get("multipart-manifest") == "get" </span><span class="cov8" title="1">{
                if srcHeader.Get("X-Static-Large-Object") != "" </span><span class="cov0" title="0">{
                        values.Set("multipart-manifest", "put")
                }</span>
                <span class="cov8" title="1">if srcHeader.Get("X-Object-Manifest") != "" </span><span class="cov0" title="0">{
                        values.Del("multipart-manifest")
                        request.Header.Set("X-Object-Manifest", srcHeader.Get("X-Object-Manifest"))
                }</span>
        }

        <span class="cov8" title="1">request.URL.RawQuery = values.Encode()
        request.ContentLength = 0
        request.Body = srcBody

        if srcStatus == http.StatusOK &amp;&amp;
                srcHeader.Get("X-Static-Large-Object") == "" &amp;&amp;
                (srcHeader.Get("X-Object-Manifest") == "" || request.FormValue("multipart-manifest") == "get") </span><span class="cov8" title="1">{
                // copy source etag so that copied content is verified, unless:
                //  - not a 200 OK response: source etag may not match the actual
                //    content, for example with a 206 Partial Content response to a
                //    ranged request
                //  - SLO manifest: etag cannot be specified in manifest PUT; SLO
                //    generates its own etag value which may differ from source
                //  - SLO: etag in SLO response is not hash of actual content
                //  - DLO: etag in DLO response is not hash of actual content
                request.Header.Set("Etag", srcHeader.Get("Etag"))
        }</span><span class="cov0" title="0"> else {
                // since we're not copying the source etag, make sure that any
                // container update override values are not copied.
                RemoveItemsWithPrefix(request.Header, "X-Object-Sysmeta-Container-Update-Override-")
        }</span>

        <span class="cov8" title="1">request.Header.Del("X-Copy-From")
        request.Header.Del("X-Copy-From-Account")

        // If the copy request does not explicitly override content-type,
        // use the one present in the source object.
        if request.Header.Get("Content-Type") == "" </span><span class="cov8" title="1">{
                request.Header.Set("Content-Type", srcHeader.Get("Content-Type"))
        }</span>

        <span class="cov8" title="1">var respHeader http.Header = make(map[string][]string)

        respHeader.Set("X-Copied-From-Account", common.Urlencode(srcAccountName))
        copiedFrom := fmt.Sprintf("%s/%s", srcContainer, srcObject)
        respHeader.Set("X-Copied-From", common.Urlencode(copiedFrom))
        if srcHeader.Get("Last-Modified") != "" </span><span class="cov0" title="0">{
                respHeader.Set("Last-Modified", srcHeader.Get("Last-Modified"))
        }</span>

        <span class="cov8" title="1">copyMetaItems(respHeader, request.Header)

        for k, v := range respHeader </span><span class="cov8" title="1">{
                for _, v1 := range v </span><span class="cov8" title="1">{
                        writer.Header().Add(k, v1)
                }</span>
        }

        <span class="cov8" title="1">c.next.ServeHTTP(writer, request)</span>
}

func (c *copyMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        apiReq, account, container, object := getPathParts(request)
        if !apiReq || account == "" || container == "" || object == "" </span><span class="cov0" title="0">{
                c.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">ctx := GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>

        <span class="cov8" title="1">cw := &amp;CopyWriter{
                ResponseWriter: writer,
                Logger:         ctx.Logger,
                accountName:    account,
                containerName:  container,
                objectName:     object,
        }

        if request.Method == "PUT" &amp;&amp; request.Header.Get("X-Copy-From") != "" </span><span class="cov8" title="1">{
                c.handlePut(cw, request)
                return
        }</span><span class="cov8" title="1"> else if request.Method == "COPY" </span><span class="cov8" title="1">{
                cw.origReqMethod = "COPY"
                c.handleCopy(cw, request)
                return
        }</span><span class="cov8" title="1"> else if request.Method == "POST" </span><span class="cov8" title="1">{
                // TODO: Replace with PipeResponse stuff from #154
                subrec := httptest.NewRecorder()
                c.next.ServeHTTP(subrec, request)
                subresp := subrec.Result()
                defer subresp.Body.Close()
                if subresp.StatusCode == http.StatusConflict </span><span class="cov8" title="1">{
                        cw.origReqMethod = "POST"
                        c.handlePostAsCopy(cw, request)
                }</span><span class="cov0" title="0"> else {
                        // Copy headers that weren't previously set.
                        for k, vs := range subresp.Header </span><span class="cov0" title="0">{
                                if _, ok := writer.Header()[k]; !ok </span><span class="cov0" title="0">{
                                        for _, v := range vs </span><span class="cov0" title="0">{
                                                writer.Header().Add(k, v)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">writer.WriteHeader(subresp.StatusCode)
                        io.Copy(writer, subresp.Body)</span>
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">c.next.ServeHTTP(writer, request)</span>
}

func NewCopyMiddleware(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{ return &amp;copyMiddleware{next: next} }</span>, nil
}
</pre>
		
		<pre class="file" id="file64" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

type corsMiddleware struct {
        next http.Handler
}

type cors struct {
        origin string
        ci     *client.ContainerInfo
}

func (c *cors) HandleCors(writer http.ResponseWriter, status int) int <span class="cov8" title="1">{
        if c.origin == "" || !common.IsOriginAllowed(c.ci.Metadata["Access-Control-Allow-Origin"], c.origin) </span><span class="cov8" title="1">{
                return status
        }</span>
        <span class="cov8" title="1">if writer.Header().Get("Access-Control-Expose-Headers") == "" </span><span class="cov8" title="1">{
                corsExposeHeaders := []string{"Cache-Control", "Content-Language",
                        "Content-Type", "Expires", "Last-Modified", "Pragma", "Etag",
                        "X-Timestamp", "X-Trans-Id", "X-Openstack-Request-Id"}
                for k := range writer.Header() </span><span class="cov0" title="0">{
                        if strings.HasPrefix(
                                k, "X-Container-Meta") || strings.HasPrefix(
                                k, "X-Object-Meta") </span><span class="cov0" title="0">{
                                corsExposeHeaders = append(corsExposeHeaders, k)
                        }</span>
                }
                <span class="cov8" title="1">if c.ci.Metadata["Access-Control-Expose-Headers"] != "" </span><span class="cov8" title="1">{
                        for _, h := range strings.Split(
                                c.ci.Metadata["Access-Control-Expose-Headers"], " ") </span><span class="cov8" title="1">{
                                corsExposeHeaders = append(corsExposeHeaders, h)
                        }</span>
                }
                <span class="cov8" title="1">writer.Header().Set(
                        "Access-Control-Expose-Headers", strings.ToLower(strings.Join(corsExposeHeaders, ", ")))</span>
        }
        <span class="cov8" title="1">if writer.Header().Get("Access-Control-Allow-Origin") == "" </span><span class="cov8" title="1">{
                if c.ci.Metadata["Access-Control-Allow-Origin"] == "*" </span><span class="cov8" title="1">{
                        writer.Header().Set("Access-Control-Allow-Origin", "*")
                }</span><span class="cov8" title="1"> else {
                        writer.Header().Set("Access-Control-Allow-Origin", c.origin)
                }</span>
        }
        <span class="cov8" title="1">return status</span>
}

func (cm *corsMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        origin := request.Header.Get("Origin")
        ctx := GetProxyContext(request)
        if ctx == nil || origin == "" </span><span class="cov0" title="0">{
                cm.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov0" title="0">pathParts, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathParts["container"] == "" </span><span class="cov0" title="0">{
                cm.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov0" title="0">if ci, err := ctx.C.GetContainerInfo(pathParts["account"], pathParts["container"]); err == nil </span><span class="cov0" title="0">{
                cHandler := &amp;cors{origin: origin, ci: ci}
                w := srv.NewCustomWriter(writer, cHandler.HandleCors)
                cm.next.ServeHTTP(w, request)
                return
        }</span>
        <span class="cov0" title="0">cm.next.ServeHTTP(writer, request)</span>
}

func NewCors(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;corsMiddleware{
                        next: next,
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file65" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "crypto/hmac"
        "crypto/sha1"
        "encoding/hex"
        "errors"
        "fmt"
        "html"
        "io"
        "io/ioutil"
        "mime"
        "mime/multipart"
        "net/http"
        "net/http/httptest"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

const (
        FP_INVALID = iota
        FP_ERROR
        FP_EXPIRED
        FP_SCOPE_ACCOUNT
        FP_SCOPE_CONTAINER
)

type fpLimitReader struct {
        io.Reader
        l int64
        r int64
}

func (o *fpLimitReader) overRead() bool <span class="cov8" title="1">{
        return o.r &gt; o.l
}</span>

func (o *fpLimitReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        i, err := o.Reader.Read(p)
        o.r += int64(i)
        if o.r &gt; o.l </span><span class="cov8" title="1">{
                return 0, errors.New("Read over limit")
        }</span>
        <span class="cov8" title="1">return i, err</span>
}

func authenticateFormpost(ctx *ProxyContext, account, container, path string, attrs map[string]string) int <span class="cov8" title="1">{
        if expires, err := common.ParseDate(attrs["expires"]); err != nil </span><span class="cov8" title="1">{
                return FP_ERROR
        }</span><span class="cov8" title="1"> else if time.Now().After(expires) </span><span class="cov8" title="1">{
                return FP_EXPIRED
        }</span>

        <span class="cov8" title="1">sigb, err := hex.DecodeString(attrs["signature"])
        if err != nil || len(sigb) == 0 </span><span class="cov8" title="1">{
                return FP_ERROR
        }</span>

        <span class="cov8" title="1">checkhmac := func(key []byte) bool </span><span class="cov8" title="1">{
                mac := hmac.New(sha1.New, key)
                fmt.Fprintf(mac, "%s\n%s\n%s\n%s\n%s", path, attrs["redirect"],
                        attrs["max_file_size"], attrs["max_file_count"], attrs["expires"])
                return hmac.Equal(sigb, mac.Sum(nil))
        }</span>

        <span class="cov8" title="1">if ai, err := ctx.GetAccountInfo(account); err == nil </span><span class="cov8" title="1">{
                if key, ok := ai.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                        return FP_SCOPE_ACCOUNT
                }</span><span class="cov8" title="1"> else if key, ok := ai.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                        return FP_SCOPE_ACCOUNT
                }</span><span class="cov8" title="1"> else if ci, err := ctx.C.GetContainerInfo(account, container); err == nil </span><span class="cov8" title="1">{
                        if key, ok := ci.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                                return FP_SCOPE_CONTAINER
                        }</span><span class="cov8" title="1"> else if key, ok := ci.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                                return FP_SCOPE_CONTAINER
                        }</span>
                }
        }
        <span class="cov8" title="1">return FP_INVALID</span>
}

func formpostRespond(writer http.ResponseWriter, status int, message, redirect string) <span class="cov8" title="1">{
        if redirect == "" </span><span class="cov8" title="1">{
                body := fmt.Sprintf("&lt;h1&gt;%d %s&lt;/h1&gt;%s", status, http.StatusText(status), message)
                writer.Header().Set("Content-Type", "text/html")
                writer.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
                writer.WriteHeader(status)
                writer.Write([]byte(body))
        }</span><span class="cov8" title="1"> else {
                glue := "?"
                if strings.Contains(redirect, "?") </span><span class="cov0" title="0">{
                        glue = "&amp;"
                }</span>
                <span class="cov8" title="1">redir := fmt.Sprintf("%s%sstatus=%d&amp;message=%s", redirect, glue, status, common.Urlencode(message))
                body := fmt.Sprintf("&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;a href=\"%s\"&gt;Click to continue...&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;",
                        html.EscapeString(redir))
                writer.Header().Set("Location", redir)
                writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
                writer.WriteHeader(303)
                io.WriteString(writer, body)</span>
        }
}

func formpostAuthorizer(scope int, account, container string) func(r *http.Request) (bool, int) <span class="cov8" title="1">{
        return func(r *http.Request) (bool, int) </span><span class="cov8" title="1">{
                ar, a, c, _ := getPathParts(r)
                if scope == FP_SCOPE_ACCOUNT </span><span class="cov8" title="1">{
                        if ar &amp;&amp; a == account </span><span class="cov8" title="1">{
                                return true, http.StatusOK
                        }</span>
                }<span class="cov8" title="1"> else if scope == FP_SCOPE_CONTAINER </span><span class="cov8" title="1">{
                        if ar &amp;&amp; a == account &amp;&amp; c == container </span><span class="cov8" title="1">{
                                return true, http.StatusOK
                        }</span>
                }
                <span class="cov8" title="1">return false, http.StatusForbidden</span>
        }
}

func formpost(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                if request.Method != "POST" </span><span class="cov0" title="0">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>

                <span class="cov8" title="1">contentType, params, err := mime.ParseMediaType(request.Header.Get("Content-Type"))
                if err != nil || contentType != "multipart/form-data" || params["boundary"] == "" </span><span class="cov0" title="0">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>

                <span class="cov8" title="1">apiReq, account, container, _ := getPathParts(request)
                if !apiReq || account == "" || container == "" </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 401)
                        return
                }</span>

                <span class="cov8" title="1">ctx := GetProxyContext(request)
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>

                <span class="cov8" title="1">validated := false
                attrs := map[string]string{
                        "redirect":       "",
                        "max_file_size":  "0",
                        "max_file_count": "0",
                        "expires":        "0",
                }
                mr := multipart.NewReader(request.Body, params["boundary"])
                var maxFileCount, fileCount, maxFileSize int64
                for </span><span class="cov8" title="1">{
                        p, err := mr.NextPart()
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }<span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                                formpostRespond(writer, 400, "invalid request", attrs["redirect"])
                                return
                        }</span>
                        <span class="cov8" title="1">if fn := p.FileName(); fn == "" </span><span class="cov8" title="1">{
                                data, err := ioutil.ReadAll(&amp;io.LimitedReader{R: p, N: 8192})
                                if err != nil </span><span class="cov0" title="0">{
                                        formpostRespond(writer, 400, "error reading form value", attrs["redirect"])
                                        return
                                }</span>
                                <span class="cov8" title="1">if len(attrs) &gt; 64 </span><span class="cov0" title="0">{
                                        formpostRespond(writer, 400, "too many form post values", attrs["redirect"])
                                        return
                                }</span>
                                <span class="cov8" title="1">attrs[p.FormName()] = string(data)</span>
                        }<span class="cov8" title="1"> else {
                                if !validated </span><span class="cov8" title="1">{
                                        if maxFileCount, err = strconv.ParseInt(attrs["max_file_count"], 10, 64); err != nil || maxFileCount &lt;= 0 </span><span class="cov0" title="0">{
                                                formpostRespond(writer, 400, "max_file_count not valid", attrs["redirect"])
                                                return
                                        }</span>
                                        <span class="cov8" title="1">if maxFileSize, err = strconv.ParseInt(attrs["max_file_size"], 10, 64); err != nil || maxFileSize &lt; 0 </span><span class="cov0" title="0">{
                                                formpostRespond(writer, 400, "max_file_size not valid", attrs["redirect"])
                                                return
                                        }</span>
                                        <span class="cov8" title="1">scope := authenticateFormpost(ctx, account, container, request.URL.Path, attrs)
                                        switch scope </span>{
                                        case FP_EXPIRED:<span class="cov8" title="1">
                                                formpostRespond(writer, 401, "request expired", attrs["redirect"])
                                                return</span>
                                        case FP_INVALID:<span class="cov0" title="0">
                                                formpostRespond(writer, 401, "invalid signature", attrs["redirect"])
                                                return</span>
                                        case FP_ERROR:<span class="cov0" title="0">
                                                formpostRespond(writer, 400, "invalid request", attrs["redirect"])
                                                return</span>
                                        default:<span class="cov8" title="1">
                                                ctx.RemoteUsers = []string{".formpost"}
                                                ctx.Authorize = formpostAuthorizer(scope, account, container)
                                                validated = true</span>
                                        }
                                }

                                <span class="cov8" title="1">fileCount++
                                if fileCount &gt; maxFileCount </span><span class="cov0" title="0">{
                                        formpostRespond(writer, 400, "max file count exceeded", attrs["redirect"])
                                        return
                                }</span>

                                <span class="cov8" title="1">path := request.URL.Path
                                if !strings.HasSuffix(path, "/") &amp;&amp; strings.Count(path, "/") &lt; 4 </span><span class="cov8" title="1">{
                                        path += "/"
                                }</span>
                                <span class="cov8" title="1">path += fn
                                neww := httptest.NewRecorder()
                                flr := &amp;fpLimitReader{Reader: p, l: maxFileSize}
                                newreq, err := ctx.newSubrequest("PUT", path, flr, request, "formpost")
                                if err != nil </span><span class="cov0" title="0">{
                                        formpostRespond(writer, 500, "internal server error", attrs["redirect"])
                                        return
                                }</span>
                                <span class="cov8" title="1">newreq.Header.Set("X-Delete-At", attrs["x_delete_at"])
                                newreq.Header.Set("X-Delete-After", attrs["x_delete_after"])
                                if attrs["content-type"] != "" </span><span class="cov0" title="0">{
                                        newreq.Header.Set("Content-Type", attrs["content-type"])
                                }</span><span class="cov8" title="1"> else {
                                        newreq.Header.Set("Content-Type", "application/octet-stream")
                                }</span>
                                <span class="cov8" title="1">ctx.serveHTTPSubrequest(neww, newreq)
                                if flr.overRead() </span><span class="cov0" title="0">{
                                        formpostRespond(writer, 400, "max_file_size exceeded", attrs["redirect"])
                                        return
                                }</span>
                                <span class="cov8" title="1">if neww.Code/100 != 2 </span><span class="cov0" title="0">{
                                        formpostRespond(writer, neww.Code, "upload error", attrs["redirect"])
                                        return
                                }</span>
                        }
                        <span class="cov8" title="1">p.Close()</span>
                }
                <span class="cov8" title="1">formpostRespond(writer, 201, "Success.", attrs["redirect"])</span>
        })
}

func NewFormPost(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("formpost", map[string]interface{}{})
        return formpost, nil
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "github.com/troubling/hummingbird/common/conf"
)

func NewHealthcheck(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(
                        func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                                if request.URL.Path == "/healthcheck" &amp;&amp; request.Method == "GET" </span><span class="cov0" title="0">{
                                        writer.Header().Set("Content-Length", "2")
                                        writer.WriteHeader(http.StatusOK)
                                        writer.Write([]byte("OK"))
                                        return
                                }</span>
                                <span class="cov0" title="0">next.ServeHTTP(writer, request)</span>
                        },
                )
        }, nil
}
</pre>
		
		<pre class="file" id="file67" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "go.uber.org/zap"
)

type keystoneAuth struct {
        resellerPrefixes  []string
        accountRules      map[string]map[string][]string
        resellerAdminRole string
        defaultDomainID   string
        next              http.Handler
}

func (ka *keystoneAuth) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer ka.next.ServeHTTP(w, r)
        ctx := GetProxyContext(r)
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">pathParts, err := common.ParseProxyPath(r.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, ok := ka.getAccountPrefix(pathParts["account"]); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">identityMap := extractIdentity(r)
        if len(identityMap) == 0 </span><span class="cov0" title="0">{
                ctx.Authorize = ka.authorizeAnonymous
                return
        }</span>
        <span class="cov0" title="0">ctx.RemoteUsers = []string{identityMap["tenantName"]}
        ctx.Authorize = ka.authorize
        ctx.addSubrequestCopy(keystoneSubrequestCopy)</span>
}

func (ka *keystoneAuth) accountMatchesTenant(account string, tenantID string) bool <span class="cov0" title="0">{
        for _, prefix := range ka.resellerPrefixes </span><span class="cov0" title="0">{
                if fmt.Sprintf("%s%s", prefix, tenantID) == account </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ka *keystoneAuth) getProjectDomainID(r *http.Request, account string) string <span class="cov0" title="0">{
        ctx := GetProxyContext(r)
        ai, err := ctx.GetAccountInfo(account)
        if err != nil </span><span class="cov0" title="0">{
                return "" // TODO: I assume this is what we want here
        }</span>
        <span class="cov0" title="0">return ai.SysMetadata["Project-Domain-Id"]</span>
}

func (ka *keystoneAuth) setProjectDomainID(r *http.Request, pathParts map[string]string, identityMap map[string]string) <span class="cov0" title="0">{
        for k := range r.Header </span><span class="cov0" title="0">{
                if k == "X-Account-Sysmeta-Project-Domain-Id" </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">if pathParts["object"] != "" || (pathParts["container"] != "" &amp;&amp; r.Method != "PUT") ||
                !common.StringInSlice(r.Method, []string{"PUT", "POST"}) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">tenantID := identityMap["tenantID"]
        sysmetaID := ka.getProjectDomainID(r, pathParts["account"])
        reqID, newID := "", ""
        if ka.accountMatchesTenant(pathParts["account"], tenantID) </span><span class="cov0" title="0">{
                reqID = identityMap["projectDomainID"]
                newID = reqID
        }</span>
        <span class="cov0" title="0">if sysmetaID == "" &amp;&amp; reqID == ka.defaultDomainID </span><span class="cov0" title="0">{
                newID = reqID
        }</span>
        <span class="cov0" title="0">if newID != "" </span><span class="cov0" title="0">{
                r.Header.Set("X-Account-Sysmeta-Project-Domain-Id", newID)
        }</span>
}

func (ka *keystoneAuth) isNameAllowedinACL(r *http.Request, account string, identityMap map[string]string) bool <span class="cov0" title="0">{
        userDomainID := identityMap["userDomainID"]
        if userDomainID != "" &amp;&amp; userDomainID != ka.defaultDomainID </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">projectDomainID := identityMap["projectDomainID"]
        if projectDomainID != "" &amp;&amp; projectDomainID != ka.defaultDomainID </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">tenantID := identityMap["tenantID"]
        allow := false
        if ka.accountMatchesTenant(account, tenantID) </span><span class="cov0" title="0">{
                allow = true
        }</span><span class="cov0" title="0"> else if common.StringInSlice(ka.getProjectDomainID(r, account), []string{ka.defaultDomainID, ""}) </span><span class="cov0" title="0">{
                allow = true
        }</span>
        <span class="cov0" title="0">return allow</span>
}

func (ka *keystoneAuth) authorizeCrossTenant(userID string, userName string,
        tenantID string, tenantName string, roles []string, allowNames bool) string <span class="cov0" title="0">{
        tenantMatch := []string{tenantID, "*"}
        userMatch := []string{userID, "*"}
        if allowNames </span><span class="cov0" title="0">{
                tenantMatch = append(tenantMatch, tenantName)
                userMatch = append(userMatch, userName)
        }</span>
        <span class="cov0" title="0">for _, tenant := range tenantMatch </span><span class="cov0" title="0">{
                for _, user := range userMatch </span><span class="cov0" title="0">{
                        s := fmt.Sprintf("%s:%s", tenant, user)
                        if common.StringInSlice(s, roles) </span><span class="cov0" title="0">{
                                return s
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (ka *keystoneAuth) authorize(r *http.Request) (bool, int) <span class="cov0" title="0">{
        identityMap := extractIdentity(r)
        ctx := GetProxyContext(r)
        if ctx == nil </span><span class="cov0" title="0">{
                return false, http.StatusUnauthorized
        }</span>
        <span class="cov0" title="0">s := http.StatusUnauthorized
        if len(ctx.RemoteUsers) != 0 </span><span class="cov0" title="0">{
                s = http.StatusForbidden
        }</span>
        <span class="cov0" title="0">tenantID := identityMap["tenantID"]
        tenantName := identityMap["tenantName"]
        userID := identityMap["userID"]
        userName := identityMap["userName"]

        referrers, roles := ParseACL(ctx.ACL)

        // allow OPTIONS requests to proceed as normal
        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                return true, http.StatusOK
        }</span>
        <span class="cov0" title="0">pathParts, err := common.ParseProxyPath(r.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Unable to parse URL", zap.Error(err))
                return false, s
        }</span>

        <span class="cov0" title="0">ka.setProjectDomainID(r, pathParts, identityMap)
        userRoles := []string{}
        for _, userRole := range common.SliceFromCSV(identityMap["roles"]) </span><span class="cov0" title="0">{
                userRoles = append(userRoles, strings.ToLower(userRole))
        }</span>
        <span class="cov0" title="0">userServiceRoles := []string{}
        for _, userServiceRole := range common.SliceFromCSV(identityMap["serviceRoles"]) </span><span class="cov0" title="0">{
                userServiceRoles = append(userServiceRoles, strings.ToLower(userServiceRole))
        }</span>
        <span class="cov0" title="0">if common.StringInSlice(ka.resellerAdminRole, userRoles) </span><span class="cov0" title="0">{
                ctx.Logger.Debug("User has reseller admin authorization", zap.String("userid", tenantID))
                return true, http.StatusOK
        }</span>

        <span class="cov0" title="0">if pathParts["container"] == "" &amp;&amp; pathParts["object"] == "" &amp;&amp;
                r.Method == "DELETE" </span><span class="cov0" title="0">{
                ctx.Logger.Debug("User is not allowed to delete its own account",
                        zap.String("tenantName", tenantName),
                        zap.String("userName", userName))
                return false, s
        }</span>
        <span class="cov0" title="0">matchedACL := ""
        if len(roles) &gt; 0 </span><span class="cov0" title="0">{
                allowNames := ka.isNameAllowedinACL(r, pathParts["account"], identityMap)
                matchedACL = ka.authorizeCrossTenant(userID, userName, tenantID, tenantName, roles, allowNames)
        }</span>
        <span class="cov0" title="0">if matchedACL != "" </span><span class="cov0" title="0">{
                ctx.Logger.Debug("user allowed in ACL authorizing", zap.String("user", matchedACL))
                return true, http.StatusOK
        }</span>

        <span class="cov0" title="0">isAuthorized, authErr := AuthorizeUnconfirmedIdentity(r, pathParts["object"], referrers, roles)

        if isAuthorized </span><span class="cov0" title="0">{
                return true, http.StatusOK
        }</span>

        <span class="cov0" title="0">if !ka.accountMatchesTenant(pathParts["account"], tenantID) </span><span class="cov0" title="0">{
                return false, s
        }</span>
        <span class="cov0" title="0">accountPrefix, _ := ka.getAccountPrefix(pathParts["account"])
        operatorRoles := ka.accountRules[accountPrefix]["operator_roles"]
        haveOperatorRole := false
        for _, or := range operatorRoles </span><span class="cov0" title="0">{
                if common.StringInSlice(or, userRoles) </span><span class="cov0" title="0">{
                        haveOperatorRole = true
                        break</span>
                }
        }
        <span class="cov0" title="0">serviceRoles := ka.accountRules[accountPrefix]["service_roles"]
        haveServiceRole := false
        for _, or := range serviceRoles </span><span class="cov0" title="0">{
                if common.StringInSlice(or, userServiceRoles) </span><span class="cov0" title="0">{
                        haveServiceRole = true
                        break</span>
                }
        }
        <span class="cov0" title="0">allowed := false
        if haveOperatorRole &amp;&amp; (len(serviceRoles) &gt; 0 &amp;&amp; haveServiceRole) </span><span class="cov0" title="0">{
                allowed = true
        }</span><span class="cov0" title="0"> else if haveOperatorRole &amp;&amp; len(serviceRoles) == 0 </span><span class="cov0" title="0">{
                allowed = true
        }</span>
        <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                return true, http.StatusOK
        }</span>
        <span class="cov0" title="0">if !isAuthorized &amp;&amp; authErr == nil </span><span class="cov0" title="0">{
                return false, s
        }</span>

        <span class="cov0" title="0">for _, role := range roles </span><span class="cov0" title="0">{
                if common.StringInSlice(role, userRoles) </span><span class="cov0" title="0">{
                        return true, http.StatusOK
                }</span>

        }
        <span class="cov0" title="0">return false, s</span>
}

func (ka *keystoneAuth) getAccountPrefix(account string) (string, bool) <span class="cov0" title="0">{
        // Empty prefix matches everything, so try to match others first
        for _, prefix := range ka.resellerPrefixes </span><span class="cov0" title="0">{
                if prefix != "" &amp;&amp; strings.HasPrefix(account, prefix) </span><span class="cov0" title="0">{
                        return prefix, true
                }</span>
        }
        <span class="cov0" title="0">for _, prefix := range ka.resellerPrefixes </span><span class="cov0" title="0">{
                if prefix == "" </span><span class="cov0" title="0">{
                        return "", true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

func (ka *keystoneAuth) authorizeAnonymous(r *http.Request) (bool, int) <span class="cov0" title="0">{
        ctx := GetProxyContext(r)
        pathParts, err := common.ParseProxyPath(r.URL.Path)
        s := http.StatusUnauthorized
        if len(ctx.RemoteUsers) != 0 </span><span class="cov0" title="0">{
                s = http.StatusForbidden
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Unable to parse URL", zap.Error(err))
                return false, s
        }</span>
        // allow OPTIONS requests to proceed as normal
        <span class="cov0" title="0">if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                return true, http.StatusOK
        }</span>
        <span class="cov0" title="0">isAuthorized := false
        if pathParts["account"] != "" </span><span class="cov0" title="0">{
                if prefix, ok := ka.getAccountPrefix(pathParts["account"]); ok </span><span class="cov0" title="0">{
                        if common.StringInSlice(prefix, ka.resellerPrefixes) </span><span class="cov0" title="0">{
                                isAuthorized = true
                        }</span>
                }
        }
        <span class="cov0" title="0">if !isAuthorized </span><span class="cov0" title="0">{
                return false, s
        }</span>

        <span class="cov0" title="0">referrers, roles := ParseACL(ctx.ACL)
        isAuthorized, _ = AuthorizeUnconfirmedIdentity(r, pathParts["object"], referrers, roles)

        if !isAuthorized </span><span class="cov0" title="0">{
                return false, s
        }</span>
        <span class="cov0" title="0">return true, http.StatusOK</span>
}

func keystoneSubrequestCopy(dst, src *http.Request) <span class="cov0" title="0">{
        for _, h := range []string{"X-Identity-Status", "X-Service-Identity-Status", "X-User-Id", "X-User-Name", "X-Project-Id", "X-Project-Name", "X-Roles", "X-Service-Roles", "X-User-Domain-Id", "X-User-Domain-Name", "X-Project-Domain-Id", "X-Project-Domain-Name"} </span><span class="cov0" title="0">{
                if v := src.Header.Get(h); v != "" </span><span class="cov0" title="0">{
                        dst.Header.Set(h, v)
                }</span><span class="cov0" title="0"> else {
                        delete(dst.Header, h)
                }</span>
        }
}

func extractIdentity(r *http.Request) map[string]string <span class="cov0" title="0">{
        identity := make(map[string]string)
        if r.Header.Get("X-Identity-Status") != "Confirmed" ||
                !common.StringInSlice(r.Header.Get("X-Service-Identity-Status"), []string{"Confirmed", ""}) </span><span class="cov0" title="0">{
                return identity
        }</span>

        <span class="cov0" title="0">identity["userID"] = r.Header.Get("X-User-Id")
        identity["userName"] = r.Header.Get("X-User-Name")
        identity["tenantID"] = r.Header.Get("X-Project-Id")
        identity["tenantName"] = r.Header.Get("X-Project-Name")
        identity["roles"] = r.Header.Get("X-Roles")
        identity["serviceRoles"] = r.Header.Get("X-Service-Roles")
        identity["userDomainID"] = r.Header.Get("X-User-Domain-Id")
        identity["userDomainName"] = r.Header.Get("X-User-Domain-Name")
        identity["projectDomainID"] = r.Header.Get("X-Project-Domain-Id")
        identity["projectDomainName"] = r.Header.Get("X-Project-Domain-Name")

        return identity</span>
}

func NewKeystoneAuth(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        defaultRules := map[string][]string{"operator_roles": {"admin", "swiftoperator"},
                "service_roles": {}}
        resellerPrefixes, accountRules := conf.ReadResellerOptions(config, defaultRules)
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;keystoneAuth{
                        next:              next,
                        resellerPrefixes:  resellerPrefixes,
                        accountRules:      accountRules,
                        resellerAdminRole: strings.ToLower(config.GetDefault("reseller_admin_role", "ResellerAdmin")),
                        defaultDomainID:   config.GetDefault("default_domain_id", "default"),
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file68" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "crypto/md5"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "mime"
        "net/http"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

var maxManifestSize = 1024 * 1024 * 2 // TODO add a check for this
var maxManifestLen = 1000

type segItem struct {
        Hash         string `json:"hash"`
        LastModified string `json:"last_modified"`
        Bytes        int64  `json:"bytes"`
        Name         string `json:"name"`
        ContentType  string `json:"content_type"`
        Range        string `json:"range,omitempty"`
        SubSlo       bool   `json:"sub_slo,omitempty"`
}

func (si segItem) segLenHash() (int64, string) <span class="cov8" title="1">{
        if si.Range != "" </span><span class="cov8" title="1">{
                segRange := si.makeRange()
                return segRange.End - segRange.Start, fmt.Sprintf(
                        "%s:%s;", si.Hash, si.Range)
        }</span>
        <span class="cov8" title="1">return int64(si.Bytes), si.Hash</span>
}

// will return the segment range specified, or a range for the whole body
func (si segItem) makeRange() common.HttpRange <span class="cov8" title="1">{
        if si.Range != "" </span><span class="cov8" title="1">{
                ranges, err := common.ParseRange(fmt.Sprintf("bytes=%s", si.Range), int64(si.Bytes))
                if err == nil &amp;&amp; len(ranges) == 1 </span><span class="cov8" title="1">{
                        return ranges[0]
                }</span>
        }
        <span class="cov8" title="1">return common.HttpRange{Start: 0, End: int64(si.Bytes)}</span>
}

type sloPutManifest struct {
        Path      string `json:"path"`
        Etag      string `json:"etag"`
        SizeBytes int64  `json:"size_bytes"`
        Range     string `json:"range,omitempty"`
}

func splitSegPath(thePath string) (string, string, error) <span class="cov8" title="1">{
        segPathParts := strings.SplitN(strings.TrimLeft(thePath, "/"), "/", 2)
        if len(segPathParts) != 2 || segPathParts[0] == "" || segPathParts[1] == "" </span><span class="cov0" title="0">{
                return "", "", errors.New(fmt.Sprintf("invalid segment path: %s", thePath))
        }</span>
        <span class="cov8" title="1">return segPathParts[0], segPathParts[1], nil</span>
}

type xloIdentifyWriter struct {
        http.ResponseWriter
        funcName string
        status   int
        isSlo    bool
        isDlo    bool
        body     *bytes.Buffer
}

func (sw *xloIdentifyWriter) WriteHeader(status int) <span class="cov8" title="1">{
        sw.status = status
        if theDlo := sw.Header().Get("X-Object-Manifest"); theDlo != "" &amp;&amp; sw.funcName != "get" </span><span class="cov8" title="1">{
                sw.isDlo = true
        }</span>
        <span class="cov8" title="1">if isSlo := sw.Header().Get("X-Static-Large-Object"); isSlo == "True" </span><span class="cov8" title="1">{
                sw.isSlo = true
        }</span>
        <span class="cov8" title="1">if !sw.isSlo &amp;&amp; !sw.isDlo </span><span class="cov8" title="1">{
                sw.ResponseWriter.WriteHeader(status)
                return
        }</span>
        <span class="cov8" title="1">sw.body = bytes.NewBuffer(make([]byte, 0))</span>
}

func (sw *xloIdentifyWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if sw.isDlo </span><span class="cov8" title="1">{
                return len(b), nil
        }</span><span class="cov8" title="1"> else if sw.isSlo </span><span class="cov8" title="1">{
                return sw.body.Write(b)
        }</span><span class="cov8" title="1"> else {
                return sw.ResponseWriter.Write(b)
        }</span>
}

type xloForwardBodyWriter struct {
        http.ResponseWriter
        // If constructed with status != 0 xloForwardBodyWriter will call x.ResponseWriter.WriteHeader.
        status int
        header http.Header
}

func (x *xloForwardBodyWriter) Header() http.Header <span class="cov8" title="1">{
        return x.header
}</span>

func (x *xloForwardBodyWriter) WriteHeader(status int) <span class="cov8" title="1">{
        if x.status != 0 </span><span class="cov8" title="1">{
                if status/100 != 2 </span><span class="cov0" title="0">{
                        x.ResponseWriter.WriteHeader(http.StatusConflict)
                }</span><span class="cov8" title="1"> else {
                        x.ResponseWriter.WriteHeader(x.status)
                }</span>
        }
        <span class="cov8" title="1">x.status = status</span>
}

func (x *xloForwardBodyWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        return x.ResponseWriter.Write(b)
}</span>

type xloCaptureWriter struct {
        status int
        body   []byte
        header http.Header
}

func (x *xloCaptureWriter) Header() http.Header    <span class="cov8" title="1">{ return x.header }</span>
func (x *xloCaptureWriter) WriteHeader(status int) <span class="cov8" title="1">{ x.status = status }</span>
func (x *xloCaptureWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        x.body = append(x.body, b...)
        return len(b), nil
}</span>

func needToRefetchManifest(sw *xloIdentifyWriter, request *http.Request) bool <span class="cov8" title="1">{
        if request.Method == "HEAD" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if request.Header.Get("Range") != "" &amp;&amp; (sw.status == 416) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if request.Header.Get("Range") != "" &amp;&amp; (sw.status == 200 || sw.status == 206) </span><span class="cov8" title="1">{
                re := regexp.MustCompile(`bytes (\d+)-(\d+)/(\d+)$`)
                res := re.FindStringSubmatch(sw.Header().Get("Content-Range"))
                if res == nil || len(res) != 4 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">end, _ := strconv.ParseInt(res[2], 10, 64)
                length, _ := strconv.ParseInt(res[3], 10, 64)
                got_everything := (res[1] == "0" &amp;&amp; end == length-1)
                return !got_everything</span>
        }
        <span class="cov8" title="1">return false</span>
}

type xloMiddleware struct {
        next http.Handler
}

func (xlo *xloMiddleware) feedOutSegments(sw *xloIdentifyWriter, request *http.Request, manifest []segItem, reqRange common.HttpRange, status int) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["account"] == "" </span><span class="cov0" title="0">{
                sw.ResponseWriter.WriteHeader(http.StatusBadRequest)
                ctx.Logger.Error("invalid origReq path", zap.String("path", request.URL.Path), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">writeHeader := true
        for _, si := range manifest </span><span class="cov8" title="1">{
                segLen, _ := si.segLenHash()
                if reqRange.Start &gt;= segLen </span><span class="cov8" title="1">{
                        reqRange.Start -= segLen
                        reqRange.End -= segLen
                        if reqRange.End &lt; 0 </span><span class="cov0" title="0">{
                                if writeHeader </span><span class="cov0" title="0">{
                                        sw.ResponseWriter.WriteHeader(status)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if reqRange.End &lt; 0 </span><span class="cov0" title="0">{
                        if writeHeader </span><span class="cov0" title="0">{
                                sw.ResponseWriter.WriteHeader(status)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">segmentRange := si.makeRange()
                subReqStart := segmentRange.Start
                if reqRange.Start &gt; 0 </span><span class="cov8" title="1">{
                        subReqStart += reqRange.Start
                }</span>
                <span class="cov8" title="1">subReqEnd := segmentRange.End
                if subReqEnd &gt; segmentRange.Start+reqRange.End </span><span class="cov8" title="1">{
                        subReqEnd = segmentRange.Start + reqRange.End
                }</span>
                <span class="cov8" title="1">if subReqEnd &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">container, object, err := splitSegPath(si.Name)
                if err != nil </span><span class="cov0" title="0">{
                        if writeHeader </span><span class="cov0" title="0">{
                                sw.ResponseWriter.WriteHeader(http.StatusConflict)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">newPath := fmt.Sprintf("/v1/%s/%s/%s", pathMap["account"], container, object)
                newReq, err := ctx.newSubrequest("GET", newPath, http.NoBody, request, "slo")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error("error building subrequest", zap.Error(err))
                        if writeHeader </span><span class="cov0" title="0">{
                                sw.ResponseWriter.WriteHeader(http.StatusConflict)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">newReq.Header.Set("Range", fmt.Sprintf("bytes=%d-%d", subReqStart, subReqEnd-1))
                sw2 := &amp;xloForwardBodyWriter{ResponseWriter: sw.ResponseWriter, header: make(http.Header)}
                if writeHeader </span><span class="cov8" title="1">{
                        sw2.status = status
                        writeHeader = false
                }</span>
                <span class="cov8" title="1">ctx.serveHTTPSubrequest(sw2, newReq)
                if sw2.status/100 != 2 </span><span class="cov0" title="0">{
                        ctx.Logger.Debug("segment not found", zap.String("path", newPath),
                                zap.String("Segment404", "404"))
                        break</span>
                }
                <span class="cov8" title="1">reqRange.Start -= segLen
                reqRange.End -= segLen</span>
        }
        <span class="cov8" title="1">if writeHeader </span><span class="cov0" title="0">{
                sw.ResponseWriter.WriteHeader(status)
        }</span>
}

func (xlo *xloMiddleware) buildSloManifest(request *http.Request, manPath string) (manifest []segItem, status int, err error) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        newReq, err := ctx.newSubrequest("GET", fmt.Sprintf("%s?multipart-manifest=get", manPath), http.NoBody, request, "slo")
        if err != nil </span><span class="cov0" title="0">{
                return manifest, http.StatusInternalServerError, err
        }</span>
        <span class="cov8" title="1">swRefetch := &amp;xloCaptureWriter{header: make(http.Header)}
        ctx.serveHTTPSubrequest(swRefetch, newReq)
        if swRefetch.status != 200 &amp;&amp; swRefetch.body == nil </span><span class="cov0" title="0">{
                return nil, swRefetch.status, errors.New("Error fetching manifest")
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(swRefetch.body, &amp;manifest)
        return manifest, http.StatusOK, err</span>
}

func (xlo *xloMiddleware) buildDloManifest(sw *xloIdentifyWriter, request *http.Request, account string, container string, prefix string) (manifest []segItem, status int, err error) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        newReq, err := ctx.newSubrequest("GET", fmt.Sprintf("/v1/%s/%s?format=json&amp;prefix=%s", account, container, prefix), http.NoBody, request, "slo")
        if err != nil </span><span class="cov0" title="0">{
                return manifest, 500, err
        }</span>
        <span class="cov8" title="1">swRefetch := &amp;xloCaptureWriter{header: make(http.Header)}
        ctx.serveHTTPSubrequest(swRefetch, newReq)
        if swRefetch.status != 200 || swRefetch.body == nil </span><span class="cov0" title="0">{
                return nil, swRefetch.status, fmt.Errorf("Error %d fetching manifest", swRefetch.status)
        }</span>
        <span class="cov8" title="1">if err = json.Unmarshal(swRefetch.body, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return manifest, 500, err
        }</span>
        <span class="cov8" title="1">for i := range manifest </span><span class="cov8" title="1">{
                manifest[i].Name = fmt.Sprintf("%s/%s", container, manifest[i].Name)
        }</span>
        <span class="cov8" title="1">return manifest, 200, nil</span>
}

func convertManifest(manifestBytes []byte) ([]byte, error) <span class="cov8" title="1">{
        var savedManifest []segItem
        var putManifest []sloPutManifest
        err := json.Unmarshal(manifestBytes, &amp;savedManifest)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov8" title="1">for _, si := range savedManifest </span><span class="cov8" title="1">{
                putManifest = append(putManifest, sloPutManifest{
                        Path: si.Name, Etag: si.Hash, SizeBytes: si.Bytes, Range: si.Range})
        }</span>
        <span class="cov8" title="1">newBody, err := json.Marshal(putManifest)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov8" title="1">return []byte(newBody), nil</span>
}

func (xlo *xloMiddleware) byteFeeder(sw *xloIdentifyWriter, request *http.Request, xloEtag string, xloContentLengthStr string, manifest []segItem) <span class="cov8" title="1">{
        xloContentLength := int64(0)
        if xloContentLengthStr != "" </span><span class="cov0" title="0">{
                if cl, err := strconv.ParseInt(xloContentLengthStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        xloContentLength = cl
                }</span><span class="cov0" title="0"> else {
                        xloContentLengthStr = ""
                }</span>
        }
        <span class="cov8" title="1">if xloEtag == "" || xloContentLengthStr == "" </span><span class="cov8" title="1">{
                xloEtagGen := md5.New()
                xloContentLengthGen := int64(0)
                for _, si := range manifest </span><span class="cov8" title="1">{
                        segLen, segHash := si.segLenHash()
                        xloContentLengthGen += segLen
                        io.WriteString(xloEtagGen, segHash)
                }</span>
                <span class="cov8" title="1">xloEtag = fmt.Sprintf("%x", xloEtagGen.Sum(nil))
                xloContentLength = xloContentLengthGen</span>
        }
        <span class="cov8" title="1">reqRangeStr := request.Header.Get("Range")
        reqRange := common.HttpRange{Start: 0, End: xloContentLength}
        if reqRangeStr != "" </span><span class="cov8" title="1">{
                if ranges, err := common.ParseRange(reqRangeStr, xloContentLength); err == nil </span><span class="cov8" title="1">{
                        xloContentLength = 0
                        if len(ranges) != 1 </span><span class="cov0" title="0">{
                                sw.ResponseWriter.Header().Set("Content-Range", fmt.Sprintf("bytes */%d", xloContentLength))
                                srv.SimpleErrorResponse(sw.ResponseWriter, http.StatusRequestedRangeNotSatisfiable, "invalid multi range")
                                return
                        }</span>
                        <span class="cov8" title="1">reqRange = ranges[0]
                        xloContentLength += reqRange.End - reqRange.Start</span>
                }<span class="cov0" title="0"> else {
                        sw.ResponseWriter.Header().Set("Content-Range", fmt.Sprintf("bytes */%d", xloContentLength))
                        srv.SimpleErrorResponse(sw.ResponseWriter, http.StatusRequestedRangeNotSatisfiable, "invalid range")
                        return
                }</span>
        }
        <span class="cov8" title="1">if request.Header.Get("If-Match") != "" </span><span class="cov0" title="0">{
                ifMatches := common.ParseIfMatch(request.Header.Get("If-Match"))
                if !ifMatches[strings.Trim(xloEtag, "\"")] </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(sw.ResponseWriter, 412, "")
                        return
                }</span>
        }
        <span class="cov8" title="1">if request.Header.Get("If-None-Match") != "" </span><span class="cov0" title="0">{
                ifNoneMatches := common.ParseIfMatch(request.Header.Get("If-None-Match"))
                if ifNoneMatches[strings.Trim(xloEtag, "\"")] </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(sw.ResponseWriter, 304, "")
                        return
                }</span>
        }
        <span class="cov8" title="1">sw.Header().Set("Content-Length", strconv.FormatInt(xloContentLength, 10))
        sw.Header().Set("Content-Type", sw.Header().Get("Content-Type"))
        sw.Header().Set("Etag", fmt.Sprintf("\"%s\"", xloEtag))
        status := http.StatusOK
        if reqRangeStr != "" </span><span class="cov8" title="1">{
                sw.Header().Set("Content-Range", fmt.Sprintf("%d-%d/%s", reqRange.Start, reqRange.End, xloContentLengthStr))
                status = http.StatusPartialContent
        }</span>
        <span class="cov8" title="1">xlo.feedOutSegments(sw, request, manifest, reqRange, status)</span>
}

func (xlo *xloMiddleware) handleDloGet(sw *xloIdentifyWriter, request *http.Request) <span class="cov8" title="1">{
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["object"] == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, 400, fmt.Sprintf(
                        "invalid must multipath PUT to an object path: %s", request.URL.Path))
                return
        }</span>
        <span class="cov8" title="1">container, prefix, err := splitSegPath(sw.Header().Get("X-Object-Manifest"))
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, 400, "invalid dlo manifest path")
                return
        }</span>
        <span class="cov8" title="1">manifest, status, err := xlo.buildDloManifest(sw, request, pathMap["account"], container, prefix)
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, status,
                        fmt.Sprintf("can not build dlo manifest at: %s?%s", container, prefix))
                return
        }</span>
        <span class="cov8" title="1">xlo.byteFeeder(sw, request, "", "", manifest)</span>
}

func (xlo *xloMiddleware) handleSloGet(sw *xloIdentifyWriter, request *http.Request) <span class="cov8" title="1">{
        // next has already been called and this is an SLO
        //TODO: what does comment at slo.py#624 mean?
        contentType, _, _ := common.ParseContentTypeForSlo(sw.Header().Get("Content-Type"), 0)
        sw.Header().Set("Content-Type", contentType)

        if sw.funcName == "get" </span><span class="cov8" title="1">{
                manifestBytes := sw.body.Bytes()
                var err error
                if request.URL.Query().Get("format") == "raw" </span><span class="cov8" title="1">{
                        manifestBytes, err = convertManifest(manifestBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                srv.SimpleErrorResponse(sw.ResponseWriter, 400, "invalid slo manifest")
                                return
                        }</span>
                }<span class="cov8" title="1"> else {
                        sw.Header().Set("Content-Type", "application/json; charset=utf-8")
                }</span>
                <span class="cov8" title="1">sw.Header().Set("Content-Length", strconv.Itoa(len(manifestBytes)))
                sw.Header().Set("Etag", strings.Trim(sw.Header().Get("Etag"), "\""))
                sw.ResponseWriter.WriteHeader(http.StatusOK)
                sw.ResponseWriter.Write(manifestBytes)
                return</span>
        }
        <span class="cov8" title="1">sloEtag := sw.Header().Get("X-Object-Sysmeta-Slo-Etag")
        savedContentLength := sw.Header().Get("X-Object-Sysmeta-Slo-Size")
        isConditional := ((request.Header.Get("If-Match") != "" ||
                request.Header.Get("If-None-Match") != "") &amp;&amp;
                (sw.status == 304 || sw.status == 412))

        if (request.Method == "HEAD" || isConditional) &amp;&amp; (sloEtag != "" || savedContentLength != "") </span><span class="cov0" title="0">{
                sw.Header().Set("Content-Length", savedContentLength)
                sw.Header().Set("Etag", fmt.Sprintf("\"%s\"", sloEtag))
                sw.ResponseWriter.WriteHeader(sw.status)
                return
        }</span>
        <span class="cov8" title="1">var manifest []segItem
        var status int
        var err error
        manifestBytes := sw.body.Bytes()
        if needToRefetchManifest(sw, request) </span><span class="cov8" title="1">{
                manifest, status, err = xlo.buildSloManifest(request, request.URL.Path)
        }</span><span class="cov8" title="1"> else {
                err = json.Unmarshal(manifestBytes, &amp;manifest)
                status = http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, status, "invalid slo manifest")
                return
        }</span>
        <span class="cov8" title="1">xlo.byteFeeder(sw, request, sloEtag, savedContentLength, manifest)</span>
}

func parsePutSloManifest(body io.ReadCloser) (manifest []sloPutManifest, errs []string) <span class="cov8" title="1">{
        dec := json.NewDecoder(body)
        if d, err := dec.Token(); err != nil </span><span class="cov0" title="0">{
                return manifest, []string{"Invalid manifest json- not a list."}
        }</span><span class="cov8" title="1"> else if r, ok := d.(json.Delim); !ok || r != '[' </span><span class="cov0" title="0">{
                return manifest, []string{"Invalid manifest json- not a list."}
        }</span>
        <span class="cov8" title="1">for i := 0; dec.More(); i++ </span><span class="cov8" title="1">{
                if i &gt; maxManifestLen </span><span class="cov0" title="0">{
                        errs = append(errs, "Invalid manifest json- too many segments")
                        break</span>
                }
                <span class="cov8" title="1">var manItem sloPutManifest
                if err := dec.Decode(&amp;manItem); err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }<span class="cov8" title="1"> else if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, "Invalid manifest json- invalid format.")
                        break</span>
                }
                <span class="cov8" title="1">if strings.Index(strings.TrimLeft(manItem.Path, "/"), "/") == -1 </span><span class="cov0" title="0">{
                        errs = append(errs,
                                fmt.Sprintf("Index %d: path does not refer to an object. Path must be of the form /container/object.", i))
                        continue</span>
                }
                // cant really check this here because you can send size_bytes as None now
                <span class="cov8" title="1">if manItem.SizeBytes &lt; 0 </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("Index %d: too small; each segment must be at least 1 byte.", i))
                        continue</span>
                }
                <span class="cov8" title="1">if manItem.Range != "" </span><span class="cov0" title="0">{
                        if strings.Count(manItem.Range, "-") != 1 </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("Index %d: invalid or multiple ranges (only one allowed)", i))
                                continue</span>
                        }
                }
                <span class="cov8" title="1">manifest = append(manifest, manItem)</span>
        }
        <span class="cov8" title="1">return manifest, errs</span>
}

func (xlo *xloMiddleware) handleSloPut(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["object"] == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, fmt.Sprintf(
                        "invalid must multipath PUT to an object path: %s", request.URL.Path))
                return
        }</span>
        <span class="cov8" title="1">contentLength := request.Header.Get("Content-Length")
        if contentLength == "" &amp;&amp; request.Header.Get("Transfer-Encoding") != "chunked" </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 411)
                return
        }</span>
        <span class="cov8" title="1">if request.Header.Get("X-Copy-From") != "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 405, "Multipart Manifest PUTs cannot be COPY requests")
                return
        }</span>
        <span class="cov8" title="1">manifest, errs := parsePutSloManifest(request.Body)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, strings.Join(errs, "\n"))
                return
        }</span>
        <span class="cov8" title="1">var toPutManifest []segItem
        i := 0
        totalSize := int64(0)
        sloEtag := md5.New()
        ctx := GetProxyContext(request)
        for _, spm := range manifest </span><span class="cov8" title="1">{
                spmContainer, spmObject, err := splitSegPath(spm.Path)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("invalid manifest path: %s", spm.Path))
                        break</span>
                }
                <span class="cov8" title="1">if spmContainer == pathMap["container"] &amp;&amp; spmObject == pathMap["object"] </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("manifest cannot reference itself: %s", spm.Path))
                        break</span>
                }

                <span class="cov8" title="1">newPath := fmt.Sprintf("/v1/%s/%s/%s", pathMap["account"], spmContainer, spmObject)
                newReq, err := ctx.newSubrequest("HEAD", newPath, http.NoBody, request, "slo")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error("Couldn't create http.Request", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">pw := &amp;xloCaptureWriter{header: make(http.Header)}
                ctx.serveHTTPSubrequest(pw, newReq)
                if pw.status != 200 </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("%d %s response on segment: %s", pw.status, http.StatusText(pw.status), newPath))
                        continue</span>
                }
                <span class="cov8" title="1">contentLength, err := strconv.ParseInt(pw.Header().Get("Content-Length"), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("bad content-length on segment: %s", newPath))
                        continue</span>
                }
                <span class="cov8" title="1">segEtag := strings.Trim(pw.Header().Get("Etag"), "\"")
                isSlo := false
                if xslo := pw.Header().Get("X-Static-Large-Object"); xslo == "True" </span><span class="cov0" title="0">{
                        isSlo = true
                }</span>
                <span class="cov8" title="1">if spm.SizeBytes &gt; 0 &amp;&amp; contentLength != spm.SizeBytes </span><span class="cov0" title="0">{
                        errs = append(errs,
                                fmt.Sprintf("Unmatching ContentLength (manifest %d) != (segment actual %d) response on segment: %s", spm.SizeBytes, contentLength, newPath))
                        continue</span>
                }
                <span class="cov8" title="1">segmentSize := contentLength
                parsedRange := spm.Range
                if spm.Range != "" </span><span class="cov0" title="0">{
                        ranges, err := common.ParseRange(fmt.Sprintf("bytes=%s", spm.Range), contentLength)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs,
                                        fmt.Sprintf("Index %d: invalid range", i))
                                continue</span>
                        }
                        <span class="cov0" title="0">if len(ranges) != 1 </span><span class="cov0" title="0">{
                                errs = append(errs,
                                        fmt.Sprintf("Index %d:  multiple ranges (only one allowed)", i))
                                continue</span>
                        }
                        <span class="cov0" title="0">segmentSize = int64(ranges[0].End - ranges[0].Start)
                        parsedRange = fmt.Sprintf("%d-%d", ranges[0].Start, ranges[0].End-1)</span> // why -1? because...
                }
                <span class="cov8" title="1">totalSize += segmentSize
                if spm.Etag != "" &amp;&amp; spm.Etag != segEtag </span><span class="cov0" title="0">{
                        errs = append(errs,
                                fmt.Sprintf("Etag Mismatch on %s: %s != %s", spm.Path, spm.Etag, segEtag))
                        continue</span>
                }
                <span class="cov8" title="1">lastModDate, _ := common.ParseDate(pw.Header().Get("Last-Modified"))

                contentType, _, _ := common.ParseContentTypeForSlo(pw.Header().Get("Content-Type"), 0)
                newSi := segItem{Name: spm.Path, Bytes: contentLength,
                        Hash: segEtag, Range: parsedRange, SubSlo: isSlo,
                        ContentType:  contentType,
                        LastModified: lastModDate.Format("2006-01-02T15:04:05.00000")}
                _, newSiHash := newSi.segLenHash()
                io.WriteString(sloEtag, newSiHash)
                toPutManifest = append(toPutManifest, newSi)</span>
        }
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, strings.Join(errs, "\n"))
                return
        }</span>
        <span class="cov8" title="1">xloEtagGen := fmt.Sprintf("%x", sloEtag.Sum(nil))
        if reqEtag := request.Header.Get("Etag"); reqEtag != "" </span><span class="cov0" title="0">{
                if strings.Trim(reqEtag, "\"") != xloEtagGen </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, 422, "Invalid Etag")
                        return
                }</span>
        }
        <span class="cov8" title="1">contentType := request.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                pathMap, _ := common.ParseProxyPath(request.URL.Path)
                contentType = mime.TypeByExtension(filepath.Ext(pathMap["object"]))
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
        }
        <span class="cov8" title="1">newBody, err := json.Marshal(toPutManifest)
        putReq, err := ctx.newSubrequest("PUT", request.URL.Path, bytes.NewReader(newBody), request, "slo")
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Creating new request", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for k := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, "X-Object-Meta-") </span><span class="cov0" title="0">{
                        putReq.Header.Set(k, request.Header.Get(k))
                }</span>
        }
        <span class="cov8" title="1">putReq.Header.Set("Content-Type", fmt.Sprintf("%s;swift_bytes=%d", contentType, totalSize))
        putReq.Header.Set("X-Static-Large-Object", "True")
        putReq.Header.Set("X-Object-Sysmeta-Slo-Etag", xloEtagGen)
        putReq.Header.Set("X-Object-Sysmeta-Slo-Size", fmt.Sprintf("%d", totalSize))
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, "could not build slo manifest")
                return
        }</span>
        <span class="cov8" title="1">putReq.Header.Set("Etag", fmt.Sprintf("%x", md5.Sum(newBody)))
        putReq.Header.Set("Content-Length", strconv.Itoa(len(newBody)))
        if request.Header.Get("If-None-Match") != "" </span><span class="cov0" title="0">{
                putReq.Header.Set("If-None-Match", request.Header.Get("If-None-Match"))
        }</span>
        <span class="cov8" title="1">ctx.serveHTTPSubrequest(writer, putReq)
        return</span>
}

func (xlo *xloMiddleware) deleteAllSegments(w http.ResponseWriter, request *http.Request, manifest []segItem) error <span class="cov8" title="1">{
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["account"] == "" </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("invalid path to slo delete: %s", request.URL.Path))
        }</span>
        <span class="cov8" title="1">ctx := GetProxyContext(request)
        for _, si := range manifest </span><span class="cov8" title="1">{
                container, object, err := splitSegPath(si.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("invalid slo item: %s", si.Name))
                }</span>
                <span class="cov8" title="1">newPath := fmt.Sprintf("/v1/%s/%s/%s?multipart-manifest=delete", pathMap["account"], container, object)
                newReq, err := ctx.newSubrequest("DELETE", newPath, http.NoBody, request, "slo")
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("error building subrequest: %s", err))
                }</span>
                <span class="cov8" title="1">sw := &amp;xloCaptureWriter{header: make(http.Header)}
                ctx.serveHTTPSubrequest(sw, newReq)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (xlo *xloMiddleware) handleSloDelete(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["object"] == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, fmt.Sprintf(
                        "invalid must multipath DELETE to an object path: %s", request.URL.Path))
                return
        }</span>
        <span class="cov8" title="1">manifest, status, err := xlo.buildSloManifest(request, request.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, status, fmt.Sprintf("invalid manifest json: %d %s", status, err))
                return
        }</span>
        <span class="cov8" title="1">if err = xlo.deleteAllSegments(writer, request, manifest); err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, fmt.Sprintf("error deleting slo: %s", err))
                return
        }</span>
        <span class="cov8" title="1">xlo.next.ServeHTTP(writer, request)
        return</span>
}

func updateEtagIsAt(request *http.Request, etagLoc string) <span class="cov8" title="1">{
        curHeader := request.Header.Get("X-Backend-Etag-Is-At")
        if curHeader == "" </span><span class="cov8" title="1">{
                curHeader = etagLoc
        }</span><span class="cov0" title="0"> else {
                curHeader = fmt.Sprintf("%s,%s", curHeader, etagLoc)
        }</span>
        <span class="cov8" title="1">request.Header.Set("X-Backend-Etag-Is-At", curHeader)</span>
}

func isValidDloHeader(manifest string) bool <span class="cov0" title="0">{
        if !strings.HasPrefix(manifest, "/") &amp;&amp;
                strings.Index(manifest, "?") == -1 &amp;&amp;
                strings.Index(manifest, "&amp;") == -1 </span><span class="cov0" title="0">{
                m := strings.SplitN(manifest, "/", 2)
                if len(m) == 2 &amp;&amp; m[0] != "" &amp;&amp; m[1] != "" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (xlo *xloMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        xloFuncName := request.URL.Query().Get("multipart-manifest")
        if request.Method == "PUT" &amp;&amp; request.Header.Get("X-Object-Manifest") != "" </span><span class="cov0" title="0">{
                if !isValidDloHeader(request.Header.Get("X-Object-Manifest")) </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, 400, fmt.Sprintf(
                                "X-Object-Manifest must be in the format container/prefix"))
                        return
                }</span>
                <span class="cov0" title="0">if xloFuncName == "put" </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, 400, fmt.Sprintf("Cannot be both SLO and DLO"))
                        return
                }</span>
        }
        <span class="cov8" title="1">if request.Method == "PUT" &amp;&amp; xloFuncName == "put" </span><span class="cov8" title="1">{
                xlo.handleSloPut(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if request.Method == "DELETE" &amp;&amp; xloFuncName == "delete" </span><span class="cov8" title="1">{
                xlo.handleSloDelete(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if request.Method == "GET" || request.Method == "HEAD" </span><span class="cov8" title="1">{
                if xloFuncName != "get" </span><span class="cov8" title="1">{
                        updateEtagIsAt(request, "X-Object-Sysmeta-Slo-Etag")
                }</span>
                <span class="cov8" title="1">sw := &amp;xloIdentifyWriter{ResponseWriter: writer, funcName: xloFuncName}
                xlo.next.ServeHTTP(sw, request)
                if sw.isSlo </span><span class="cov8" title="1">{
                        xlo.handleSloGet(sw, request)
                }</span><span class="cov8" title="1"> else if sw.isDlo </span><span class="cov8" title="1">{
                        xlo.handleDloGet(sw, request)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov0" title="0">xlo.next.ServeHTTP(writer, request)</span>
}

func NewXlo(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("slo", map[string]interface{}{"max_manifest_segments": 1000, "max_manifest_size": 2097152, "min_segment_size": 1048576})
        RegisterInfo("dlo", map[string]interface{}{"max_segments": 10000})
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;xloMiddleware{next: next}
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file69" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "go.uber.org/zap"
)

func NewRequestLogger(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(
                        func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                                start := time.Now()
                                next.ServeHTTP(writer, request)
                                ctx := GetProxyContext(request)
                                _, status := ctx.Response()
                                ctx.Logger.Info("Request log",
                                        zap.String("remoteAddr", request.RemoteAddr),
                                        zap.String("eventTime", time.Now().Format("02/Jan/2006:15:04:05 -0700")),
                                        zap.String("method", request.Method),
                                        zap.String("urlPath", common.Urlencode(request.URL.Path)),
                                        zap.Int("status", status),
                                        zap.String("contentLength", common.GetDefault(writer.Header(), "Content-Length", "-")),
                                        zap.String("referer", common.GetDefault(request.Header, "Referer", "-")),
                                        zap.String("userAgent", common.GetDefault(request.Header, "User-Agent", "-")),
                                        zap.Float64("requestTimeSeconds", time.Since(start).Seconds()))
                        }</span>,
                )
        }, nil
}
</pre>
		
		<pre class="file" id="file70" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "strconv"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

type mrw struct {
        io.Writer
        header http.Header
        err    error
}

func (w *mrw) WriteHeader(int)     <span class="cov8" title="1">{}</span>
func (w *mrw) Header() http.Header <span class="cov8" title="1">{ return w.header }</span>

func firstRange(rangeHeader string) string <span class="cov8" title="1">{
        rangeHeader = strings.Replace(strings.ToLower(rangeHeader), " ", "", -1)
        if !strings.HasPrefix(rangeHeader, "bytes=") </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">rangeHeader = rangeHeader[6:]
        return "bytes=" + strings.Split(rangeHeader, ",")[0]</span>
}

func multirange(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                rangeHeader := request.Header.Get("Range")
                if request.Method != "GET" || rangeHeader == "" || !strings.Contains(rangeHeader, ",") </span><span class="cov8" title="1">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">if apiReq, _, _, object := getPathParts(request); !apiReq || object == "" </span><span class="cov0" title="0">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">var ranges []common.HttpRange

                ctx := GetProxyContext(request)
                var contentLength int64
                var contentType string
                var mw *common.MultiWriter

                subreq, err := ctx.newSubrequest("GET", request.URL.Path, nil, request, "multirange")
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 500)
                        return
                }</span>
                <span class="cov8" title="1">subreq.Header.Set("Range", firstRange(rangeHeader))

                uw := &amp;mrw{Writer: ioutil.Discard, header: make(http.Header)}
                subw := srv.NewCustomWriter(uw, func(w http.ResponseWriter, status int) int </span><span class="cov8" title="1">{
                        if status != http.StatusPartialContent </span><span class="cov8" title="1">{
                                uw.err = fmt.Errorf("Bad status code %d", status)
                                uw.Writer = writer
                                for k := range uw.header </span><span class="cov8" title="1">{
                                        writer.Header().Set(k, uw.header.Get(k))
                                }</span>
                                <span class="cov8" title="1">writer.WriteHeader(status)
                                return status</span>
                        }
                        <span class="cov8" title="1">contentType = uw.header.Get("Content-Type")
                        rspRange := uw.header.Get("Content-Range")
                        rrp := strings.Split(rspRange, "/")
                        if contentLength, err = strconv.ParseInt(rrp[len(rrp)-1], 10, 64); err != nil </span><span class="cov0" title="0">{
                                uw.err = fmt.Errorf("Error parsing content-length from response")
                                writer.Header().Set("Content-Range", uw.header.Get("Content-Range"))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return http.StatusInternalServerError
                        }</span>
                        <span class="cov8" title="1">if ranges, err = common.ParseRange(rangeHeader, contentLength); err != nil </span><span class="cov0" title="0">{
                                uw.err = fmt.Errorf("Error parsing multiple ranges from request")
                                writer.Header().Set("Content-Range", fmt.Sprintf("bytes */%d", contentLength))
                                srv.StandardResponse(writer, http.StatusRequestedRangeNotSatisfiable)
                                return http.StatusRequestedRangeNotSatisfiable
                        }</span>
                        <span class="cov8" title="1">mw = common.NewMultiWriter(writer, contentType, contentLength)
                        for _, rng := range ranges </span><span class="cov8" title="1">{
                                mw.Expect(rng.Start, rng.End)
                        }</span>
                        <span class="cov8" title="1">writer.Header().Set("Content-Length", strconv.FormatInt(mw.ContentLength(), 10))
                        writer.Header().Set("Content-Type", "multipart/byteranges;boundary="+mw.Boundary())
                        writer.WriteHeader(http.StatusPartialContent)

                        part, err := mw.CreatePart(ranges[0].Start, ranges[0].End)
                        if err != nil </span><span class="cov0" title="0">{
                                uw.err = err
                        }</span><span class="cov8" title="1"> else {
                                uw.Writer = part
                        }</span>
                        <span class="cov8" title="1">return status</span>
                })
                <span class="cov8" title="1">if ctx.serveHTTPSubrequest(subw, subreq); uw.err != nil </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">for _, rng := range ranges[1:] </span><span class="cov8" title="1">{
                        if subreq, err = ctx.newSubrequest("GET", request.URL.Path, nil, request, "multirange"); err != nil </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 500)
                                return
                        }</span>
                        <span class="cov8" title="1">subreq.Header.Set("Range", fmt.Sprintf("bytes=%d-%d", rng.Start, rng.End-1))
                        if err != nil </span><span class="cov0" title="0">{
                                return // we just can't complete this request
                        }</span>
                        <span class="cov8" title="1">uw := &amp;mrw{Writer: ioutil.Discard, header: make(http.Header)}
                        subw := srv.NewCustomWriter(uw, func(w http.ResponseWriter, status int) int </span><span class="cov8" title="1">{
                                part, err := mw.CreatePart(rng.Start, rng.End)
                                if err != nil </span><span class="cov0" title="0">{
                                        uw.err = err
                                }</span><span class="cov8" title="1"> else if status != http.StatusPartialContent </span><span class="cov0" title="0">{
                                        uw.err = fmt.Errorf("Bad status code %d", status)
                                }</span><span class="cov8" title="1"> else {
                                        uw.Writer = part
                                }</span>
                                <span class="cov8" title="1">return status</span>
                        })
                        <span class="cov8" title="1">if ctx.serveHTTPSubrequest(subw, subreq); uw.err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">mw.Close()</span>
        })
}

// NewMultirange returns an instance of the multirange middleware with the given config.
//
// This middleware intercepts object GET requests with multiple ranges in the Range header and
// turns them into separate single-range requests on the backend, combining them into a multipart
// response.  This should simplify the implementation of things like xLO and the object server.
func NewMultirange(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov8" title="1">{
        return multirange, nil
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

const rateBuffer = int64(5 * time.Second)
const maxSleep = int64(60 * time.Second)
const nsPerSecond = int64(1000000000)

var writeMethods = map[string]bool{"PUT": true, "DELETE": true, "POST": true}

// will sleep on write requests if the client starts to exceed the
// specified rate. The maximum rate allowed per sec is only as
// accurate as the clocks in the proxy layer- meaning if your clocks
// are accurate to 1/100 of a second then the max reliable rate/sec
// you can set is 100/sec.

type ratelimiter struct {
        accountLimit   int64
        containerLimit int64
        next           http.Handler
}

var sleep = func(s time.Duration) <span class="cov0" title="0">{
        time.Sleep(s)
}</span>

var nowNano = func() int64 <span class="cov0" title="0">{
        return time.Now().UnixNano()
}</span>

// returns int64 of ns to sleep before serving request
func (r *ratelimiter) getSleepTime(mc ring.MemcacheRing, key string, ratePs int64) (int64, error) <span class="cov8" title="1">{
        nsPerRequest := nsPerSecond / ratePs
        runningTime, err := mc.Incr(key, nsPerRequest, 3600)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">sleepTime := int64(0)
        now := nowNano()
        if int64(now-runningTime) &gt; rateBuffer </span><span class="cov8" title="1">{
                // nothing has happened in a while, set new clocktime
                mc.Set(key, now+nsPerRequest, 3600)
        }</span><span class="cov8" title="1"> else {
                sleepTime = runningTime - now - nsPerRequest
                if sleepTime &lt; 0 </span><span class="cov0" title="0">{
                        sleepTime = 0
                }</span>
        }
        <span class="cov8" title="1">return sleepTime, nil</span>
}

func (r *ratelimiter) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        isWrite := writeMethods[request.Method]
        pathParts, err := common.ParseProxyPath(request.URL.Path)
        if !isWrite || err != nil || pathParts["container"] == "" </span><span class="cov0" title="0">{
                r.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov0" title="0">ctx := GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                ctx.Logger.Debug("Error ratelimiter getting ctx")
                return
        }</span>
        <span class="cov0" title="0">limit := int64(0)
        var ratekey string
        if pathParts["object"] == "" </span><span class="cov0" title="0">{
                ratekey = fmt.Sprintf(
                        "ratelimit/%s", pathParts["account"])
                limit = r.accountLimit
        }</span><span class="cov0" title="0"> else {
                ratekey = fmt.Sprintf(
                        "ratelimit/%s/%s", pathParts["account"], pathParts["container"])
                limit = r.containerLimit
        }</span>
        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                sleepTime, err := r.getSleepTime(ctx.Cache, ratekey, limit)
                if err == nil </span><span class="cov0" title="0">{
                        if sleepTime &gt; maxSleep </span><span class="cov0" title="0">{
                                sleep(time.Second)
                                srv.StandardResponse(writer, 498)
                                return
                        }</span>
                        <span class="cov0" title="0">sleep(time.Duration(sleepTime))</span>
                }<span class="cov0" title="0"> else {
                        if ctx := GetProxyContext(request); ctx != nil </span><span class="cov0" title="0">{
                                ctx.Logger.Debug("Ratelimiter errored while getting sleep time", zap.Error(err))
                        }</span>
                }
        }
        <span class="cov0" title="0">r.next.ServeHTTP(writer, request)</span>
}

func NewRatelimiter(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{

        accLimit := int64(config.GetInt("account_db_max_writes_per_sec", 0))
        contLimit := int64(config.GetInt("container_db_max_writes_per_sec", 0))
        //TODO: add account metadata global-write-ratelimit ratelimiter
        RegisterInfo("ratelimit", map[string]interface{}{"account_ratelimit": accLimit, "container_ratelimits": [][]int64{{contLimit}}, "max_sleep_time_seconds": float64(60.0)})
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;ratelimiter{
                        accountLimit:   accLimit,
                        containerLimit: contLimit,
                        next:           next,
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file72" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html"
        "io"
        "math"
        "net/http"
        "net/http/httptest"
        "net/url"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

func NewStaticWeb(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("staticweb", map[string]interface{}{})
        return staticWeb, nil
}</span>

func staticWeb(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                (&amp;staticWebHandler{next: next}).ServeHTTP(writer, request)
        }</span>)
}

type staticWebHandler struct {
        next             http.Handler
        ctx              *ProxyContext
        account          string
        container        string
        object           string
        webIndex         string
        webError         string
        webListings      bool
        webListingsLabel string
        webListingsCSS   string
        webDirType       string
}

func (s *staticWebHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if request.Method != "GET" &amp;&amp; request.Method != "HEAD" </span><span class="cov0" title="0">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">s.ctx = GetProxyContext(request)
        if s.ctx.Source == "staticweb" </span><span class="cov8" title="1">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if len(s.ctx.RemoteUsers) != 0 &amp;&amp; !common.LooksTrue(request.Header.Get("X-Web-Mode")) </span><span class="cov0" title="0">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">var apiReq bool
        apiReq, s.account, s.container, s.object = getPathParts(request)
        if !apiReq || s.account == "" || s.container == "" </span><span class="cov0" title="0">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">ci, err := s.ctx.C.GetContainerInfo(s.account, s.container)
        if err != nil </span><span class="cov8" title="1">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">s.webIndex = strings.TrimSpace(ci.Metadata["Web-Index"])
        s.webError = strings.TrimSpace(ci.Metadata["Web-Error"])
        s.webListings = common.LooksTrue(strings.TrimSpace(ci.Metadata["Web-Listings"]))
        s.webListingsLabel = strings.TrimSpace(ci.Metadata["Web-Listings-Label"])
        s.webListingsCSS = strings.TrimSpace(ci.Metadata["Web-Listings-Css"])
        s.webDirType = strings.TrimSpace(ci.Metadata["Web-Directory-Type"])
        if s.webDirType == "" </span><span class="cov8" title="1">{
                s.webDirType = "application/directory"
        }</span>
        <span class="cov8" title="1">if s.object != "" </span><span class="cov8" title="1">{
                s.handleObject(writer, request)
                return
        }</span>
        <span class="cov8" title="1">s.ctx.ACL = ci.ReadACL
        if s.ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, st := s.ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, st)
                        return
                }</span>
        }
        <span class="cov8" title="1">s.handleDirectory(writer, request)</span>
}

func (s *staticWebHandler) handleObject(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        subreq, err := s.ctx.newSubrequest("HEAD", request.URL.Path, nil, request, "staticweb")
        if err != nil </span><span class="cov0" title="0">{
                s.handleError(writer, request, http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">subrec := httptest.NewRecorder()
        s.ctx.serveHTTPSubrequest(subrec, subreq)
        subresp := subrec.Result()
        if subresp.StatusCode &gt;= 200 &amp;&amp; subresp.StatusCode &lt;= 399 </span><span class="cov8" title="1">{
                if subresp.Header.Get("Content-Type") == s.webDirType &amp;&amp; subresp.ContentLength &lt;= 1 </span><span class="cov0" title="0">{
                        s.handleDirectory(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">s.next.ServeHTTP(writer, request)
                return</span>
        }
        <span class="cov8" title="1">if subresp.StatusCode != http.StatusNotFound </span><span class="cov8" title="1">{
                s.handleError(writer, request, subresp.StatusCode, nil)
                return
        }</span>
        <span class="cov8" title="1">s.handleDirectory(writer, request)</span>
}

func (s *staticWebHandler) handleDirectory(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if s.webIndex == "" &amp;&amp; !s.webListings </span><span class="cov8" title="1">{
                if common.LooksTrue(request.Header.Get("X-Web-Mode")) </span><span class="cov8" title="1">{
                        s.handleError(writer, request, http.StatusNotFound, nil)
                        return
                }</span>
                <span class="cov0" title="0">s.next.ServeHTTP(writer, request)
                return</span>
        }
        <span class="cov8" title="1">if !strings.HasSuffix(request.URL.Path, "/") </span><span class="cov8" title="1">{
                if s.webIndex != "" </span><span class="cov8" title="1">{
                        subreq, err := s.ctx.newSubrequest("HEAD", request.URL.Path+"/"+s.webIndex, nil, request, "staticweb")
                        if err != nil </span><span class="cov0" title="0">{
                                s.handleError(writer, request, http.StatusInternalServerError, err)
                                return
                        }</span>
                        <span class="cov8" title="1">subrec := httptest.NewRecorder()
                        s.ctx.serveHTTPSubrequest(subrec, subreq)
                        subresp := subrec.Result()
                        if subresp.StatusCode &gt;= 200 &amp;&amp; subresp.StatusCode &lt;= 399 </span><span class="cov8" title="1">{
                                writer.Header().Set("Location", request.URL.Path+"/")
                                srv.StandardResponse(writer, http.StatusMovedPermanently)
                                return
                        }</span>
                }
                <span class="cov8" title="1">if s.webListings </span><span class="cov8" title="1">{
                        if s.object == "" </span><span class="cov8" title="1">{
                                writer.Header().Set("Location", request.URL.Path+"/")
                                srv.StandardResponse(writer, http.StatusMovedPermanently)
                                return
                        }</span>
                        <span class="cov8" title="1">subreq, err := s.ctx.newSubrequest("GET", fmt.Sprintf("/v1/%s/%s?limit=1&amp;format=json&amp;delimiter=/&amp;prefix=%s/", url.PathEscape(s.account), url.PathEscape(s.container), url.QueryEscape(s.object)), nil, request, "staticweb")
                        if err != nil </span><span class="cov0" title="0">{
                                s.handleError(writer, request, http.StatusInternalServerError, err)
                                return
                        }</span>
                        <span class="cov8" title="1">subrec := httptest.NewRecorder()
                        s.ctx.serveHTTPSubrequest(subrec, subreq)
                        subresp := subrec.Result()
                        if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                                s.handleError(writer, request, subresp.StatusCode, nil)
                                return
                        }</span>
                        <span class="cov8" title="1">listing := make([]struct{}, 0)
                        if err = json.NewDecoder(subresp.Body).Decode(&amp;listing); err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        s.handleError(writer, request, http.StatusNotFound, err)
                                }</span><span class="cov0" title="0"> else {
                                        s.handleError(writer, request, http.StatusInternalServerError, err)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov8" title="1">if len(listing) == 0 </span><span class="cov8" title="1">{
                                s.handleError(writer, request, http.StatusNotFound, nil)
                                return
                        }</span>
                        <span class="cov8" title="1">writer.Header().Set("Location", request.URL.Path+"/")
                        srv.StandardResponse(writer, http.StatusMovedPermanently)
                        return</span>
                }
                <span class="cov0" title="0">s.handleError(writer, request, http.StatusNotFound, nil)
                return</span>
        }
        <span class="cov8" title="1">if s.webIndex != "" </span><span class="cov8" title="1">{
                subreq, err := s.ctx.newSubrequest("HEAD", request.URL.Path+s.webIndex, nil, request, "staticweb")
                if err != nil </span><span class="cov0" title="0">{
                        s.handleError(writer, request, http.StatusInternalServerError, err)
                        return
                }</span>
                <span class="cov8" title="1">subrec := httptest.NewRecorder()
                s.ctx.serveHTTPSubrequest(subrec, subreq)
                subresp := subrec.Result()
                if subresp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                        subreq, err := s.ctx.newSubrequest(request.Method, request.URL.Path+s.webIndex, request.Body, request, "staticweb")
                        if err != nil </span><span class="cov0" title="0">{
                                s.handleError(writer, request, http.StatusInternalServerError, err)
                                return
                        }</span>
                        <span class="cov8" title="1">for k, v := range request.Header </span><span class="cov0" title="0">{
                                subreq.Header[k] = v
                        }</span>
                        <span class="cov8" title="1">s.ctx.serveHTTPSubrequest(writer, subreq)
                        return</span>
                }<span class="cov8" title="1"> else if subresp.StatusCode != http.StatusNotFound </span><span class="cov0" title="0">{
                        s.handleError(writer, request, subresp.StatusCode, nil)
                        return
                }</span>
        }
        <span class="cov8" title="1">label := request.URL.Path
        if s.webListingsLabel != "" </span><span class="cov0" title="0">{
                label = s.webListingsLabel + "/" + s.object
        }</span>
        <span class="cov8" title="1">css := defaultCSS
        if s.webListingsCSS != "" </span><span class="cov8" title="1">{
                path := s.webListingsCSS
                if !strings.HasPrefix(s.webListingsCSS, "/") &amp;&amp; !strings.HasPrefix(s.webListingsCSS, "http://") &amp;&amp; !strings.HasPrefix(s.webListingsCSS, "https://") </span><span class="cov8" title="1">{
                        path = ""
                        for i := strings.Count(s.webListingsCSS, "/"); i &gt; 0; i-- </span><span class="cov0" title="0">{
                                path += "../"
                        }</span>
                        <span class="cov8" title="1">path += s.webListingsCSS</span>
                }
                <span class="cov8" title="1">css = fmt.Sprintf(`&lt;link rel="stylesheet" type="text/css" href="%s" /&gt;`, path)</span>
        }
        <span class="cov8" title="1">if !s.webListings </span><span class="cov8" title="1">{
                webIndexNote := ""
                if s.webIndex != "" </span><span class="cov8" title="1">{
                        webIndexNote = fmt.Sprintf(webIndexNoteHTML, html.EscapeString(s.webIndex))
                }</span>
                <span class="cov8" title="1">body := fmt.Sprintf(disabledListingHTML, html.EscapeString(label), css, webIndexNote)
                writer.Header().Set("Content-Type", "text/html")
                writer.Header().Set("Content-Length", fmt.Sprintf("%d", len(body)))
                writer.WriteHeader(http.StatusNotFound)
                writer.Write([]byte(body))
                return</span>
        }
        <span class="cov8" title="1">listingPath := fmt.Sprintf("/v1/%s/%s?format=json&amp;delimiter=/", url.PathEscape(s.account), url.PathEscape(s.container))
        if s.object != "" </span><span class="cov8" title="1">{
                listingPath += fmt.Sprintf("&amp;prefix=%s", url.QueryEscape(s.object))
        }</span>
        <span class="cov8" title="1">subreq, err := s.ctx.newSubrequest("GET", listingPath, nil, request, "staticweb")
        if err != nil </span><span class="cov0" title="0">{
                s.handleError(writer, request, http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">subrec := httptest.NewRecorder()
        s.ctx.serveHTTPSubrequest(subrec, subreq)
        subresp := subrec.Result()
        if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                s.handleError(writer, request, subresp.StatusCode, nil)
                return
        }</span>
        <span class="cov8" title="1">type entry struct {
                Name         string `json:"name"`
                ContentType  string `json:"content_type"`
                Bytes        int    `json:"bytes"`
                LastModified string `json:"last_modified"`
                Subdir       string `json:"subdir"`
        }
        listing := make([]*entry, 0)
        if err = json.NewDecoder(subresp.Body).Decode(&amp;listing); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        s.handleError(writer, request, http.StatusNotFound, err)
                }</span><span class="cov0" title="0"> else {
                        s.handleError(writer, request, http.StatusInternalServerError, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1">if len(listing) == 0 </span><span class="cov0" title="0">{
                s.handleError(writer, request, http.StatusNotFound, nil)
                return
        }</span>
        <span class="cov8" title="1">var body bytes.Buffer
        fmt.Fprintf(&amp;body, preambleListingHTML, html.EscapeString(label), css, html.EscapeString(label))
        if s.object != "" </span><span class="cov8" title="1">{
                body.WriteString(`&lt;tr id="parent" class="item"&gt;&lt;td class="colname"&gt;&lt;a href="../"&gt;../&lt;/a&gt;&lt;/td&gt;&lt;td class="colsize"&gt;&amp;nbsp;&lt;/td&gt;&lt;td class="coldate"&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;`)
        }</span>
        <span class="cov8" title="1">for _, e := range listing </span><span class="cov8" title="1">{
                if e.Subdir == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">p := strings.TrimPrefix(e.Subdir, s.object)
                fmt.Fprintf(&amp;body, `&lt;tr class="item subdir"&gt;&lt;td class="colname"&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td class="colsize"&gt;&amp;nbsp;&lt;/td&gt;&lt;td class="coldate"&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;`, html.EscapeString(p), html.EscapeString(p))</span>
        }
        <span class="cov8" title="1">for _, e := range listing </span><span class="cov8" title="1">{
                if e.Subdir != "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">var c []string
                for _, s := range strings.Split(strings.ToLower(e.ContentType), "/") </span><span class="cov8" title="1">{
                        c = append(c, "type-"+s)
                }</span>
                <span class="cov8" title="1">p := strings.TrimPrefix(e.Name, s.object)
                m := strings.Replace(strings.Split(e.LastModified, ".")[0], "T", " ", 1)
                fmt.Fprintf(&amp;body, `&lt;tr class="item %s"&gt;&lt;td class="colname"&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td class="colsize"&gt;%s&lt;/td&gt;&lt;td class="coldate"&gt;%s&lt;/td&gt;&lt;/tr&gt;`, html.EscapeString(strings.Join(c, " ")), html.EscapeString(p), html.EscapeString(p), humanReadable(e.Bytes), html.EscapeString(m))</span>
        }
        <span class="cov8" title="1">body.WriteString(`&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;`)
        writer.Header().Set("Content-Type", "text/html")
        writer.Header().Set("Content-Length", fmt.Sprintf("%d", body.Len()))
        writer.WriteHeader(http.StatusOK)
        writer.Write(body.Bytes())</span>
}

const defaultCSS string = `
&lt;style type="text/css"&gt;
    h1 {font-size: 1em; font-weight: bold;}
    th {text-align: left; padding: 0px 1em 0px 1em;}
    td {padding: 0px 1em 0px 1em;}
    p {font-size: 2}
    a {text-decoration: none;}
&lt;/style&gt;
`

const disabledListingHTML string = `&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Listing of %s&lt;/title&gt;
        %s
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Web Listing Disabled&lt;/h1&gt;
        &lt;p&gt;The owner of this web site has disabled web listing.&lt;/p&gt;
        &lt;p&gt;If you are the owner of this web site, you can enableweb listing by setting X-Container-Meta-Web-Listings.&lt;/p&gt;
        %s
    &lt;/body&gt;
&lt;/html&gt;
`

const webIndexNoteHTML string = `
&lt;h1&gt;Index File Not Found&lt;/h1&gt;
&lt;p&gt;The owner of this web site has set &lt;b&gt;X-Container-Meta-Web-Index: %s&lt;/b&gt;. However, this file was not found.&lt;/p&gt;
`

const preambleListingHTML string = `&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Listing of %s&lt;/title&gt;
        %s
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1 id="title"&gt;Listing of %s&lt;/h1&gt;
        &lt;table id="listing"&gt;
            &lt;tr id="heading"&gt;
                &lt;th class="colname"&gt;Name&lt;/th&gt;
                &lt;th class="colsize"&gt;Size&lt;/th&gt;
                &lt;th class="coldate"&gt;Date&lt;/th&gt;
            &lt;/tr&gt;
`

func humanReadable(value int) string <span class="cov8" title="1">{
        v := float64(value)
        i := -1
        suffixes := "KMGTPEZY"
        for v &gt;= 1024 &amp;&amp; i+1 &lt; len(suffixes) </span><span class="cov0" title="0">{
                i += 1
                v = math.Floor(v/1024 + .5)
        }</span>
        <span class="cov8" title="1">if i == -1 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d", int(v))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d%ci", int(v), suffixes[i])</span>
}

func (s *staticWebHandler) handleError(writer http.ResponseWriter, request *http.Request, status int, err error) <span class="cov8" title="1">{
        if s.webError == "" </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, status)
                return
        }</span>
        <span class="cov8" title="1">subreq, err := s.ctx.newSubrequest("GET", fmt.Sprintf("/v1/%s/%s/%d%s", url.PathEscape(s.account), url.PathEscape(s.container), status, s.webError), nil, request, "staticweb")
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, status)
                return
        }</span>
        <span class="cov8" title="1">subrec := httptest.NewRecorder()
        s.ctx.serveHTTPSubrequest(subrec, subreq)
        subresp := subrec.Result()
        defer subresp.Body.Close()
        if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, status)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", subresp.Header.Get("Content-Type"))
        writer.Header().Set("Content-Length", subresp.Header.Get("Content-Length"))
        writer.WriteHeader(status)
        io.Copy(writer, subresp.Body)</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

type testUser struct {
        Account   string
        Username  string
        Password  string
        Roles     []string
        Url       string
        AccountID string
}

type tempAuth struct {
        testUsers    []testUser
        resellers    []string
        reseller     string
        accountRules map[string]map[string][]string
        next         http.Handler
}

func (ta *tempAuth) getUser(account, user, key string) *testUser <span class="cov8" title="1">{
        for _, tu := range ta.testUsers </span><span class="cov8" title="1">{
                if tu.Account == account &amp;&amp; tu.Username == user &amp;&amp; tu.Password == key </span><span class="cov8" title="1">{
                        return &amp;tu
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type cachedAuth struct {
        Groups  []string
        Expires int64
}

func (ta *tempAuth) getUserGroups(tu *testUser) []string <span class="cov8" title="1">{
        groups := []string{tu.Account, fmt.Sprintf("%s:%s", tu.Account, tu.Username)}
        isAdmin := false
        for _, r := range tu.Roles </span><span class="cov8" title="1">{
                if r == ".admin" </span><span class="cov8" title="1">{
                        isAdmin = true
                }</span><span class="cov0" title="0"> else {
                        groups = append(groups, r)
                }</span>
        }
        <span class="cov8" title="1">if isAdmin </span><span class="cov8" title="1">{
                for _, r := range ta.resellers </span><span class="cov8" title="1">{
                        groups = append(groups, r+tu.Account)
                }</span>
                <span class="cov8" title="1">if tu.AccountID != "" &amp;&amp; !common.StringInSlice(tu.AccountID, groups) </span><span class="cov8" title="1">{
                        groups = append(groups, tu.AccountID)
                }</span>
        }
        <span class="cov8" title="1">return groups</span>
}

func (ta *tempAuth) handleGetToken(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{

        if request.Method != "GET" </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
                return
        }</span>
        <span class="cov8" title="1">user := request.Header.Get("X-Auth-User")
        parts := strings.Split(user, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 401)
                return
        }</span>
        <span class="cov8" title="1">account := parts[0]
        user = parts[1]
        password := request.Header.Get("X-Auth-Key")
        tUser := ta.getUser(account, user, password)
        if tUser == nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, 401)
                return
        }</span>
        <span class="cov8" title="1">var token string
        ctx := GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">var prevToken string
        userGroups := ta.getUserGroups(tUser)
        if err := ctx.Cache.GetStructured("authuser:"+user, &amp;prevToken); err == nil </span><span class="cov8" title="1">{
                var ca cachedAuth
                if err = ctx.Cache.GetStructured("auth:"+prevToken, &amp;ca); err == nil </span><span class="cov8" title="1">{
                        if ca.Expires &gt; time.Now().Unix() &amp;&amp; len(userGroups) == len(ca.Groups) </span><span class="cov0" title="0">{
                                eq := true
                                for i, r := range userGroups </span><span class="cov0" title="0">{
                                        if r != ca.Groups[i] </span><span class="cov0" title="0">{
                                                eq = false
                                        }</span>
                                }
                                <span class="cov0" title="0">if eq </span><span class="cov0" title="0">{
                                        token = prevToken
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if token == "" </span><span class="cov8" title="1">{
                token = ta.reseller + common.UUID()
                now := time.Now().Unix()
                ctx.Cache.Set("auth:"+token, &amp;cachedAuth{Expires: now + 86400, Groups: userGroups}, 86400)
                ctx.Cache.Set("authuser:"+user, &amp;token, 86400)
        }</span>

        <span class="cov8" title="1">ctx.RemoteUsers = []string{user}
        writer.Header().Set("X-Storage-Token", token)
        writer.Header().Set("X-Auth-Token", token)
        if tUser.Url != "" </span><span class="cov0" title="0">{
                writer.Header().Set("X-Storage-URL", tUser.Url)
        }</span><span class="cov8" title="1"> else {
                writer.Header().Set("X-Storage-URL", fmt.Sprintf("http://%s/v1/%s%s", request.Host, ta.reseller, account))
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, 200)</span>

}

func (ta *tempAuth) getReseller(account string) (string, bool) <span class="cov8" title="1">{
        // dosn't handle empty resellers yet
        if strings.HasPrefix(account, ta.reseller) </span><span class="cov8" title="1">{
                return ta.reseller, true
        }</span>
        <span class="cov8" title="1">for _, r := range ta.resellers </span><span class="cov8" title="1">{
                if strings.HasPrefix(account, r) </span><span class="cov8" title="1">{
                        return r, true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

func (ta *tempAuth) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if request.URL.Path == "/auth/v1.0" </span><span class="cov0" title="0">{
                ta.handleGetToken(writer, request)
                return
        }</span><span class="cov8" title="1"> else if strings.HasPrefix(request.URL.Path, "/v1") || strings.HasPrefix(request.URL.Path, "/V1") </span><span class="cov8" title="1">{
                token := request.Header.Get("X-Auth-Token")
                if token == "" </span><span class="cov0" title="0">{
                        token = request.Header.Get("X-Storage-Token")
                }</span>
                <span class="cov8" title="1">ctx := GetProxyContext(request)
                if ctx == nil </span><span class="cov0" title="0">{
                        ta.next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">if ctx.Authorize == nil </span><span class="cov8" title="1">{
                        pathParts, err := common.ParseProxyPath(request.URL.Path)
                        if err != nil </span><span class="cov0" title="0">{
                                ta.next.ServeHTTP(writer, request)
                                return
                        }</span>
                        <span class="cov8" title="1">if token != "" &amp;&amp; strings.HasPrefix(token, ta.reseller) </span><span class="cov8" title="1">{
                                if curReseller, ok := ta.getReseller(pathParts["account"]); ok &amp;&amp; curReseller == ta.reseller </span><span class="cov8" title="1">{
                                        var ca cachedAuth
                                        if err := ctx.Cache.GetStructured("auth:"+token, &amp;ca); err != nil </span><span class="cov0" title="0">{
                                                ctx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{
                                                        return false, http.StatusUnauthorized
                                                }</span>
                                        }<span class="cov8" title="1"> else {
                                                if st := request.Header.Get("X-Service-Token"); st != "" </span><span class="cov0" title="0">{
                                                        var caSt cachedAuth
                                                        if err := ctx.Cache.GetStructured("auth:"+st, &amp;caSt); err == nil </span><span class="cov0" title="0">{
                                                                for _, g := range caSt.Groups </span><span class="cov0" title="0">{
                                                                        ca.Groups = append(ca.Groups, g)
                                                                }</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">ctx.RemoteUsers = ca.Groups
                                                ctx.Authorize = ta.authorize</span>
                                        }
                                }<span class="cov0" title="0"> else if ok </span><span class="cov0" title="0">{
                                        ctx.Authorize = ta.authorize
                                }</span>
                        }<span class="cov8" title="1"> else {
                                if _, ok := ta.getReseller(pathParts["account"]); ok </span><span class="cov8" title="1">{
                                        // i do handle the req's reseller auth. allow anonymous authorize
                                        ctx.Authorize = ta.authorize
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">ta.next.ServeHTTP(writer, request)</span>
}

func (ta *tempAuth) authorize(r *http.Request) (bool, int) <span class="cov8" title="1">{
        pathParts, err := common.ParseProxyPath(r.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                return false, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                return true, http.StatusOK
        }</span>
        <span class="cov8" title="1">reseller, ok := ta.getReseller(pathParts["account"])
        if !ok </span><span class="cov8" title="1">{
                return false, http.StatusUnauthorized
        }</span>
        <span class="cov8" title="1">ctx := GetProxyContext(r)
        if ctx == nil </span><span class="cov0" title="0">{
                return false, http.StatusUnauthorized
        }</span>
        <span class="cov8" title="1">s := http.StatusUnauthorized
        if len(ctx.RemoteUsers) != 0 </span><span class="cov8" title="1">{
                s = http.StatusForbidden
        }</span>
        <span class="cov8" title="1">if common.StringInSlice(".reseller_admin", ctx.RemoteUsers) &amp;&amp;
                !common.StringInSlice(pathParts["account"], ta.resellers) &amp;&amp;
                !strings.HasPrefix(pathParts["account"], ".") </span><span class="cov8" title="1">{
                ctx.StorageOwner = true
                return true, http.StatusOK
        }</span>
        <span class="cov8" title="1">if common.StringInSlice(pathParts["account"], ctx.RemoteUsers) &amp;&amp;
                (pathParts["container"] != "" || !common.StringInSlice(r.Method, []string{"PUT", "DELETE"})) </span><span class="cov8" title="1">{
                // The user is admin for the account and is not trying to do an account DELETE or PUT
                var requireGroups []string
                if rule, ok := ta.accountRules[reseller]; ok </span><span class="cov8" title="1">{
                        requireGroups = rule["require_group"]
                }</span>
                <span class="cov8" title="1">if len(requireGroups) == 0 </span><span class="cov8" title="1">{
                        ctx.StorageOwner = true
                        return true, http.StatusOK
                }</span><span class="cov8" title="1"> else {
                        for _, rg := range requireGroups </span><span class="cov8" title="1">{
                                if common.StringInSlice(rg, ctx.RemoteUsers) </span><span class="cov8" title="1">{
                                        ctx.StorageOwner = true
                                        return true, http.StatusOK
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">referrers, roles := ParseACL(ctx.ACL)
        if auth, _ := AuthorizeUnconfirmedIdentity(r, pathParts["object"], referrers, roles); auth </span><span class="cov8" title="1">{
                return true, http.StatusOK
        }</span>
        <span class="cov8" title="1">for _, ru := range ctx.RemoteUsers </span><span class="cov8" title="1">{
                if common.StringInSlice(ru, roles) </span><span class="cov8" title="1">{
                        return true, http.StatusOK
                }</span>
        }
        <span class="cov8" title="1">return false, s</span>
}

func NewTempAuth(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        users := []testUser{}
        defaultRules := map[string][]string{"require_group": {}}
        resellerPrefixes, accountRules := conf.ReadResellerOptions(config, defaultRules)
        reseller := resellerPrefixes[0]
        for key, val := range config.Section </span><span class="cov0" title="0">{
                keyparts := strings.Split(key, "_")
                valparts := strings.Fields(val)
                if len(keyparts) != 3 || keyparts[0] != "user" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">account, user := keyparts[1], keyparts[2]
                vallen := len(valparts)
                if vallen &lt; 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">url := ""
                accountID := reseller + account
                groups := []string{}
                if vallen &gt; 1 </span><span class="cov0" title="0">{
                        urlSpot := 0
                        s := valparts[vallen-1]
                        if strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://") </span><span class="cov0" title="0">{
                                urlSpot = 1
                                url = s
                                urlParts := strings.Split(url, "/")
                                accountID = urlParts[len(urlParts)-1]
                        }</span>
                        <span class="cov0" title="0">for _, group := range valparts[1 : vallen-urlSpot] </span><span class="cov0" title="0">{
                                groups = append(groups, group)
                        }</span>
                }

                <span class="cov0" title="0">users = append(users, testUser{account, user, valparts[0], groups, url, accountID})</span>
        }
        <span class="cov0" title="0">RegisterInfo("tempauth", map[string]interface{}{"account_acls": false})
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;tempAuth{
                        next:         next,
                        testUsers:    users,
                        resellers:    resellerPrefixes,
                        reseller:     reseller,
                        accountRules: accountRules,
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file74" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "crypto/hmac"
        "crypto/sha1"
        "encoding/hex"
        "fmt"
        "net/http"
        "path/filepath"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

const (
        SCOPE_INVALID = iota
        SCOPE_ACCOUNT
        SCOPE_CONTAINER
)

type tuWriter struct {
        http.ResponseWriter
        method   string
        filename string
        obj      string
        expires  string
        inline   bool
}

func dispositionFormat(dtype string, filename string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s; filename=\"%s\"; filename*=UTF-8''%s",
                dtype, common.Urlencode(filename), common.Urlencode(filename))
}</span>

func (w *tuWriter) WriteHeader(status int) <span class="cov8" title="1">{
        if (w.method == "GET" || w.method == "HEAD") &amp;&amp; status/100 == 2 </span><span class="cov8" title="1">{
                for k := range w.Header() </span><span class="cov8" title="1">{
                        if strings.HasPrefix(k, "X-Object-Meta") &amp;&amp; !strings.HasPrefix(k, "X-Object-Meta-Public-") </span><span class="cov8" title="1">{
                                w.Header().Del(k)
                        }</span>
                }
                <span class="cov8" title="1">if w.inline </span><span class="cov8" title="1">{
                        if w.filename == "" </span><span class="cov8" title="1">{
                                w.Header().Set("Content-Disposition", "inline")
                        }</span><span class="cov8" title="1"> else {
                                w.Header().Set("Content-Disposition", dispositionFormat("inline", w.filename))
                        }</span>
                }<span class="cov8" title="1"> else if w.filename != "" </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Disposition", dispositionFormat("attachment", w.filename))
                }</span><span class="cov8" title="1"> else if w.Header().Get("Content-Disposition") == "" </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Disposition", dispositionFormat("attachment", filepath.Base(w.obj)))
                }</span>
                <span class="cov8" title="1">w.Header().Set("Expires", w.expires)</span>
        }
        <span class="cov8" title="1">w.ResponseWriter.WriteHeader(status)</span>
}

func checkhmac(key, sig []byte, method, path string, expires time.Time) bool <span class="cov8" title="1">{
        if method == "HEAD" </span><span class="cov8" title="1">{
                for _, meth := range []string{"HEAD", "GET", "POST", "PUT"} </span><span class="cov8" title="1">{
                        mac := hmac.New(sha1.New, key)
                        fmt.Fprintf(mac, "%s\n%d\n%s", meth, expires.Unix(), path)
                        if hmac.Equal(sig, mac.Sum(nil)) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }<span class="cov8" title="1"> else {
                mac := hmac.New(sha1.New, key)
                fmt.Fprintf(mac, "%s\n%d\n%s", method, expires.Unix(), path)
                return hmac.Equal(sig, mac.Sum(nil))
        }</span>
}

func tempurl(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                if request.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">ctx := GetProxyContext(request)
                if ctx.Authorize != nil </span><span class="cov8" title="1">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">q := request.URL.Query()
                sig := q.Get("temp_url_sig")
                exps := q.Get("temp_url_expires")
                _, inline := q["inline"]

                if sig == "" &amp;&amp; exps == "" </span><span class="cov8" title="1">{
                        next.ServeHTTP(writer, request)
                        return
                }</span><span class="cov8" title="1"> else if sig == "" || exps == "" </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, 401)
                        return
                }</span>

                <span class="cov8" title="1">expires, err := common.ParseDate(exps)
                if err != nil || time.Now().After(expires) </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, 401)
                        return
                }</span>

                <span class="cov8" title="1">sigb, err := hex.DecodeString(sig)
                if err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, 401)
                        return
                }</span>

                <span class="cov8" title="1">apiReq, account, container, obj := getPathParts(request)
                if !apiReq || account == "" || container == "" </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, 401)
                        return
                }</span>

                <span class="cov8" title="1">if bh := request.Header.Get("X-Object-Manifest"); bh != "" &amp;&amp; (request.Method == "PUT" || request.Method == "POST") </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, 400)
                        return
                }</span>

                <span class="cov8" title="1">path := ""
                if _, hasPrefix := q["temp_url_prefix"]; hasPrefix </span><span class="cov8" title="1">{
                        prefix := q.Get("temp_url_prefix")
                        if !strings.HasPrefix(obj, prefix) </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 401)
                                return
                        }</span>
                        <span class="cov8" title="1">path = fmt.Sprintf("prefix:/v1/%s/%s/%s", account, container, prefix)</span>
                }<span class="cov8" title="1"> else {
                        path = fmt.Sprintf("/v1/%s/%s/%s", account, container, obj)
                }</span>

                <span class="cov8" title="1">scope := SCOPE_INVALID
                if ai, err := ctx.GetAccountInfo(account); err == nil </span><span class="cov8" title="1">{
                        if key, ok := ai.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov8" title="1">{
                                scope = SCOPE_ACCOUNT
                        }</span><span class="cov8" title="1"> else if key, ok := ai.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov0" title="0">{
                                scope = SCOPE_ACCOUNT
                        }</span><span class="cov8" title="1"> else if ci, err := ctx.C.GetContainerInfo(account, container); err == nil </span><span class="cov8" title="1">{
                                if key, ok := ci.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov8" title="1">{
                                        scope = SCOPE_CONTAINER
                                }</span><span class="cov8" title="1"> else if key, ok := ci.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov0" title="0">{
                                        scope = SCOPE_CONTAINER
                                }</span>
                        }
                }
                <span class="cov8" title="1">if scope == SCOPE_INVALID </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, 401)
                        return
                }</span>
                <span class="cov8" title="1">ctx.RemoteUsers = []string{".tempurl"}
                ctx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov8" title="1">{
                        ar, a, c, _ := getPathParts(r)
                        if ar &amp;&amp; ((scope == SCOPE_ACCOUNT &amp;&amp; a == account) || (scope == SCOPE_CONTAINER &amp;&amp; c == container)) </span><span class="cov8" title="1">{
                                return true, http.StatusOK
                        }</span>
                        <span class="cov8" title="1">return false, http.StatusUnauthorized</span>
                }

                <span class="cov8" title="1">next.ServeHTTP(
                        &amp;tuWriter{
                                ResponseWriter: writer,
                                method:         request.Method,
                                obj:            obj,
                                filename:       q.Get("filename"),
                                expires:        expires.Format(time.RFC1123),
                                inline:         inline,
                        },
                        request,
                )</span>
        })
}

func NewTempURL(config conf.Section) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("tempurl", map[string]interface{}{
                "methods":                 []string{"GET", "HEAD", "PUT", "POST", "DELETE"},
                "incoming_remove_headers": []string{"x-timestamp"},
                "incoming_allow_headers":  []string{},
                "outgoing_remove_headers": []string{"x-object-meta-*"}, "outgoing_allow_headers": []string{"x-object-meta-public-*"},
        })
        return tempurl, nil
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "mime"
        "net/http"
        "path/filepath"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"
)

func (server *ProxyServer) ObjectGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">srv.StandardResponse(writer, 404)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.ReadACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.GetObject(vars["account"], vars["container"], vars["obj"], request.Header)
        for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)
        common.Copy(resp.Body, writer)
        resp.Body.Close()</span>
}

func (server *ProxyServer) ObjectHeadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">srv.StandardResponse(writer, 404)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.ReadACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.HeadObject(vars["account"], vars["container"], vars["obj"], request.Header)
        for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        writer.WriteHeader(resp.StatusCode)</span>
}

func (server *ProxyServer) ObjectDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">srv.StandardResponse(writer, 404)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.WriteACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.DeleteObject(vars["account"], vars["container"], vars["obj"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ObjectPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">srv.StandardResponse(writer, 404)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.WriteACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.PostObject(vars["account"], vars["container"], vars["obj"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ObjectPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if !(request.Header.Get("If-None-Match") == "" ||
                request.Header.Get("If-None-Match") == "*") </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, "If-None-Match only supports *")
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">srv.StandardResponse(writer, 404)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.WriteACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if request.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                contentType := mime.TypeByExtension(filepath.Ext(vars["obj"]))
                contentType = strings.Split(contentType, ";")[0] // remove any charset it tried to foist on us
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
                <span class="cov0" title="0">request.Header.Set("Content-Type", contentType)</span>
        }
        <span class="cov0" title="0">if status, str := CheckObjPut(request, vars["obj"]); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/plain")
                writer.WriteHeader(status)
                writer.Write([]byte(str))
                return
        }</span>
        <span class="cov0" title="0">resp := ctx.C.PutObject(vars["account"], vars["container"], vars["obj"], request.Header, request.Body)
        resp.Body.Close()
        writer.Header().Set("Etag", resp.Header.Get("Etag"))
        if modified, err := common.ParseDate(request.Header.Get("X-Timestamp")); err == nil </span><span class="cov0" title="0">{
                writer.Header().Set("Last-Modified", common.FormatLastModified(modified))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, resp.StatusCode)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
